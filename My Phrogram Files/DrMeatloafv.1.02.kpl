//in-game cheats for your testing pleasure/unlockables for beta:
	//set difficulty in game
		//1 = easy
		//2 = medium
		//3 = hard
		//4 = Chesney - sadly, this is uber-easy, not uber-hard, for your easy testing
		//5 = god - unlockable only - this is uber-hard
	//health cheats
		//period = send health up- bar will go down
		//comma = send health down- bar will go up
	//time
		//t = gain more time
		//y = subtract time
	//other 
		//i = switch invincible
			//note: will stil take damage from enemies, just won't die. If health = 0, and you switch invincibility off, you die
		//u = unlock level 5, have to enter key during play
		//z = shows cell coordinates

Program DrMeatloaf
	
	Class Difficulty
		Define enemyhurt As Integer//how much the enemy will hurt the player at this difficulty
		Define goodFoodBonus As Integer//how the good food will help the player at this difficulty
		Define AITransfer As Decimal//the distance at which enemies begin to intercept the player
		//Define playerSpeeds As Decimal[3]
		//Define enemySpeed As Decimal
		Method loadDifficulty(hurt As Integer, bonus As Integer, transfer As Decimal)//
			enemyhurt = hurt
			goodFoodBonus = bonus
			AItransfer = transfer +1
		End Method
		
		
	End Class
	
	
	
	Class goodFood 
		Define xpos As Decimal// x position of the good food in the maze
		Define ypos As Decimal// y position of the good food in the maze
		
		Define psprite As Sprite//sprite that is defined to this good food
		Define cellsize As Integer//size of the cells
		Define active As Boolean = False//should the good food still be shown
		Define isReal As Boolean = False//does this good food exist at all
		Define picture As String//picture that goes with the sprite
		Define isLoaded As Boolean = False//is the picture loaded to the sprite
		
		Method loadFood(x As Integer, y As Integer, pic As String, c As Integer)
			cellsize = c//input cell size
			picture = pic//adds the picture
			xpos = x//set initial x postion
			ypos = y//sets initial y position
			active = True//good food is alive
			isReal = True//good food exists
		End Method
		
		Method Load()
			psprite.Load(picture)//loads the sprites
			psprite.Scale(100*(cellsize-4)/This.psprite.Width,100*(cellsize-4)/This.psprite.Height)//scales them to the cell
			isLoaded = True//make sure sprite has been loaded
			active = True//sprite is active
		End Method
		
		Method unload()
			psprite.hide()//hides the sprite
			psprite.Unload()//unloads picture from memory
			isLoaded = False//picture is now notloaded
		End Method
		
		Method changepos(x As Decimal, y As Decimal, movex As Integer, movey As Integer)//moves the sprite
			xpos = x//sets x position equal to x
			ypos = y//sets y position equal to y
			psprite.moveto( movex + cellsize/2 - psprite.Width/2, movey+ cellsize/2 - psprite.Height/2)//moves it apptoptiate position
		End Method
	End Class
	
	//level class
	//contains maze, size, etc. for each level
	//created 19Oct2009 by Kevin Meyer
	Class Level
		Define rows As Integer = 15//gives you size
		Define columns As Integer = 15
		Define removeLeft As Cell[rows*columns]//what walls should be removed
		Define removeUp As Cell[rows * columns]
		Define removeRight As Cell[rows * columns]
		Define removeDown As Cell[rows * columns]
		Define enemyset As enemy[rows*columns]//what enemies for level
		Define invalidLocations As Cell[rows*columns]//use this to say what locations are actually in the maze
		//means an enemy or prize can't be put in a dead zone
		//Define goodpic As String
		Define goodFoods As goodFood[rows*columns]//what good foods for level
		Define SpawnLocations As Cell[rows*columns]//enemy spawn locations
		Define Maze As cell[rows *columns]//the maze
		Define totalfoods As Integer//total number of good foods
		Define foodseaten As Integer//number of foods eaten
		Define picture As String
		Define music As Sound//level music
		Define mus As String
		Define time As Integer//time limit
		Define barName As String//label of health bar
		Define hasbeenBeaten As Boolean[5] 
		//loadslevel
		Method loadLevelPt1(remLeft As cell[], remUp As cell[],remRight As cell[],remDown As cell[], music As String, t As Integer, bname As String, Invalid As cell[])
			//input what walls to remove
			removeLeft = remLeft
			removeUp = remUp
			removeRight = remRight
			removeDown = remDown
			mus = music//input music file
			time = t//set time limit
			barname = bname//set label on health bar
			Define i As Integer
			For i = 1 To arraylength(hasbeenbeaten)
				hasbeenbeaten[i] = False
			Next
			invalidLocations = invalid//invalid locations
		End Method
			
		Method LoadLevelpt2(spawn As Cell[], enset As enemy[], foods As goodFood[])	
			goodfoods = foods//set of good foods
			enemyset = enset//set of enemies
			SpawnLocations = spawn//spawn locations
			totalfoods = arraylength(foods)//gets total number of foods
		End Method	
		
		//Notes: load level required two parts because part 1 gives yiu the info to assemble the maze which is required for all the stuff in part 2
		//all the arrays are rows * columns because can't create emptyended arrays
		
	End Class
	//cell class
	//created 14Oct2009 by Kevin Meyer
	Class Cell
		
		
		//Booleans for if can go through to the name direction
		Define left As Boolean//can go through left, true = yes
		Define up As Boolean//can go through up, true = yes
		Define right As Boolean//see above re right
		Define Down As Boolean//same re down
		
		//index within array(add one when calling)+row and column
		Define index As Integer//location
		Define row As Integer//Cell location in y direction top to bottom in array
		Define column As Integer//cell location in x left to right
		Define xpos As Decimal//relative x position
		Define ypos As Decimal//relative y position
		Define containsEnemy As Boolean = False
		Define invalidLoc As Boolean = False
		
		
	End Class
	//(15Oct09,Boshen) created player class, this is the player's sprite
	//(15Oct09, Kevin) created convertX,Y method, allows for changing of maze 
	//location to plot location function more easily. 
	//added Dr. Meatloaf sprite in place of black box Chase 401 PM 19OCT2009
	Class Player
		Define startx As Decimal//staring x position
		Define starty As Decimal//starting y position
		Define xpos As Decimal//current xposition
		Define ypos As Decimal//current yposition
		Define Direction As Integer //0 = up, 1 = right, 2 = down, 3 = left
		Define psprite As Sprite//player sprite
		Define pspriteU As Sprite//up down left right version of player sprite
		Define pspriteL As Sprite
		Define pspriteR As Sprite
		Define pspriteD As Sprite
		Define cellsize As Integer//cell size
		Define health As Integer//health - scale 0 to 100
		Define playerSpeed As Decimal//how fast is player
		Define isReal As Boolean = False//
		Define hasBeenLoaded As Boolean = False//has the sprite been loaded --error handling
		Define enemiesHit As Integer
		Define goodFoodsHit As Integer
		Define maxHealth As Integer
		Define MinHealth As Integer
		Define score As Integer
		Define lives As Integer//lives remaining
		Define hasBeenHit As Boolean//ensure can no be hit by enemies that can't be hit by more than one enemy in frame
		Define upKey As String//will move up, down etc. if you hit this key
		Define downKey As String
		Define rightKey As String
		Define leftKey As String
		Define invincible As Boolean = False
		
		
		
		Method setPlayerSpeed()//set speed according to health
			If health > 65 Then
				playerspeed = .16
			Else If health >=35 Then
				playerspeed = .13
			Else 
				playerSpeed = .10
			End If
		End Method
		
		
		Method loadplayer(c As Integer)
			cellsize = c
			pspriteU.Load("Dr. Meatloaf Back.png")
			pspriteD.Load("Dr. Meatloaf Front.png")
			pspriteL.Load("Dr. Meatloaf Side.png")
			pspriteR.Load("Dr. Meatloaf Side.png")
			pspriteR.FlipHorizontal()//opp of left sprite
			pspriteU.Scale(100*(cellsize-4)/This.pspriteU.Width,100*(cellsize-4)/This.pspriteU.Height)//scale to cell
			pspriteD.Scale(100*(cellsize-4)/This.pspriteD.Width,100*(cellsize-4)/This.pspriteD.Height)
			pspriteL.Scale(100*(cellsize-4)/This.pspriteL.Width,100*(cellsize-4)/This.pspriteL.Height)
			pspriteR.Scale(100*(cellsize-4)/This.pspriteR.Width,100*(cellsize-4)/This.pspriteR.Height)
			health = 50
			psprite= pspriteL
			xpos = 8
			ypos = 8
			startx = xpos
			starty = ypos
			isReal = True
			hasBeenLoaded = True
			maxHealth = health
			minHealth = health
			enemiesHit = 0
			goodFoodsHit =0
			setPlayerSpeed()
			invincible = False
			
		End Method
		//lets you pick position
		Method loadplayer(x As Integer, y As Integer, c As Integer)
			cellsize = c
			pspriteU.Load("Dr. Meatloaf Back.png")
			pspriteD.Load("Dr. Meatloaf Front.png")
			pspriteL.Load("Dr. Meatloaf Side.png")
			pspriteR.Load("Dr. Meatloaf Side.png")
			pspriteR.FlipHorizontal()//opp of left sprite
			pspriteU.Scale(100*(cellsize-4)/This.pspriteU.Width,100*(cellsize-4)/This.pspriteU.Height)//scale to cell
			pspriteD.Scale(100*(cellsize-4)/This.pspriteD.Width,100*(cellsize-4)/This.pspriteD.Height)
			pspriteL.Scale(100*(cellsize-4)/This.pspriteL.Width,100*(cellsize-4)/This.pspriteL.Height)
			pspriteR.Scale(100*(cellsize-4)/This.pspriteR.Width,100*(cellsize-4)/This.pspriteR.Height)
			health = 50
			psprite= pspriteL
			xpos = x
			ypos = y
			startx = xpos
			starty = ypos
			isReal = True
			hasBeenLoaded = True
			maxHealth = health
			minHealth = health
			enemiesHit = 0
			goodFoodsHit =0
			setPlayerSpeed()
			invincible = False
			
		End Method
		Method changepos(x As Decimal, y As Decimal, movex As Integer, movey As Integer)//moves the sprite
			xpos = x//obvious
			ypos = y//obvious
			//centers sprites in cell
			//have to move them all at once
			psprite.moveto( movex + cellsize/2 - psprite.Width/2, movey+ cellsize/2 - psprite.Height/2)
			pspriteU.moveto(movex + cellsize/2 - pspriteU.Width/2, movey+ cellsize/2 - pspriteU.Height/2)
			pspriteD.moveto(movex + cellsize/2 - pspriteD.Width/2, movey+ cellsize/2 - pspriteD.Height/2)
			pspriteL.moveto(movex + cellsize/2 - pspriteL.Width/2, movey+ cellsize/2 - pspriteL.Height/2)
			pspriteR.moveto(movex + cellsize/2 - pspriteR.Width/2, movey+ cellsize/2 - pspriteR.Height/2)
		End Method
		
		//use to set score
		//If < 0, sets score = 0
		Method SetScore(n As Integer)
			If Not n > 0 Then
				score = 0
				Return
			End If
			score = n
		End Method
		
		//sets direction of player
		//see direction variable notes for meaning
		//created 10/16 by Kevin Meyer
		Method setDirection(a As Integer)
			If a<= 3 And a >= 0 Then 
				direction = a
			End If
		End Method
		
		//used to load and scale sprites
		Method Load(pic As String)
			psprite.Hide()
			psprite.Load(pic)
			psprite.Scale(100*(cellsize-4)/This.psprite.Width,100*(cellsize-4)/This.psprite.Height)
			psprite.Show()
		End Method

		//will load keys for player movements
		Method setKeys(up As String, Right As String, down As String, Left As String)
			upKey = up
			rightKey = right
			downKey = down
			leftKey = Left
		End Method
		
		//sets health on scale 0 - 100
		//called when hit enemy or goodfood
		Method setPlayerHealth( h As Integer)
			If h>100 Then
				health = 100
			Else If h<=0 Then
				health = 0
			Else 
				health = h	
			End If
			If health > maxHealth Then 
				maxHealth = health
			Else If health<MinHealth Then
				MinHealth = health
			End If
			setPlayerSpeed()
		End Method
		
	End Class
	
	//created by Kevin Meyer, 17Oct2009
	//added potato chip bag sprite instead of black box Chase 355 PM 19OCT2009
	Class Enemy
		Define xpos As Decimal//place in maze
		Define ypos As Decimal//place in maze
		Define Direction As Integer //0 = up, 1 = right, 2 = down, 3 = left
		Define psprite As Sprite//att. sprite
		Define cellsize As Integer//cellsize
		Define startX As Integer//starting xpos
		Define startY As Integer//starting ypos
		Define active As Boolean = False//iis alive
		Define isReal As Boolean = False//is real enemy in game or null if false
		Define picture As String//picture to be loaded
		Define isLoaded As Boolean = False//has it been loaded - use for errorhandling
		Define IsBurger As Boolean
		
		Method loadEnemy(x As Integer, y As Integer, pic As String, c As Integer)
			cellsize = c
			picture = pic
			//psprite.Load(pic)
			startY = y
			startX = x
			xpos = x
			ypos = y
			direction = 0
			active = True
			isReal = True
		End Method
		
		
		//same as player
		Method changepos(x As Decimal, y As Decimal, movex As Integer, movey As Integer)//moves the sprite
			xpos = x
			ypos = y
			psprite.moveto( movex + cellsize/2 - psprite.Width/2, movey+ cellsize/2 - psprite.Height/2)
		End Method
		
		//just changes x and y - doesn't display
		Method changepos(x As Decimal, y As Decimal)//moves the sprite - not anymore
			xpos = x
			ypos = y
		End Method
		
		//wil load picMethod
		Method Load()
			psprite.Load(picture)
			If Not isBurger Then
				psprite.Scale(100*(cellsize-4)/This.psprite.Width,100*(cellsize-4)/This.psprite.Height)
			Else
				psprite.Scale(100*(3*(cellsize)-4)/This.psprite.Width,100*(3*(cellsize)-4)/This.psprite.Height)
			End If
			isLoaded = True
			active = True
		End Method
		
		//unloads sprite
		Method unload()
			psprite.hide()
			If isloaded Then
				psprite.Unload()
			End If
			isLoaded = False
		End Method
		
		//same as player
		Method setDirection(a As Integer)
			If a<= 3 And a >= 0 Then 
				direction = a
			End If
		End Method
		
	End Class
	//(26Oct09, Boshen) just displays a simple red bar showing how much health you have
	Class bar// use for progress/time/health
		Define width As Integer
		Define x As Integer
		Define y As Integer 
		Define height As Integer
		Define label As String//label under healthbar
		Define icon As sprite//get sput next to bar
		Define pic As String//image for icon
		Define isloaded As Boolean = False//is pic loaded into icon - error handling
		Method loadbar(xpos As Integer, ypos As Integer,w As Integer, h As Integer, l As String, picture As String)
			x=xpos
			y=ypos
			height = h
			label = l
			width = w
			pic = picture
		End Method
		
		//converts to percentage for graphing
		Function converttodec(number As Decimal, max As Decimal) As Decimal// used For coverting health to decimal
			Return number/max
		End Function
		
		//loads icon
		Method Load()
			icon.Load(pic)
			icon.scale(100*30/icon.Width,100*30/icon.Height)
			icon.MoveTo(x-40,y)//loads the sprites
			isloaded = True
		End Method
		//unloads icon
		Method unload()
			icon.hide()//hides the sprite
			icon.Unload()//unloads picture from memory
			isLoaded = False//picture is now notloaded
		End Method
		
		//draws bar
		Method draw(hp As Decimal)
			//draw rectangle
			pen(False)
			moveto(x+1,y+1)
			If hp> 1 Then
				rectangle((width)-2,height-2,True)
			Else
				rectangle((hp*width)-2,height-2,True)
			End If
			color(black)
			pen(False)
			moveto(x,y)
			pen(True)
			moveto(x+width,y)
			moveto(x+width,y+height)
			moveto(x,y+height)
			moveto(x,y)
			pen(False)
			
			//print label
			moveto(x, y + 25)
			print(label)
		End Method
		Define blinkFrames As Integer = 7//number of frames to blink for
		Define blinkNumber As Integer = 0//current frame
		
		Method Blink(color As Integer)//will blink the  bar on or off en=very blinkFrames Frames
			
			While blinkNumber >= 2*blinkFrames
				blinkNumber -= 2*blinkFrames
			End While
			If blinkNumber < blinkFrames Then
				color(color)
			Else 
				color(white)
			End If
			blinkNumber+=1
		End Method
		
	End Class
	
	Class button
		Define buttonpic As Sprite
		Method loadbutton(x As Integer, y As Integer, pic As String)
			buttonpic.Load(pic)
			buttonpic.MoveTo(x,y)
			buttonpic.Show()
		End Method
		Function isclicked() As Boolean
			If leftpressed=True And buttonpic.ContainsPoint(mousex,mousey) Then
				Return True
			End If
			Return False
		End Function
	End Class
	//shows a fullscreen sprite that has nutritional info on the screen
	Class infoscreen
		Define info As sprite
		Method load(s As String)
			
			//build it
			clearMouseEvents()
			clearKeyBoardEvents()
			info.Load(s)
			info.scale(100*(screenwidth()/info.Width),100*(screenheight()/info.Height))
			info.Show()
			//while no input, loop
			While getKey() = "" And Not mouse.Event = "ButtonDown"
				delay(1)
			End While
			//leave
			info.unload()
			clearmouseevents()
			clearkeyboardevents()
		End Method
	End Class
	
	//variables
	//Define keepPlaying As Boolean = True//keepPlaying Y/N
	Define isCaught As Boolean = False//are you dead
	Define haswon As Boolean = False//have you won
	Define paused As Boolean = False//is the game paused
	
	
	Define yGap As Integer = 100//size of top for menus
	
	//Define totalTime As Integer = 60
	
	//size of maze
	
	//size of cells - can change
	Define cellSize As Integer = 50
	
	
	Define character As player
	Define player1 As Player
	Define player2 As Player
	Define Players As Player[2] = {player1,player2}
	//Players[1] = character
	
	
	Define EnemySpeed As Decimal = .08//speed of enemies /cells per frame/
	
	
	//Define levels here
	Define Level1 As Level
	Define Level2 As Level
	Define Level3 As Level
	Define Level4 As Level
	Define Level5 As Level
	Define Multi As Level
	//etc. 
	//infoscreens for each level
	Define lvlinfo As infoscreen
	
	Define diff As Integer//determines difficulty, 0 to 3,Chesney to Hard
	Define hard As Difficulty
	Define medium As Difficulty
	Define easy As Difficulty
	Define Chesney As Difficulty
	//we built Chesney so you(the graders) could test like crazy, and not have to worry about death or the timer
	//seriously, that's why it's caled Chesney
	//Also, level3 is a pain. Don't say I didn't warn you
	Define god As Difficulty
	
	Define cLevel As Integer//use for currentlevel()
	//sound 
	Define found As Sound//good food sound
	Define caught2 As Sound//enemy hit sound
	Define background As Sound//background musics for menus
	Define background2 As Sound//
	
	Define healthbar As bar//health bar
	Define progress As bar//progress in level
	Define timeBar As bar//time remaining
	
	Define healthbar1 As bar//multi for you know what
	Define healthbar2 As bar
	Define timebar2 As bar
	
	Define totalGameTime As Decimal//time in level
	Define GameTimer As Timer//timer for the game
	
	Define currentmenu As String//what menu
	
	Define lifeSprite As Sprite//sprite for lives
	
	//use for level5 unlock cheatcode
	Define unlocked As Boolean[5]={False,False,False,False,False}
	
	//main method
	//created 14Oct2009 by Kevin Meyer
	Method Main()
		
		
		//currentlevel() = level1
		initGame()//loads game
		lvlinfo.load("Controls.png")
		mainmenu(background, background2)//calls menu
		While True
			While Not currentmenu = "q"//menu loading
				loadcurrentmenu(background, background2)
			End While
			
			If currentlevel() = multi Then//starts level
				initLevelMulti()
				runGameMulti()
			Else
				initLevel()
				runGame()//runs game
			End If
			If isKeyDown(escape)Or getKey() = escape Then 
				stop()// allows for quick exit
			End If
			delay(500)//quick transition is scary
			//seriously, erase the above line and see
			playAgain()//progress screen
		End While
		stop()
	End Method
	
	
	//general initialization
	//used to load and build entire game before entering
	//occasionally crashes - why???
	Method initGame()
		//size screen to size of maze
		//CellSize = getPlayerSize() * someNumber
		//reset screensize
		setScreenSize(600, 600)
		SetConsoleFont( "Arial", 14)
		SetConsoleFontStyle(True, False, False)
		SetConsoleBackgroundColor( Black )
		SetConsoleFontColor( White )
		SetConsoleTextAlignment( "Center" )
		//load sounds
		caught2.LoadFile("Hit.wav")
		found.LoadFile("Break.wav")
		background.LoadFile("level2.wav")
		background2.LoadFile("level.wav")
		//load difficulties
		hard.loadDifficulty(50, 5, 3.0)
		medium.loadDifficulty(40, 10, 2.0)
		easy.loadDifficulty(30, 15, 1.5)
		Chesney.loadDifficulty(0, 10, 2)
		god.loadDifficulty(100, 0 , 4.0)
		//load bars
		healthbar.loadbar(screenwidth()- 175,0,150,25,"Hypertension","carrot.png")
		progress.loadbar(screenwidth()-375,0,150,25,"Healthy Foods Found","carrot v.2.png")
		timeBar.loadbar(25,0,150,25, "Time Left","carrot.png")
		healthbar1.loadbar(25, 0 , 150, 25, "Player 1 Health","carrot.png")
		healthbar2.loadbar(425, 0 , 150, 25, "Player 2 Health","carrot.png")
		timebar2.loadbar(225, 0 , 150, 25, "TimeLeft","carrot.png")
		//set up keys
		character.setkeys(up,right,down,left)
		player1.setKeys("w","d","s","a")
		player2.setKeys(up,right,down,left)		
		
		//builds levels
		setlevel(1)		
		Define removeLeft As Cell[rows*columns] = {getCell(8,1),getcell(10,13),getcell(12,14),getCell(5,7),getcell(5,15),getCell(10,1),getcell(3,14),getCell(5,6),getCell(2,4),getcell(1,13),getcell(14,14),getcell(14,15),getcell(1,14),getCell(8,5),getCell(7,2),getcell(12,4),getcell(12,5),getcell(6,14),getcell(5,14),getcell(6,13),getCell(2,1),getcell(11,3),getCell(3,2),getcell(14,11),getcell(14,10),getcell(15,12),getcell(14,12),getCell(6,2),getcell(11,1),getcell(12,1),getCell(6,9),getcell(13,7),getcell(14,8),getcell(15,2),getcell(14,2),getcell(15,3),getCell(8,3),getCell(10,3),getCell(7,8),getCell(10,8),getcell(10,11),getcell(11,11),getcell(12,11),getCell(9,8),getcell(15,9),getcell(4,10),getcell(14,9),getcell(13,9),getCell(9,3),getCell(4,2),getCell(3,1),getCell(5,1),getCell(4,1),getCell(2,7),getCell(10,6),getCell(1,6),getCell(4,8),getCell(6,5),getCell(10,9),getCell(7,6),getCell(8,7),getCell(9,5)}
		//will remove the upper wall of these positions
		Define removeUp As Cell[rows*columns] = {getCell(7,3),getcell(10,15),getcell(12,12),getcell(9,15),getCell(1,9),getcell(2,15),getCell(1,10),getcell(15,12),getcell(15,11),getCell(4,9),getCell(13,5),getcell(14,13),getcell(14,14),getcell(12,15),getcell(1,15),getcell(7,14),getcell(7,13),getcell(13,6),getcell(12,5),getcell(7,12),getcell(5,13),getcell(4,14),getcell(4,13),getcell(4,12),getcell(4,11),getcell(11,5),getcell(13,4),getcell(14,11),getcell(13,11),getCell(5,7),getCell(3,8),getCell(3,7),getcell(15,2),getcell(13,2),getcell(13,3),getcell(12,8),getcell(12,7),getcell(13,7),getcell(14,8),getCell(1,2), getCell(2,6),getCell(2,5),getCell(5,4),getCell(9,6),getCell(7,10),getCell(8,9),getCell(5,6),getCell(9,8),getCell(1,10),getCell(6,1),getCell(6,4),getCell(6,3),getCell(6,5),getCell(5,3),getCell(6,6),getCell(6,7),getCell(6,8),getCell(9,10),getCell(6,10),getCell(6,9),getCell(5,2),getCEll(4,5), getCell(8,7), getCell(9,7)}
		//remove Right walls of these cells
		Define removeRight As Cell[rows*columns] = {getCell(8,2),getcell(10,13),getcell(10,12),getcell(12,13),getcell(12,12),getcell(6,11),getcell(7,11),getcell(8,11),getcell(3,14),getcell(4,14),getcell(3,15),getCell(10,6),getcell(14,15),getcell(14,14),getcell(12,14),getcell(3,14),getcell(7,15),getcell(6,14),getCell(11,6),getCell(13,6),getcell(5,12),getCell(14,6),getCell(15,6),getCell(5,7),getcell(11,3),getcell(12,3),getcell(4,11),getcell(5,11),getCell(1,10),getcell(13,4),getcell(11,2),getcell(10,7),getcell(11,8),getcell(10,8),getcell(12,1),getcell(15,1),getcell(14,4),getcell(14,5),getcell(15,5),getcell(15,4),getCell(2,9),getcell(15,8),getcell(15,10),getCell(4,9),getCell(2,10),getcell(10,10),getCell(2,8),getCell(1,8),getCell(3,7),getCell(8,1),getCell(7,10),getCell(9,5),getCell(7,8),getCell(8,4),getCell(8,9),getCell(3,6),getCell(2,6),getCell(1,6),getCell(1,3),getCell(2,3),getCell(3,3),getCell(4,3),getcell(1,1)}
		//remove Down walls of these cells
		Define removeDown As Cell[rows*columns] =  {getCell(1,1),getcell(11,15),getcell(11,13),getcell(11,14),getCell(9,11),getcell(2,10),getcell(2,11),getcell(2,12),getcell(2,13),getcell(1,11),getcell(1,12),getcell(14,15),getcell(1,15),getcell(12,15),getcell(2,15),getCell(6,10),getcell(3,11),getcell(3,12),getcell(8,12),getcell(8,13),getcell(8,14),getCell(6,12),getCell(6,14),getCell(6,15),getCell(9,12),getCell(9,13),getCell(9,14),getCell(9,15),getCell(10,3),getCell(3,3),getCell(4,9),getCell(3,4),getCell(3,5),getCell(7,5),getcell(15,6),getcell(15,7),getcell(15,8),getcell(15,9),getCell(7,4),getCell(5,4),getCell(1,3),getCell(10,4),getCell(10,1),getCell(6,1),getCell(7,1),getcell(11,9),getcell(12,9),getcell(12,10),getcell(12,8),getCell(7,3),getCell(9,10),getCell(10,8),getCell(10,2), getCell(1,2)}
		//locations that aren't actually part of the maze, isolated by walls etc.  
		Define InvalidLocations As Cell[rows*columns] = {getcell(3,15),getcell(4,15),getcell(5,15),getcell(5,12),getcell(6,12),getcell(1,11),getcell(1,12),getcell(1,13),getcell(5,13),getcell(6,13),getcell(7,15),getcell(3,11),getcell(3,12),getcell(3,13),getcell(8,12),getcell(8,13),getcell(8,14),getcell(8,15),getcell(11,2),getcell(11,7),getcell(11,4),getcell(11,5),getcell(11,9),getcell(11,10),getcell(11,12),getcell(12,2),getcell(12,4),getcell(12,5),getcell(12,13),getcell(13,8),getcell(13,10),getcell(13,11),getcell(13,13),getcell(13,15),getcell(14,1),getcell(14,3),getcell(14,5),getcell(14,7),getcell(14,8),getcell(14,10),getcell(14,11),getcell(14,15),getcell(15,3),getcell(15,5),getcell(15,13),getcell(15,13),getcell(15,15),getcell(10,12),getcell(10,14),getcell(10,15),getCell(2,2), getCell(3,2),getCell(4,2), getCell(4,4), getCell(4,5), getCell(1,5), getCell(8,2), getCell(9,2), getCell(8,4), getCell(9,4), getCell(1,7), getCell(2,7), getCell(2,9), getCell(3,9), getCell(7,7), getCell(8,7), getCell(8,6), getCell(5,8), getCell(5,10), getCell(10,7), getCell(10,10), getCell(7,9), getCell(7,10), getCell(8,10)} 
		currentlevel().loadLevelPt1(removeLeft,removeUp, removeRight, removeDown, "level6.wav", 45, "Hypertension", InvalidLocations)
		createMaze()//will build the maze
		//places for enemies to spawn
		Define SpawnLocations As Cell[10] = {getCell(3,8) ,getCell(5,3)  ,getCell(2,6) ,getCell(9,1), getCell(6,9),getcell(14,14),getcell(9,13),getcell(10,3),getcell(1,6),getcell(9,1)}
		//locations of good foods
		Define goodFoodLocations As Cell[20] = {getCell(5,1),getcell(7,1),getcell(11,11),getcell(14,9),getcell(12,14),getCell(3,4) ,getCell(10,1)  ,getCell(10,9)  ,getCell(1,8)  ,getCell(5,7),getcell(13,5),getcell(1,14),getcell(14,12),getcell(1,1),getcell(9,13),getcell(4,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6)}
		//gets actual good foods
		Define goodfoods As goodFood[20] = addGoodFoods(goodFoodLocations,"Carrot.png")
		//builds enemies
		Define enemySet As Enemy[10] = createEnemySet(10,SpawnLocations, "Potato Bag.png")
		//puts them all into level
		currentlevel().LoadLevelpt2(SpawnLocations, enemySet, goodfoods)
		//repaeat the above notes for every other single level in here
		
		
		setlevel(2)
		Define removeLeft2 As Cell[rows*columns] = {getcell(2,1),getcell(3,1),getcell(4,1),getcell(5,1),getcell(6,1),getcell(7,1),getcell(8,1),getcell(9,1),getcell(10,1),getcell(11,1),getcell(12,1),getcell(13,1),getcell(14,1),getcell(15,1),getcell(3,2),getcell(4,2),getcell(5,2),getcell(6,2),getcell(7,2),getcell(8,2),getcell(9,2),getcell(10,2),getcell(11,2),getcell(12,2),getcell(13,2),getcell(14,2),getcell(4,3),getcell(5,3),getcell(6,3),getcell(7,3),getcell(8,3),getcell(9,3),getcell(10,3),getcell(11,3),getcell(12,3),getcell(13,3),getcell(5,4),getcell(6,4),getcell(7,4),getcell(8,4),getcell(9,4),getcell(10,4),getcell(11,4),getcell(12,4),getcell(6,5),getcell(7,5),getcell(8,5),getcell(9,5),getcell(10,5),getcell(11,5),getcell(7,6),getcell(7,8),getcell(7,10),getcell(8,6),getcell(9,6),getcell(10,6),getcell(8,8),getcell(6,8),getcell(11,8),getcell(5,5),getcell(5,11),getcell(4,8),getcell(3,3),getcell(3,13),getcell(2,8),getcell(1,1)}		
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp2 As Cell[rows*columns] = {getcell(8,1),getcell(1,2),getcell(1,3),getcell(1,4),getcell(1,5),getcell(1,6),getcell(1,7),getcell(1,8),getcell(1,9),getcell(1,10),getcell(1,11),getcell(1,12),getcell(1,13),getcell(1,14),getcell(1,15),getcell(2,3),getcell(2,4),getcell(2,5),getcell(2,6),getcell(2,7),getcell(2,8),getcell(2,9),getcell(2,10),getcell(2,11),getcell(2,12),getcell(2,13),getcell(2,14),getcell(13,4),getcell(13,5),getcell(13,6),getcell(13,7),getcell(13,8),getcell(13,9),getcell(13,10),getcell(13,11),getcell(13,12),getcell(13,13),getcell(12,5),getcell(12,6),getcell(12,7),getcell(12,8),getcell(12,9),getcell(12,10),getcell(12,11),getcell(12,12),getcell(5,6),getcell(5,7),getcell(5,8),getcell(5,9),getcell(5,10),getcell(5,11),getcell(10,7),getcell(10,8),getcell(10,9),getcell(10,10),getcell(6,7),getcell(6,8),getcell(6,9),getcell(6,10),getcell(8,4),getcell(1,15)}
		//remove Right walls of these cells
		Define removeRight2 As Cell[rows*columns] = {getcell(1,15),getcell(2,15),getcell(3,15),getcell(4,15),getcell(5,15),getcell(6,15),getcell(7,15),getcell(8,15),getcell(9,15),getcell(10,15),getcell(11,15),getcell(12,15),getcell(13,15),getcell(14,15),getcell(2,14),getcell(3,14),getcell(4,14),getcell(5,14),getcell(6,14),getcell(7,14),getcell(8,14),getcell(9,14),getcell(10,14),getcell(11,14),getcell(12,14),getcell(13,14),getcell(3,13),getcell(4,13),getcell(5,13),getcell(6,13),getcell(7,13),getcell(8,13),getcell(9,13),getcell(10,13),getcell(11,13),getcell(12,13),getcell(4,12),getcell(5,12),getcell(6,12),getcell(7,12),getcell(8,12),getcell(9,12),getcell(10,12),getcell(11,12),getcell(5,11),getcell(6,11),getcell(7,11),getcell(8,11),getcell(9,11),getcell(10,11),getcell(8,8),getcell(9,8),getcell(7,10),getcell(8,10),getcell(9,10),getcell(11,5),getcell(11,11),getcell(12,8),getcell(13,3),getcell(13,13),getcell(14,8),getcell(15,1),getcell(15,15)}
		//remove Down walls of these cells
		Define removeDown2 As Cell[rows*columns] =  {getcell(15,1),getcell(15,2),getcell(15,3),getcell(15,4),getcell(15,5),getcell(15,6),getcell(15,7),getcell(15,8),getcell(15,9),getcell(15,10),getcell(15,11),getcell(15,12),getcell(15,13),getcell(15,14),getcell(14,2),getcell(14,3),getcell(14,4),getcell(14,5),getcell(14,6),getcell(14,7),getcell(14,8),getcell(14,9),getcell(14,10),getcell(14,11),getcell(14,12),getcell(14,13),getcell(3,3),getcell(3,4),getcell(3,5),getcell(3,6),getcell(3,7),getcell(3,8),getcell(3,9),getcell(3,10),getcell(3,11),getcell(3,12),getcell(4,4),getcell(4,5),getcell(4,6),getcell(4,7),getcell(4,8),getcell(4,9),getcell(4,10),getcell(4,11),getcell(11,5),getcell(11,6),getcell(11,7),getcell(11,8),getcell(11,9),getcell(11,10),getcell(8,6),getcell(8,7),getcell(8,8),getcell(8,9),getcell(8,10),getcell(8,5),getcell(8,12)}
		Define InvalidLocations2 As Cell[4] = {getCell(7,7), getCell(7,9),getCell(9,7),getCell(9,9)}
		currentlevel().loadLevelPt1(removeLeft2,removeUp2, removeRight2, removeDown2, "level4.wav", 45, "Obesity", InvalidLocations2)
		
		createMaze()
		Define SpawnLocations2 As Cell[10] = {getCell(3,8) ,getCell(5,3)  ,getCell(2,6) ,getCell(9,1), getCell(6,9),getcell(14,14),getcell(9,13),getcell(10,3),getcell(1,6),getcell(9,1)}
		Define goodFoodLocations2 As Cell[20] = {getCell(5,1),getcell(7,1),getcell(11,11),getcell(14,9),getcell(12,14),getCell(3,4) ,getCell(10,1)  ,getCell(10,9)  ,getCell(1,8)  ,getCell(5,7),getcell(13,5),getcell(1,14),getcell(14,12),getcell(1,1),getcell(9,13),getcell(4,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6)}
		Define goodfoods2 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations2,"Strawberry.png")
		Define enemySet2 As Enemy[10] = createEnemySet(10,SpawnLocations, "Donut.png")
		currentlevel().LoadLevelpt2(SpawnLocations2, enemySet2, goodfoods2)
				
		setlevel(3)
		Define removeLeft3 As Cell[rows*columns] = {getcell(3,11),getcell(4,11),getcell(3,8),getcell(2,7),getcell(1,11),getcell(4,13),getcell(1,12),getcell(3,5),getcell(2,5),getcell(1,13),getcell(15,12),getcell(5,5),getcell(6,6),getcell(5,6),getcell(3,1),getcell(5,2),getcell(4,2),getcell(4,4),getcell(5,11),getcell(5,7),getcell(6,7),getcell(7,7),getcell(6,8),getcell(6,2),getcell(8,13),getcell(6,13),getcell(7,12),getcell(7,13),getcell(7,14),getcell(7,15),getcell(7,2),getcell(8,1),getcell(9,1),getcell(10,1),getcell(13,14),getcell(14,2),getcell(11,14),getcell(13,13),getcell(7,11),getcell(8,11),getcell(9,11),getcell(15,1),getcell(13,9),getcell(15,2),getcell(14,5),getcell(15,4),getcell(12,7),getcell(14,7),getcell(13,7),getcell(10,12),getcell(11,12),getcell(12,12),getcell(11,11),getcell(9,8),getcell(1,1),getcell(8,8),getcell(9,4),getcell(8,10),getcell(10,3),getcell(11,3),getcell(8,3),getcell(9,2)}		
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp3 As Cell[rows*columns] = {getcell(2,12),getcell(2,11),getcell(2,10),getcell(1,11),getcell(4,13),getcell(2,14),getcell(2,13),getcell(1,15),getcell(15,14),getcell(15,15),getcell(3,2),getcell(4,11),getcell(4,10),getcell(4,9),getcell(4,8),getcell(5,13),getcell(5,12),getcell(9,15),getcell(9,14),getcell(7,2),getcell(14,10),getcell(14,11),getcell(14,12),getcell(14,13),getcell(14,14),getcell(14,1),getcell(6,10),getcell(6,11),getcell(11,2),getcell(11,1),getcell(13,2),getcell(14,6),getcell(14,7),getcell(11,11),getcell(1,1),getcell(2,3),getcell(7,8),getcell(7,7),getcell(7,6),getcell(8,7),getcell(8,6),getcell(9,5),getcell(9,6),getcell(9,7),getcell(9,8),getcell(11,4),getcell(11,5),getcell(11,6),getcell(11,7),getcell(11,8),getcell(11,9),getcell(9,4),getcell(10,1),getcell(10,2),getcell(10,3),getcell(10,15)}
		//remove Right walls of these cells
		Define removeRight3 As Cell[rows*columns] = {getcell(1,9),getcell(2,9),getcell(3,9),getcell(2,7),getcell(15,10),getcell(3,12),getcell(1,12),getcell(3,7),getcell(2,15),getcell(3,15),getcell(2,14),getcell(3,14),getcell(4,14),getcell(1,14),getcell(5,5),getcell(5,11),getcell(7,12),getcell(9,13),getcell(6,4),getcell(13,14),getcell(6,9),getcell(11,14),getcell(14,9),getcell(15,9),getcell(13,3),getcell(14,3),getcell(15,3),getcell(13,9),getcell(12,8),getcell(13,8),getcell(14,8),getcell(10,10),getcell(1,1),getcell(2,3),getcell(7,4),getcell(9,9),getcell(10,9),getcell(11,9),getcell(12,6),getcell(11,3),getcell(12,3)}
		//remove Down walls of these cells
		Define removeDown3 As Cell[rows*columns] =  {getcell(15,10),getcell(3,12),getcell(3,5),getcell(3,4),getcell(3,6),getcell(5,4),getcell(4,5),getcell(5,5),getcell(6,5),getcell(4,15),getcell(5,3),getcell(4,2),getcell(4,3),getcell(5,8),getcell(5,9),getcell(5,13),getcell(5,14),getcell(5,15),getcell(5,1),getcell(6,14),getcell(7,14),getcell(8,13),getcell(8,14),getcell(8,15),getcell(6,2),getcell(6,3),getcell(6,15),getcell(14,14),getcell(11,12),getcell(13,15),getcell(11,13),getcell(13,12),getcell(12,14),getcell(12,15),getcell(12,1),getcell(12,2),getcell(13,10),getcell(13,11),getcell(13,11),getcell(1,3),getcell(1,4),getcell(1,5),getcell(1,6),getcell(1,7),getcell(1,8),getcell(1,2),getcell(15,4),getcell(15,5),getcell(15,6),getcell(15,7),getcell(12,9),getcell(12,10),getcell(12,11),getcell(13,3),getcell(13,4),getcell(10,10),getcell(9,8),getcell(1,1),getcell(2,3),getcell(8,9),getcell(7,4),getcell(8,2),getcell(9,9),getcell(9,10),getcell(9,11),getcell(7,8),getcell(10,4),getcell(10,5),getcell(10,6),getcell(10,7),getcell(12,4),getcell(12,5)}
		Define InvalidLocations3 As Cell[rows*columns] = {getCell(2,2), getCell(3,2),getCell(4,2), getCell(4,4), getCell(4,5), getCell(1,5), getCell(8,2), getCell(9,2), getCell(8,4), getCell(9,4), getCell(1,7), getCell(2,7), getCell(2,9), getCell(3,9), getCell(7,7), getCell(8,7), getCell(8,6), getCell(5,8), getCell(5,10), getCell(10,7), getCell(10,10), getCell(7,9), getCell(7,10), getCell(8,10)} 
		currentlevel().loadLevelPt1(removeLeft3,removeUp3, removeRight3, removeDown3, "level5.wav", 45, "Diabetes", InvalidLocations3)
		createMaze()
		Define SpawnLocations3 As Cell[10] = {getCell(4,8) ,getCell(4,3)  ,getCell(3,6) ,getCell(9,1), getCell(6,9),getcell(14,14),getcell(11,13),getcell(10,3),getcell(1,6),getcell(9,1)}
		Define goodFoodLocations3 As Cell[20] = {getCell(5,1),getcell(7,1),getcell(11,12),getcell(14,9),getcell(12,14),getCell(3,4) ,getCell(10,1)  ,getCell(10,9)  ,getCell(1,8)  ,getCell(5,7),getcell(13,5),getcell(1,14),getcell(14,12),getcell(1,1),getcell(8,13),getcell(5,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6)}
		Define goodfoods3 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations3,"Milk.png")
		Define enemySet3 As Enemy[10] = createEnemySet(10,SpawnLocations3, "Soda.png")
		currentlevel().LoadLevelpt2(SpawnLocations3, enemySet3, goodfoods3)
				
		setlevel(4)
		Define removeLeft4 As Cell[rows*columns] = {getcell(1,1),getcell(1,3),getcell(1,5),getcell(1,7),getcell(1,9),getcell(1,11),getcell(1,13),getcell(1,15),getcell(1,2),getcell(2,2),getcell(3,2),getcell(4,2),getcell(5,2),getcell(6,2),getcell(7,2),getcell(8,2),getcell(9,2),getcell(10,2),getcell(11,2),getcell(12,2),getcell(13,2),getcell(14,2),getcell(15,2),getcell(1,4),getcell(2,4),getcell(3,4),getcell(4,4),getcell(5,4),getcell(6,4),getcell(7,4),getcell(8,4),getcell(9,4),getcell(10,4),getcell(11,4),getcell(12,4),getcell(13,4),getcell(14,4),getcell(15,4),getcell(1,6),getcell(2,6),getcell(3,6),getcell(4,6),getcell(5,6),getcell(6,6),getcell(7,6),getcell(8,6),getcell(9,6),getcell(10,6),getcell(11,6),getcell(12,6),getcell(13,6),getcell(14,6),getcell(15,6),getcell(1,8),getcell(2,8),getcell(3,8),getcell(4,8),getcell(5,8),getcell(6,8),getcell(7,8),getcell(8,8),getcell(9,8),getcell(10,8),getcell(11,8),getcell(12,8),getcell(13,8),getcell(14,8),getcell(15,8),getcell(1,10),getcell(2,10),getcell(3,10),getcell(4,10),getcell(5,10),getcell(6,10),getcell(7,10),getcell(8,10),getcell(9,10),getcell(10,10),getcell(11,10),getcell(12,10),getcell(13,10),getcell(14,10),getcell(15,10),getcell(1,12),getcell(2,12),getcell(3,12),getcell(4,12),getcell(5,12),getcell(6,12),getcell(7,12),getcell(8,12),getcell(9,12),getcell(10,12),getcell(11,12),getcell(12,12),getcell(13,12),getcell(14,12),getcell(15,12),getcell(1,14),getcell(2,14),getcell(3,14),getcell(4,14),getcell(5,14),getcell(6,14),getcell(7,14),getcell(8,14),getcell(9,14),getcell(10,14),getcell(11,14),getcell(12,14),getcell(13,14),getcell(14,14),getcell(15,14)}
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp4 As Cell[rows*columns] = {getcell(2,1),getcell(2,2)}
		//remove Right walls of these cells
		Define removeRight4 As Cell[rows*columns] = {getcell(1,2),getcell(2,2)}
		//remove Down walls of these cells
		Define removeDown4 As Cell[rows*columns] =  {getcell(1,15),getcell(3,15),getcell(5,15),getcell(7,15),getcell(9,15),getcell(11,15),getcell(13,15),getcell(15,15),getcell(2,1),getcell(2,2),getcell(2,3),getcell(2,4),getcell(2,5),getcell(2,6),getcell(2,7),getcell(2,8),getcell(2,9),getcell(2,10),getcell(2,11),getcell(2,12),getcell(2,13),getcell(2,14),getcell(2,15),getcell(4,1),getcell(4,2),getcell(4,3),getcell(4,4),getcell(4,5),getcell(4,6),getcell(4,7),getcell(4,8),getcell(4,9),getcell(4,10),getcell(4,11),getcell(4,12),getcell(4,13),getcell(4,14),getcell(4,15),getcell(6,1),getcell(6,2),getcell(6,3),getcell(6,4),getcell(6,5),getcell(6,6),getcell(6,7),getcell(6,8),getcell(6,9),getcell(6,10),getcell(6,11),getcell(6,12),getcell(6,13),getcell(6,14),getcell(6,15),getcell(8,1),getcell(8,2),getcell(8,3),getcell(8,4),getcell(8,5),getcell(8,6),getcell(8,7),getcell(8,8),getcell(8,9),getcell(8,10),getcell(8,11),getcell(8,12),getcell(8,13),getcell(8,14),getcell(8,15),getcell(10,1),getcell(10,2),getcell(10,3),getcell(10,4),getcell(10,5),getcell(10,6),getcell(10,7),getcell(10,8),getcell(10,9),getcell(10,10),getcell(10,11),getcell(10,12),getcell(10,13),getcell(10,14),getcell(10,15),getcell(12,1),getcell(12,2),getcell(12,3),getcell(12,4),getcell(12,5),getcell(12,6),getcell(12,7),getcell(12,8),getcell(12,9),getcell(12,10),getcell(12,11),getcell(12,12),getcell(12,13),getcell(12,14),getcell(12,15),getcell(14,1),getcell(14,2),getcell(14,3),getcell(14,4),getcell(14,5),getcell(14,6),getcell(14,7),getcell(14,8),getcell(14,9),getcell(14,10),getcell(14,11),getcell(14,12),getcell(14,13),getcell(14,14),getcell(14,15)}
		Define InvalidLocations4 As Cell[] = level4invalid()//= {getCell(2,2), getCell(3,2),getCell(4,2), getCell(4,4), getCell(4,5), getCell(1,5), getCell(8,2), getCell(9,2), getCell(8,4), getCell(9,4), getCell(1,7), getCell(2,7), getCell(2,9), getCell(3,9), getCell(7,7), getCell(8,7), getCell(8,6), getCell(5,8), getCell(5,10), getCell(10,7), getCell(10,10), getCell(7,9), getCell(7,10), getCell(8,10)} 
		currentlevel().loadLevelPt1(removeLeft4,removeUp4, removeRight4, removeDown4, "level7.wav", 45,"Atherosclerosis", invalidLocations4)
		createMaze()
		Define SpawnLocations4 As Cell[10] = {getCell(3,8) ,getCell(6,3)  ,getCell(2,6) ,getCell(10,1), getCell(6,9),getcell(14,14),getcell(10,13),getcell(10,3),getcell(1,6),getcell(10,1)}
		Define goodFoodLocations4 As Cell[20] = {getCell(6,1),getcell(8,1),getcell(12,11),getcell(14,9),getcell(12,14),getCell(3,4) ,getCell(10,15),getCell(10,9),getCell(1,8),getCell(6,7),getcell(14,5),getcell(1,14),getcell(14,12),getcell(2,1),getcell(10,13),getcell(4,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6)}
		Define goodfoods4 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations4,"Green Apple.png")
		Define enemySet4 As Enemy[10] = createEnemySet(10,SpawnLocations4, "Fries.png")
		currentlevel().LoadLevelpt2(SpawnLocations4, enemySet4, goodfoods4)
				
		setlevel(5)
		Define removeLeft5 As Cell[rows*columns] = {getcell(1,8),getcell(3,7),getcell(2,7),getcell(15,7),getcell(14,7),getcell(2,9),getcell(1,9),getcell(15,9),getcell(1,14),getcell(1,15),getcell(2,2),getcell(1,2),getcell(15,2),getcell(14,2),getcell(1,11),getcell(1,12),getcell(4,2),getcell(6,2),getcell(5,2),getcell(13,2),getcell(12,3),getcell(7,2),getcell(8,2),getcell(9,2),getcell(10,2),getcell(14,13),getcell(4,13),getcell(13,13),getcell(3,13),getcell(11,4),getcell(10,4),getcell(9,4),getcell(8,4),getcell(7,4),getcell(6,4),getcell(13,5),getcell(12,5),getcell(6,6),getcell(7,6),getcell(8,6),getcell(9,6),getcell(10,6),getcell(11,6),getcell(11,10),getcell(10,10),getcell(9,10),getcell(8,10),getcell(7,10),getcell(6,10),getcell(8,8),getcell(9,8),getcell(1,1)}
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp5 As Cell[rows*columns] = {getcell(14,6),getcell(14,5),getcell(14,4),getcell(2,6),getcell(2,5),getcell(2,4),getcell(1,7),getcell(1,6),getcell(1,5),getcell(1,4),getcell(1,3),getcell(15,7),getcell(15,6),getcell(15,5),getcell(15,4),getcell(15,3),getcell(15,8),getcell(1,8),getcell(13,5),getcell(13,4),getcell(13,3),getcell(6,4),getcell(6,3),getcell(10,4),getcell(10,3),getcell(12,13),getcell(4,13),getcell(5,5),getcell(11,5),getcell(4,9),getcell(4,8),getcell(4,7),getcell(12,9),getcell(12,8),getcell(12,7),getcell(12,12),getcell(12,11),getcell(4,12),getcell(4,11),getcell(6,12),getcell(6,11),getcell(10,12),getcell(10,11),getcell(11,10),getcell(11,9),getcell(11,8),getcell(11,7),getcell(5,10),getcell(5,9),getcell(5,8),getcell(5,7),getcell(1,1),getcell(2,1)}
		//remove Right walls of these cells
		Define removeRight5 As Cell[rows*columns] = {getcell(2,2),getcell(14,13),getcell(15,13),getcell(1,13),getcell(14,10),getcell(15,10),getcell(1,10),getcell(4,14),getcell(5,14),getcell(6,14),getcell(7,14),getcell(8,14),getcell(9,14),getcell(10,14),getcell(11,14),getcell(5,13),getcell(6,13),getcell(7,13),getcell(8,13),getcell(9,13),getcell(10,13),getcell(4,3),getcell(10,2),getcell(11,2),getcell(7,3),getcell(8,3),getcell(2,10),getcell(13,10),getcell(3,5),getcell(4,5),getcell(6,5),getcell(7,5),getcell(8,5),getcell(9,5),getcell(3,10),getcell(12,10),getcell(4,10),getcell(11,10),getcell(4,12),getcell(5,12),getcell(6,12),getcell(7,12),getcell(8,12),getcell(9,12),getcell(10,12),getcell(11,12),getcell(7,11),getcell(8,11),getcell(6,7),getcell(7,7),getcell(8,7),getcell(9,7)}
		//remove Down walls of these cells
		Define removeDown5 As Cell[rows*columns] =  {getcell(14,8),getcell(2,8),getcell(1,14),getcell(15,14),getcell(15,15),getcell(2,13),getcell(2,14),getcell(14,13),getcell(14,14),getcell(14,15),getcell(14,1),getcell(13,14),getcell(13,15),getcell(3,14),getcell(3,15),getcell(1,11),getcell(15,11),getcell(5,15),getcell(7,15),getcell(9,15),getcell(11,15),getcell(4,14),getcell(4,15),getcell(4,1),getcell(6,14),getcell(6,15),getcell(6,1),getcell(8,14),getcell(8,15),getcell(8,1),getcell(10,14),getcell(10,15),getcell(10,1),getcell(12,14),getcell(12,15),getcell(12,1),getcell(4,13),getcell(12,13),getcell(3,2),getcell(3,3),getcell(3,4),getcell(4,3),getcell(12,3),getcell(14,10),getcell(14,11),getcell(14,12),getcell(2,10),getcell(2,11),getcell(2,12),getcell(3,11),getcell(13,11),getcell(11,5),getcell(5,5),getcell(3,5),getcell(3,6),getcell(3,7),getcell(3,8),getcell(3,9),getcell(13,5),getcell(13,6),getcell(13,7),getcell(13,8),getcell(13,9),getcell(7,8),getcell(7,9),getcell(9,8),getcell(9,9),getcell(6,7),getcell(6,8),getcell(10,7),getcell(10,8),getcell(2,1)}
		Define InvalidLocations5 As Cell[rows*columns] = {getCell(2,2), getCell(3,2),getCell(4,2), getCell(4,4), getCell(4,5), getCell(1,5), getCell(8,2), getCell(9,2), getCell(8,4), getCell(9,4), getCell(1,7), getCell(2,7), getCell(2,9), getCell(3,9), getCell(7,7), getCell(8,7), getCell(8,6), getCell(5,8), getCell(5,10), getCell(10,7), getCell(10,10), getCell(7,9), getCell(7,10), getCell(8,10)} 
		currentlevel().loadLevelPt1(removeLeft5,removeUp5, removeRight5, removeDown5, "level8.wav", 45, "Cholesterol", InvalidLocations5)
		createMaze()
		Define SpawnLocations5 As Cell[10] = {getCell(3,8) ,getCell(6,3)  ,getCell(2,7) ,getCell(10,1), getCell(5,9),getcell(14,14),getcell(12,13),getcell(10,3),getcell(1,6),getcell(10,1)}
		Define goodFoodLocations5 As Cell[20] = {getCell(6,1),getcell(8,1),getcell(12,11),getcell(13,9),getcell(12,14),getCell(3,4) ,getCell(10,15),getCell(11,9),getCell(1,8),getCell(5,7),getcell(13,5),getcell(2,14),getcell(14,12),getcell(2,1),getcell(10,12),getcell(4,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6)}
		Define goodfoods5 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations5,"Fish.png")
		Define enemySet5 As Enemy[9] = createEnemySetLevel5(9,SpawnLocations5)
		currentlevel().LoadLevelpt2(SpawnLocations5, enemySet5, goodfoods5)
		
		setLevel(6)
		multi.rows=10
		multi.columns = 10
		Define removeLeft6 As Cell[rows*columns] = {getCell(8,1),getCell(5,7),getCell(10,1), getCell(5,6),getCell(2,4),getCell(8,5),getCell(7,2),getCell(2,1),getCell(3,2),getCell(6,2),getCell(6,9),getCell(8,3),getCell(10,3),getCell(7,8),getCell(10,8),getCell(9,8),getCell(9,3),getCell(4,2),getCell(3,1),getCell(5,1),getCell(4,1),getCell(2,7),getCell(10,6),getCell(1,6),getCell(4,8),getCell(6,5),getCell(10,9),getCell(7,6),getCell(8,7),getCell(9,5)}
		//will remove the upper wall of these positions
		//If you add o6 remove positions, RESIZE
		Define removeUp6 As Cell[rows*columns] = {getCell(7,3),getCell(1,9),getCell(1,10),getCell(4,9),getCell(5,7),getCell(3,8),getCell(3,7),getCell(1,2), getCell(2,6),getCell(2,5),getCell(5,4),getCell(9,6),getCell(7,10),getCell(8,9),getCell(5,6),getCell(9,8),getCell(1,10),getCell(6,1),getCell(6,4),getCell(6,3),getCell(6,5),getCell(5,3),getCell(6,6),getCell(6,7),getCell(6,8),getCell(9,10),getCell(6,10),getCell(6,9),getCell(5,2),getCEll(4,5), getCell(8,7), getCell(9,7)}
		//remove Right walls of these cells
		Define removeRight6 As Cell[rows*columns] = {getCell(8,2),getCell(5,7),getCell(1,10),getCell(2,9),getCell(4,9),getCell(2,10),getCell(3,10),getCell(2,8),getCell(1,8),getCell(3,7),getCell(8,1),getCell(7,10),getCell(9,5),getCell(7,8),getCell(8,4),getCell(8,9),getCell(3,6),getCell(2,6),getCell(1,6),getCell(1,3),getCell(2,3),getCell(3,3),getCell(4,3),getcell(1,1)}
		//remove Down walls of these cells
		Define removeDown6 As Cell[rows*columns] = {getCell(1,1),getCell(10,3),getCell(3,3),getCell(4,9),getCell(3,4),getCell(3,5),getCell(7,5),getCell(7,4),getCell(5,4),getCell(1,3),getCell(10,4),getCell(10,1),getCell(6,1),getCell(7,1),getCell(7,3),getCell(9,10),getCell(10,8),getCell(10,2), getCell(1,2)}
		Define InvalidLocations6 As Cell[rows*columns] = {getCell(2,2), getCell(3,2),getCell(4,2), getCell(4,4), getCell(4,5), getCell(1,5), getCell(8,2), getCell(9,2), getCell(8,4), getCell(9,4), getCell(1,7), getCell(2,7), getCell(2,9), getCell(3,9), getCell(7,7), getCell(8,7), getCell(8,6), getCell(5,8), getCell(5,10), getCell(10,7), getCell(10,10), getCell(7,9), getCell(7,10), getCell(8,10)} 
		
		currentlevel().loadLevelPt1(removeLeft6,removeUp6, removeRight6, removeDown6,"level7.wav", 180,"", InvalidLocations6 )
		createMaze()
		Define SpawnLocations6 As Cell[8] = {getCell(3,8) ,getCell(5,3)  ,getCell(2,6) ,getCell(9,6)   ,getCell(9,1)   ,getCell(8,5)   ,getCell(7,8)   ,getCell(6,9)}
		Define goodFoodLocations6 As Cell[] = {getCell(5,1)  ,getCell(3,4) ,getCell(10,1)  ,getCell(10,9)  ,getCell(1,8)  ,getCell(5,7)}
		Define enemySet6 As enemy[] = createEnemySet(5,SpawnLocations6, "Potato Bag v.1.3.gif")
		Define goodfoods6 As goodFood[] = addGoodFoods(goodFoodLocations6,"Carrot v.1.1.gif")
		currentlevel().LoadLevelpt2(SpawnLocations6, enemySet, goodfoods)
		//you need to follow these lines exactly
		setLevel(1)
	End Method
	
	
	//returnslevel4 invalid
	Function level4invalid() As Cell[]
		Define inv As Cell[((currentlevel().columns+1)/2)*(currentlevel().rows+1)/2]
		Define i As Integer
		Define i2 As Integer
		Define loc As Integer = 1
		For i = 1 To ((currentlevel().columns+1)/2)
			For i2 = 1 To ((currentlevel().rows+1)/2)
				inv[loc] = getcell(2*i-1, 2*i2-1)
				loc +=1
			Next
		Next
		Return inv
	End Function
	
	//returns difficulty
	Function currentDifficulty() As Difficulty
		If diff = 0 Then
			Return Chesney
		Else If diff = 1 Then
			Return easy
		Else If diff = 2 Then
			Return medium
		Else If diff = 3 Then
			Return hard
		Else 
			Return god
		End If
	End Function
	
	//sets diff as int
	Method setDifficulty(difficulty As Integer) 
		If difficulty <= 4 And difficulty >=0 Then
			diff = difficulty
		End If
	End Method	
	
	//returns currentlevel - uses clevel as pointer
	Function currentlevel() As level
		If clevel = 1 Then 
			Return level1
		Else If clevel = 2Then 
			Return level2
		Else If clevel = 3 Then 
			Return level3
		Else If clevel = 4 Then 
			Return level4
		Else If clevel = 5 Then 
			Return level5
		Else 
			Return multi
		End If
	End Function	
	
	//sets level as int
	Method setLevel(levelnew As Integer) 
		If levelnew >=1 And levelnew <=6 Then
			leaveCurrentLevel()
			clevel = levelnew
		End If
	End Method
	
	//reinits level
	//do everything in terms of currentlevel()
	//run before starting every level
	Method initLevel()
		//loads various bars
		progress.load()
		healthbar.load()
		timebar.load()
		//loads the lives spite-used to stamp out number of lives
		lifeSprite.Load("Dr. Meatloaf Lives.png")
		lifesprite.Scale(100*30/lifesprite.Width, 100*30/lifesprite.height)
		
		Define counter As Integer
		Define l As Level = currentLevel()
		//If  Not l.mus = "" Then
			l.music.loadFile(l.mus)//loads music for level
		//End If
		//loads good foods
		For counter = 1 To arraylength(l.goodFoods)
			If l.goodFoods[counter].isReal Then//if real then load and move into position
				l.goodFoods[counter].load()
				l.goodfoods[counter].changepos(currentlevel().goodfoods[counter].xpos,currentlevel().goodfoods[counter].ypos, convertX(currentlevel().goodFoods[counter].xpos), convertY(currentlevel().goodFoods[counter].ypos))
			Else //else keep out of sight- probably unnecessary, but
				l.enemyset[counter].psprite.hide()
			End If
			
		Next
		
		//loads enemies
		For counter = 1 To arrayLength(currentlevel().enemyset)
			
			If l.enemyset[counter].isReal Then//saem as above
				l.enemyset[counter].Load()
				If l.enemyset[counter].picture = "" Then
					counter+=1
				End If
				l.enemyset[counter].changepos(currentlevel().enemyset[counter].startX,currentlevel().enemyset[counter].startY, convertX(currentlevel().enemyset[counter].startX), convertY(currentlevel().enemyset[counter].startY))
				
			Else
				//l.enemyset[counter].psprite.hide()
			End If
			If currentlevel() = level5 Then
				l.enemyset[1].unload()
				l.enemyset[1].load()
				l.enemyset[1].changepos(currentlevel().enemyset[1].startX,currentlevel().enemyset[1].startY, convertX(currentlevel().enemyset[1].startX), convertY(currentlevel().enemyset[1].startY))
				
			End If
		Next
		//loads player
		character.loadplayer(cellsize)
		//you haven't wonm, but you haven't lost
		isCaught = False
		haswon = False
		//time in game = 0
		totalGameTime = 0
		//get healthbar label
		healthbar.label = l.barName
		//display the game
		scrollGame()
		//display the player
		changeCharacterPosition(character.xpos, character.ypos, character)
		//refresh the screen
		RefreshScreen()
		
	End Method
	
	Method RunGame()
		Define timeBuffer As Integer//should help prevent overlapping cheats
		Gametimer.start()//starts gametimer
		Define PauseSprite As Sprite
		pauseSprite.Load("Pause.png")
		Define goodFoodHit As Boolean
		Define enemyHit As Boolean 
		Define counter As Integer
		Define l As Level = currentlevel()
		//Define timeA as Decimal = GameTimer.elapsed
		l.music.PlayLoop()
		//starts up music
		//clearKeyboardEvents()
		//wait until player moves to enter game - user input
		While getKey() = "" And GameTimer.Elapsed< 5 
			delay(1)
		End While
		//while you don't want to exit, you haven't won, and you haven't lost, and you haven''t run out of time(last is N/A on Chesney)
		While Not iskeydown(escape) And Not IsCaught And Not hasWon And (totalGameTime <= l.time Or currentDifficulty() = chesney)
			//pause code
			If isKeyDown("p") And paused Then
				paused = False
				clearKeyboardevents()
				gameTimer.Reset()
				pauseSprite.hide()
				//don't reset til players ready
				While getKey() = "" And GameTimer.Elapsed< 2 
					delay(1)
				End While
			Else If isKeyDown("p")Then
				paused = True
				clearKeyboardevents()
				pauseSprite.hide()
				pauseSPrite.Scale(100*300/pausesprite.width,100*300/pausesprite.width)
				pauseSprite.moveTo((screenwidth()-pauseSprite.width)/2, (screenheight()+ygap-pauseSprite.height)/2)
				
			End If
			//quit code 
			If isKeyDown("q")Then
				character.setPlayerHealth(0)
				character.lives = 0
				clearkeyboardevents()
			End If
			
			//cheatcode/testing section
			If isKeyDown("3") Then
				setDifficulty(3)
			End If
			If isKeyDown("2") Then
				setDifficulty(2)
			End If
			If isKeyDown("1") Then
				setDifficulty(1)
			End If
			If isKeyDown("4") Then
				setDifficulty(0)
			End If
			If isKeyDown("5") Then
				setDifficulty(4)
			End If
			If isKeyDown(".") Then
				character.setPlayerHealth(character.health+1)
			End If
			If isKeyDown(",") Then
				character.setPlayerHealth(character.health-1)
			End If
			If isKeyDown("t") Then
				totalGameTime-=1
			End If
			If isKeyDown("y") Then
				totalGameTime+=1
			End If
			If isKeyDown("i") And totalGameTime - timebuffer > 1 Then
				character.invincible = Not character.invincible
			End If
			If isKeyDown("u") Then
				unlocked[diff+1] = True
			End If
			If isKeyDown("e") Then
				For counter =1 To arraylength(l.enemyset)
					If l.enemyset[counter].isReal Then
						l.enemyset[counter].active = True
					End If
				Next
			End If
			If isKeyDown("g") Then
				For counter = 1 To arraylength(l.goodFoods) 
					If l.goodfoods[counter].isReal Then
						l.goodFoods[counter].active = True
					End If
				Next
			End If
			If Not paused Then
				//timer
				Define time As Decimal = GameTimer.elapsed
				Delay(30-1000*time)
				//igore extra long frames- testing etc. 
				If time < .5 Then
					totalGameTime+=time
				End If
				//reset timer
				GameTimer.reset()
				//moveplayer, then enemies, then display
				MovePlayer(character)
				moveEnemies(l.enemyset, character)
				scrollGame()
				//now check for goodfoods and enemies
				enemyHit = caught(l.enemyset, character)
				goodFoodHit = checkGoodFoodIntersection(character)
				//play requisite sounds
				//playSounds(enemyHit,goodFoodHit)
				//contains enemy does nothing- ignore
				//updateContainsEnemy()
				//have you found all good foods
				haswon = IsComplete()
				//are you dead
				isCaught = isDead(character)
			Else
				pauseSprite.show()
			End If
		End While
		//stop muzak
		l.music.Stop()
		paused = False
		pauseSprite.Unload()
	End Method	
	
	Method initLevelMulti()
		//loads various bars
		ygap = 45
		healthbar1.load()
		healthbar2.load()
		timebar2.load()
		
		Define counter As Integer
		Define l As Level = currentLevel()
		l.music.loadFile(l.mus)//loads music for level
		//loads good foods
		For counter = 1 To arraylength(l.goodFoods)
			If l.goodFoods[counter].isReal Then//if real then load and move into position
				l.goodFoods[counter].load()
				l.goodfoods[counter].changepos(currentlevel().goodfoods[counter].xpos,currentlevel().goodfoods[counter].ypos, convertX(currentlevel().goodFoods[counter].xpos), convertY(currentlevel().goodFoods[counter].ypos))
			End If
			
		Next
		
		//loads enemies
		For counter = 1 To arrayLength(currentlevel().enemyset)
			
			If l.enemyset[counter].isReal Then//saem as above
				l.enemyset[counter].Load()
				If l.enemyset[counter].picture = "" Then
					counter+=1
				End If
				l.enemyset[counter].changepos(currentlevel().enemyset[counter].startX,currentlevel().enemyset[counter].startY, convertX(currentlevel().enemyset[counter].startX), convertY(currentlevel().enemyset[counter].startY))
				
			End If
		Next
		//loads player
		player1.loadplayer(3, 3, cellsize)
		player2.loadplayer(8,8, cellsize)
		
		//time in game = 0
		totalGameTime = 0
		//display the game
		scrollGameMulti()
		//display the player
		changeCharacterPosition(player1.xpos, player1.ypos, player1)
		changeCharacterPosition(player2.xpos, player2.ypos, player2)
		//refresh the screen
		RefreshScreen()
		
	End Method
	
	Method RunGameMulti()
		Define timeBuffer As Integer//should help prevent overlapping cheats
		Gametimer.start()//starts gametimer
		Define PauseSprite As Sprite
		pauseSprite.Load("Pause.png")
		Define goodFoodHit1 As Boolean
		Define goodFoodHit2 As Boolean
		Define enemyHit1 As Boolean
		Define enemyHit2 As Boolean 
		Define counter As Integer
		Define l As Level = currentlevel()
		
		//Define timeA as Decimal = GameTimer.elapsed
		l.music.PlayLoop()
		//starts up music
		//clearKeyboardEvents()
		//wait until player moves to enter game - user input
		While getKey() = "" And GameTimer.Elapsed< 5 
			delay(1)
		End While
		//while you don't want to exit, you haven't won, and you haven't lost, and you haven''t run out of time(last is N/A on Chesney)
		While Not iskeydown(escape) And (totalGameTime <= l.time)
			//pause code
			If isKeyDown("p") And paused Then
				paused = False
				clearKeyboardevents()
				gameTimer.Reset()
				pauseSprite.hide()
				//don't reset til players ready
				While getKey() = "" And GameTimer.Elapsed< 2 
					delay(1)
				End While
			Else If isKeyDown("p")Then
				paused = True
				clearKeyboardevents()
				pauseSprite.hide()
				pauseSprite.Scale(100*300/pausesprite.width,100*300/pausesprite.width)
				pauseSprite.moveTo((screenwidth()-pauseSprite.width)/2, (screenheight()+ygap-pauseSprite.height)/2)
				
			End If
			If Not paused Then
				//timer
				Define time As Decimal = GameTimer.elapsed
				Delay(30-1000*time)
				//igore extra long frames- testing etc. 
				If time < .5 Then
					totalGameTime+=time
				End If
				//reset timer
				GameTimer.reset()
				//moveplayer, then enemies, then display
				MovePlayerMulti(player1)
				MovePlayerMulti(player2)
				moveEnemies(l.enemyset, player1)
				scrollGameMulti()
				//now check for goodfoods and enemies
				enemyHit1 = caught(l.enemyset, player1)
				goodFoodHit1 = checkGoodFoodIntersection(player1)
				enemyHit2 = caught(l.enemyset, player2)
				goodFoodHit2 = checkGoodFoodIntersection(player2)
				
			Else
				pauseSprite.show()
			End If
		End While
		//stop muzak
		l.music.Stop()
		paused = False
		pauseSprite.Unload()
		ygap = 100
	End Method	
	
	Function isDead(p As Player) As Boolean
		If p.health> 0 Or p.invincible Then
			Return False
		End If
		Return True
	End Function
	
	//plays sounds based on whether you hit goodfoods and enemies
	Method playSounds(e As Boolean, g As Boolean)
		//if good foods hit
		If g Then
			//stop sounds
			If caught2.IsPlaying Then
				caught2.Stop()
			End If
			If found.IsPlaying Then
				found.Stop()
			End If
			//play sound
			found.Play()
		Else If e Then//else enemy hit
			//stop sounds
			If caught2.IsPlaying Then
				caught2.Stop()
			End If
			If found.IsPlaying Then
				found.Stop()
			End If
			//play enemysound
			caught2.play()
		End If
	End Method
	
	//moves all enemies in enemyset
	Method moveEnemies(e As enemy[], p As Player)
		Define counter As Integer = 0
		For counter = 1 To arrayLength(e)
			moveEnemy(e[counter], p)
		Next
	End Method
	
	Method moveEnemies(e As enemy[], p As Player[])
		Define counter As Integer = 0
		For counter = 1 To arrayLength(e)
			moveEnemy(e[counter], p)
		Next
	End Method
	
	//updates maze position and draws
	Method MoveMaze()
		Define counter As Integer
		Define l As Level = currentlevel()
		For counter = 1 To arraylength(currentlevel().maze)
			l.maze[counter].xpos = l.maze[counter].column +(character.startx - character.xpos)
			l.maze[counter].ypos = l.maze[counter].row +(character.starty - character.ypos)
		Next
		DrawMaze()
	End Method
	
	//picks player sprite given direction
	Method DisplayPlayer(p As player)
		If p.hasbeenLoaded Then
			p.psprite.Hide()//hides
			If p.invincible Then
				p.psprite.opacity = 50
			Else 
				p.psprite.opacity = 100
			End If
		End If
		//switches value
		Select p.direction
			Case 0
				p.psprite = p.pspriteU
			End Case
			Case 1
				p.psprite = p.pspriteR
			End Case
			Case 2
				p.psprite = p.pspriteD
			End Case
			Case 3
				p.psprite = p.pspriteL
				
			End Case
		End Select
		
		p.psprite.Show()
		
	End Method
	
	//has finished level
	//call every frame
	Function isComplete() As Boolean
		Define i As Integer
		Define l As Level = currentlevel()
		//if any foods are stil active, you aren't done so return false
		For i = 1 To arraylength(currentlevel().goodFoods)
			If l.goodFoods[i].active Then
				Return False
			End If
		Next
		
		Return True
	End Function
	
	//checks good food intersections
	//returns boolean re if hit for sound playing
	Function checkgoodFoodIntersection(p As player) As Boolean
		Define n As Integer
		Define l As Level = currentlevel()
		Define intersected As Boolean = False
		For n =1 To arraylength(currentlevel().goodFoods)
			If intersectsPlayer(l.goodFoods[n], p) And l.goodFoods[n].active Then//getCell(currentlevel().goodFoods[n].xpos,currentlevel().goodFoods[n].ypos) = getPlayerCell(character.xpos, character.ypos) And currentlevel().goodFoods[n].active Then
				
				p.setPlayerHealth( p.health+ currentDifficulty().goodFoodBonus)
				l.goodFoods[n].active = False
				l.foodseaten+=1
				p.goodFoodsHit +=1
				intersected = True
			End If	
		Next
		Return intersected
		
	End Function
	
	
	
	//checks if good food g intersects player p
	//called in checkgoodfoodintersection
	Function intersectsPlayer(g As goodFood, p As player) As Boolean

		Define x As Decimal = p.xpos
		Define y As Decimal = p.ypos
		//if within one cell or sprites intersect, is true else false
		If abs(x-g.xpos) < 1 And abs(y-g.ypos)< 1 Or g.psprite.Intersects(p.psprite) Then
			Return True
		End If
		Return False
	End Function
	
	//creates the set of enemies for a level
	//called in load game
	Function createEnemySet(n As Int, spawn As cell[], pic As String) As Enemy[]
		//so n is number of enemies, spawn is the locations they should appear in, and pic ois the picture tht goes with the enemies
		Define enSet As Enemy[n]
		Define counter As Integer 
		//if more enemies then spots, stop program
		If n  > arrayLength(spawn) Then
			stop()
		Else If n = arrayLength(spawn) Then
			//if equal size just fill spots
			For counter = 1 To n
				Define e As enemy
				e.loadenemy(spawn[counter].column,spawn[counter].row,pic, cellsize)
				enset[counter] = e
			Next
		Else
			//if more spots than player, randomly fill spots
			Define invalid As Boolean//checks for valid spawning
			Define c As Integer
			For counter = 1 To n
				Define e As Enemy
				Invalid = True
				While invalid = True
					invalid = False
					c = Random(1, arrayLength(spawn))// pick random location
					If spawn[c].containsEnemy Then//if filled then pick another one
						invalid = True
					End If
				End While
				
				spawn[c].containsEnemy = True//make this spot be full
				e.loadEnemy(spawn[c].column,spawn[c].row, pic,cellsize)//load enemy an put in enemyset
				enSet[counter] = e
			Next
		End If
		Return enset//return enset to act as that level's enemyset
	End Function
	
	//creates the set of enemies for a level
	//called in load game
	Function createEnemySetlevel5(n As Int, spawn As cell[]) As Enemy[]
		//so n is number of enemies, spawn is the locations they should appear in, and pic ois the picture tht goes with the enemies
		Define enSet As Enemy[n]
		Define counter As Integer 
		//if more enemies then spots, stop program
		If n  > arrayLength(spawn) Then
			stop()
		Else If n = arrayLength(spawn) Then
			//if equal size just fill spots
			For counter = 1 To n
				Define e As enemy
				If counter = 1 Then
					e.IsBurger = True
				End If
				If counter/2 = 0 Then 
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Burger.png", cellsize)
				Else If counter/2 = 1 Then 
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Fries.png", cellsize)
				Else If counter/2 = 2 Then 
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Soda.png", cellsize)
				Else If counter/2 = 3 Then 
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Potato Bag.png", cellsize)
				Else If counter/2 = 4 Then 
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Donut.png", cellsize)
				End If
				enset[counter] = e
			Next
		Else
			//if more spots than player, randomly fill spots
			Define invalid As Boolean//checks for valid spawning
			Define c As Integer
			For counter = 1 To n
				Define e As Enemy
				Invalid = True
				While invalid = True
					invalid = False
					c = Random(1, arrayLength(spawn))// pick random location
					If spawn[c].containsEnemy Then//if filled then pick another one
						invalid = True
					End If
				End While
				If c = 1 Then
					e.IsBurger = True
				End If
				spawn[c].containsEnemy = True//make this spot be fullIf counter/2 = 0 Then 
				If c/2 = 0 Then
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Burger.png", cellsize)
				Else If c/2 = 1 Then 
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Fries.png", cellsize)
				Else If c/2 = 2 Then 
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Soda.png", cellsize)
				Else If c/2 = 3 Then 
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Potato Bag.png", cellsize)
				Else If c/2 = 4 Then 
					e.loadenemy(spawn[counter].column,spawn[counter].row,"Donut.png", cellsize)
				End If
				enSet[counter] = e
			Next
		End If
		Return enset//return enset to act as that level's enemyset
	End Function
	
	//generic movePlayer code
	//moves player based on direction
	//ripped from rungame 19Oct2009
	Method MovePlayer( p As player)
		Define buffer As Decimal = .50
		Define a As Integer = p.direction
		Define cellchanges As Boolean
		Define b As Boolean
		If iskeydown(p.upKey) Then
			p.setDirection(0)
			cellchanges = Not (ceiling(p.ypos) = ceiling(p.ypos-p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).up  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer And (Not cellchanges Or (getCell(round(p.xpos), floor(p.ypos - p.playerspeed)).down And cellchanges)) Then
				changeCharacterPosition(round(p.xpos),p.ypos -p.playerSpeed, p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).up  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer Then
				changeCharacterPosition(round(p.xpos),ceiling(p.ypos -p.playerSpeed), p)
			Else
				p.setDirection(a)
			End If
					
		End If
		//same for down, right, left
		If iskeydown(p.downKey) Then
			p.setDirection(2)
			cellchanges = Not (floor(p.ypos) = floor(p.ypos+p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).down  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer And (Not cellchanges Or (getCell(round(p.xpos), ceiling(p.ypos + p.playerspeed)).up And cellchanges)) Then
				changeCharacterPosition(round(p.xpos),p.ypos +p.playerSpeed, p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).down  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer Then
				changeCharacterPosition(round(p.xpos),floor(p.ypos +p.playerSpeed), p)
			Else
				p.setDirection(a)
			End If
		End If
			
			
		If iskeydown(p.rightKey) Then
			p.setDirection(1)
			cellchanges = Not(floor(p.xpos) = floor(p.xpos+p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).right  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer And (Not cellchanges Or (getCell(ceiling(p.xpos + p.playerspeed),round(p.ypos)).left And cellchanges))  Then
				changeCharacterPosition(p.xpos +p.playerSpeed, round(p.ypos), p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).right  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer Then
				changeCharacterPosition(floor(p.xpos +p.playerSpeed), round(p.ypos), p)
			Else
				p.setDirection(a)
			End If
		End If
			
			
		If iskeydown(p.leftKey) Then
			p.setDirection(3)
			cellchanges = Not (ceiling(p.xpos) = ceiling(p.xpos-p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).left  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer And (Not cellchanges Or (getCell(floor(p.xpos - p.playerspeed),round(p.ypos)).right And cellchanges))Then
				changeCharacterPosition(p.xpos -p.playerSpeed, round(p.ypos), p)
			Else If getPlayerCell(p.xpos,p.ypos, p).left  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer Then
				changeCharacterPosition(ceiling(p.xpos -p.playerSpeed), round(p.ypos), p)
			Else
				p.setDirection(a)
			End If
		End If
		
	End Method
	
	
	Method MovePlayerMulti( p As player)
		Define buffer As Decimal = .50
		Define a As Integer = p.direction
		Define cellchanges As Boolean
		Define b As Boolean
		If iskeydown(p.upKey) Then
			p.setDirection(0)
			cellchanges = Not (ceiling(p.ypos) = ceiling(p.ypos-p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).up  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer And (Not cellchanges Or (getCell(round(p.xpos), floor(p.ypos - p.playerspeed)).down And cellchanges)) Then
				changeCharacterPositionMulti(round(p.xpos),p.ypos -p.playerSpeed, p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).up  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer Then
				changeCharacterPositionMulti(round(p.xpos),ceiling(p.ypos -p.playerSpeed), p)
			Else
				p.setDirection(a)
			End If
					
		End If
		//same for down, right, left
		If iskeydown(p.downKey) Then
			p.setDirection(2)
			cellchanges = Not (floor(p.ypos) = floor(p.ypos+p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).down  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer And (Not cellchanges Or (getCell(round(p.xpos), ceiling(p.ypos + p.playerspeed)).up And cellchanges)) Then
				changeCharacterPositionMulti(round(p.xpos),p.ypos +p.playerSpeed, p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).down  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer Then
				changeCharacterPositionMulti(round(p.xpos),floor(p.ypos +p.playerSpeed), p)
			Else
				p.setDirection(a)
			End If
		End If
			
			
		If iskeydown(p.rightKey) Then
			p.setDirection(1)
			cellchanges = Not(floor(p.xpos) = floor(p.xpos+p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).right  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer And (Not cellchanges Or (getCell(ceiling(p.xpos + p.playerspeed),round(p.ypos)).left And cellchanges))  Then
				changeCharacterPositionMulti(p.xpos +p.playerSpeed, round(p.ypos), p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).right  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer Then
				changeCharacterPositionMulti(floor(p.xpos +p.playerSpeed), round(p.ypos), p)
			Else
				p.setDirection(a)
			End If
		End If
			
			
		If iskeydown(p.leftKey) Then
			p.setDirection(3)
			cellchanges = Not (ceiling(p.xpos) = ceiling(p.xpos-p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).left  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer And (Not cellchanges Or (getCell(floor(p.xpos - p.playerspeed),round(p.ypos)).right And cellchanges))Then
				changeCharacterPositionMulti(p.xpos -p.playerSpeed, round(p.ypos), p)
			Else If getPlayerCell(p.xpos,p.ypos, p).left  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer Then
				changeCharacterPositionMulti(ceiling(p.xpos -p.playerSpeed), round(p.ypos), p)
			Else
				p.setDirection(a)
			End If
		End If
		
	End Method
	
	
	//scrolls amd displays game
	//really should be called display game, cause it rewrites the game from the ground up
	Method ScrollGame()
		Define n As Integer
		Define l As Level = currentlevel()
		BeginFrame()
		//displays enemies
		For n = 1 To arraylength(l.enemyset)
			//changepos
			l.enemyset[n].changepos(l.enemyset[n].xpos,l.enemyset[n].ypos, convertX(l.enemyset[n].xpos + character.startx-character.xpos), convertY(l.enemyset[n].ypos+ character.starty-character.ypos))
			//if in upper block or inactive, hide, else show
			If convertY(l.enemyset[n].ypos+ character.starty-character.ypos) <=yGap Or Not l.enemyset[n].active  Then
				l.enemyset[n].psprite.Hide()
			Else If l.enemyset[n].active Then
				l.enemyset[n].psprite.show()
			End If
		Next
		//display character
		DisplayPlayer(character)
		
		//display and scroll good foods- see enemies
		
		Define foodsgone As Integer = 0
		For n = 1 To arraylength(l.goodfoods)
			l.goodfoods[n].changepos(l.goodfoods[n].xpos,l.goodfoods[n].ypos, convertX(l.goodFoods[n].xpos + character.startx-character.xpos), convertY(l.goodFoods[n].ypos+ character.starty-character.ypos))
			If convertY(l.goodFoods[n].ypos+ character.starty-character.ypos) <=yGap Or Not l.goodfoods[n].active Then
				l.goodFoods[n].psprite.Hide()
			Else If l.goodFoods[n].active Then
				currentlevel().goodFoods[n].psprite.show()
			End If
			If Not l.goodFoods[n].active Then
				foodsGone+=1
			End If
		Next
		//move maze
		MoveMaze()
		//set score - need to tweak
		character.setScore(diff*diff*((character.lives-1)*1000 + 0+character.Health*10+character.goodFoodsHit*100-character.enemiesHit*200-TotalGameTime*5))
		//draw menu rectangle on top of screen
		Color(white)
		Pen(False)
		moveTo(0,0)
		Pen(True)
		Rectangle(screenwidth(), yGap, True )
		Color(Black)
		moveto(0,yGap-5)
		Rectangle(screenwidth(), 5, True )
		//draw health bars,etc.
		If character.health > 65 Then
			color(limegreen)
		Else If character.health >=35 Then
			color(yellow)
		Else
			healthbar.blink(red)
		End If
		//fill in health bar
		healthbar.draw(convertTodecimal(1)-healthbar.converttodec(character.health, 100))
		//bdraw levelprogress bar
		Define dec As Decimal
		
		dec = convertToDecimal(l.totalfoods-foodsGone)
		dec = dec/convertToDecimal(l.totalfoods)
		If 1-dec> 2.0/3.0 Then
			color(limegreen)
		Else If 1-dec >1.0/3.0 Then
			color(yellow)
		Else 
			color(red)
		End If
		//color(limegreen)
		progress.draw(1-dec)
		Pen(False)
		moveTO(0,40)
		print("Score: " + character.score)
		moveTo(100, 40)
		Print("Lives: ")
		//stamp number of lives
		For n = 1 To character.lives
			lifeSprite.MoveTo(150 + (n-1)*1.5*lifesprite.Width, 40)
			lifeSprite.Stamp()
		Next
		
		//draw timebar
		If ( l.time - totalGameTime)/(l.time) > 2.0/3.0 Then
			color(limegreen)
		Else If ( l.time - totalGameTime)/(l.time) > 1.0/3.0 Then
			color(yellow)
		Else
			timeBar.blink(red)
		End If
		timeBar.draw(( l.time - totalGameTime)/(l.time))
		RefreshScreen()
	End Method
	
	Method ScrollGameMulti()
		Define n As Integer
		Define l As Level = currentlevel()
		BeginFrame()
		//displays enemies
		For n = 1 To arraylength(l.enemyset)
			//changepos
			l.enemyset[n].changepos(l.enemyset[n].xpos,l.enemyset[n].ypos, convertX(l.enemyset[n].xpos), convertY(l.enemyset[n].ypos))
			//if in upper block or inactive, hide, else show
			If convertY(l.enemyset[n].ypos) <=yGap  Then
				l.enemyset[n].psprite.Hide()
			Else If l.enemyset[n].active Then
				l.enemyset[n].psprite.show()
			Else If Not l.enemyset[n].active Then
				changeEnemyPosition(l.enemyset[n].startX,l.enemyset[n].startY,l.enemyset[n])
				l.enemyset[n].active = True
			End If
		Next
		//display character
		DisplayPlayer(player1)
		DisplayPlayer(player2)
		//display and scroll good foods- see enemies
		
		//Define foodsgone As Integer = 0
		For n = 1 To arraylength(l.goodfoods)
			l.goodfoods[n].changepos(l.goodfoods[n].xpos,l.goodfoods[n].ypos, convertX(l.goodFoods[n].xpos), convertY(l.goodFoods[n].ypos))
			If convertY(l.goodfoods[n].ypos) <=yGap  Then
				l.goodfoods[n].psprite.Hide()
			Else If l.goodFoods[n].active Then
				l.goodFoods[n].psprite.show()
			Else If Not l.goodFoods[n].active Then
				l.goodfoods[n].active = True
			End If
		Next
		//move maze
		color(black)
		DrawMaze()
		//set score - need to tweak
		player1.setScore((0+player1.Health*10+player1.goodFoodsHit*100-player1.enemiesHit*200-TotalGameTime*5))
		player2.setScore((0+player2.Health*10+player2.goodFoodsHit*100-player2.enemiesHit*200-TotalGameTime*5))
		//draw menu rectangle on top of screen
		Color(white)
		Pen(False)
		moveTo(0,0)
		Pen(True)
		Rectangle(screenwidth(), yGap, True )
		Color(Black)
		moveto(0,yGap-5)
		Rectangle(screenwidth(), 5, True )
		//draw health bars,etc.
		If player1.health > 65 Then
			color(limegreen)
		Else If player1.health >=35 Then
			color(yellow)
		Else
			healthbar1.blink(red)
		End If
		//fill in health bar
		healthbar1.draw(convertTodecimal(1)-healthbar.converttodec(player1.health, 100))
		//scores
		Pen(False)
		moveTO(0,40)
		print("Score1: " + player1.score)
		moveTO(500,40)
		print("Score2: " + player2.score)
		
		//draw timebar
		If ( l.time - totalGameTime)/(l.time) > 2.0/3.0 Then
			color(limegreen)
		Else If ( l.time - totalGameTime)/(l.time) > 1.0/3.0 Then
			color(yellow)
		Else
			timeBar2.blink(red)
		End If
		timeBar2.draw(( l.time - totalGameTime)/(l.time))
		If player2.health > 65 Then
			color(limegreen)
		Else If player2.health >=35 Then
			color(yellow)
		Else
			healthbar2.blink(red)
		End If
		healthbar2.draw(convertTodecimal(1)-healthbar.converttodec(player2.health, 100))
		RefreshScreen()
	End Method
	
	
	//moves enemy
	//created by Kevin Meyer, 18Oct2009
	//move enemy comes in 3 stages
	//If enemy is at intersection
	//first, it  gets the order to check the directions = get possibles
	//second, it checks those directions in order, and checks to see which way it should move getEnemyDirections
	//third, it then moves either enemyspeed, or until it hits a wall.  
	
	//run this every frame
	Method MoveEnemy(e As Enemy, p As player)
		//If not at an intersection, con't change direction
		Define cellchanges As Boolean
		
		If abs((convertToDecimal(convertToInteger(e.xpos)) - e.xpos))< enemyspeed/2 And  abs((convertToDecimal(convertToInteger(e.ypos)) - e.ypos))< enemyspeed/2 Then
			//get new direction
			e.Direction = getEnemyDirection(e, p)
			
		End If
		//use direction to move.  
		If e.active Then
			Select e.Direction
				Case 0 
					//will the enemy change cells
					cellchanges = Not (ceiling(e.ypos) = ceiling(e.ypos-enemyspeed))
					//if it won't change cells or the new cell has no wall to bang up against, move normal
					If (Not cellchanges Or (getCell(round(e.xpos), floor(e.ypos - enemyspeed)).down And cellchanges)) Then
						changeEnemyPosition(round(e.xpos),e.ypos -enemyspeed, e)	
					Else//else move until the wall
						changeEnemyPosition(round(e.xpos),ceiling(e.ypos - enemyspeed), e)
					End If
					
				End Case
				//repeats above for every other direction
				Case 1 
					cellchanges = Not (floor(e.xpos) = floor(e.xpos+enemySpeed))
					If (Not cellchanges Or (getCell(ceiling(e.xpos + enemyspeed),round(e.ypos)).left And cellchanges))  Then
						changeEnemyPosition(e.xpos +enemyspeed, round(e.ypos),e)	
					Else
						changeEnemyPosition(floor(e.xpos +enemyspeed),round(e.ypos), e)
					End If
				End Case
			
				Case 2 
					cellchanges = Not (floor(e.ypos) = floor(e.ypos+enemySpeed))
					If (Not cellchanges Or (getCell(round(e.xpos), ceiling(e.ypos + enemyspeed)).up And cellchanges)) Then
						changeEnemyPosition(round(e.xpos),e.ypos +enemyspeed, e)	
					Else
						changeEnemyPosition(round(e.xpos),floor(e.ypos + enemyspeed), e)
					End If
				End Case
			
				Case 3 
					cellchanges = Not (ceiling(e.xpos) = ceiling(e.xpos-enemySpeed))
					If (Not cellchanges Or (getCell(floor(e.xpos - enemyspeed),round(e.ypos)).right And cellchanges))  Then
						changeEnemyPosition(e.xpos -enemyspeed, round(e.ypos),e)	
					Else
						changeEnemyPosition(ceiling(e.xpos - enemyspeed),round(e.ypos), e)
					End If
				End Case
			End Select
		Else
			e.psprite.Hide()
		End If
	End Method

	//returns enemy's direction
	//created by Kevin Meyer, 18Oct2009
	Function getEnemyDirection(e As enemy, p As Player) As Integer
		// gives order of directions
		Define directions As Integer[4] = getPossibles(e, p)
		
		Define counter As Integer
		For counter = 1 To 4
			//checks to see if can move in that direction
			//checks each of directions in order from getPossibles
			Select directions[counter]
				Case 0
					If getEnemyCell(e.xpos, e.ypos, 0).up  = True Then
						Return 0
					End If
				End Case
				
				Case 1
					If (getEnemyCell(e.xpos, e.ypos, 1).right = True)Then
						Return 1
					End If
				End Case
				
				Case 2
					If getEnemyCell(e.xpos, e.ypos, 2).down = True Then
						Return 2
					End If
				End Case
							
				Case 3
					If getEnemyCell(e.xpos, e.ypos, 3).left = True Then
						Return 3
					End If
				End Case
				
					
			End Select
			//End If
		Next
		
		//If, you can't move, returns -12, will be rejected by moveEnemy
		Return -12
	End Function
	
	//This will return the order in which the directions should be checked
	//for enemy movement	
	//created by Kevin Meyer, 18Oct2009
	Function getPossibles(e As enemy, p As player) As Integer[]
		Define order As Integer[4]
		Define l As Level = currentlevel()
		Define deltax As Decimal = p.xpos - e.xpos
		Define deltay As Decimal = p.ypos - e.ypos
		//If within change, will attack player
		//outside will do random	
		
		//allows for wraparound
		If deltax > l.columns/2.0 Then
			deltax -=l.columns
		End If
		If deltax < -l.columns/2.0 Then
			deltax +=l.columns
		Else If deltay > l.rows/2.0 Then
			deltay -= l.rows
		Else If deltay < -l.rows/2.0 Then
			deltay += l.rows
		End If
		If abs(deltax)<=currentDifficulty().aiTransfer And abs(deltay)<=currentDifficulty().aiTransfer Then
			//build order - tries to head straight at you, then sort of perpendicular, then reverse perpendicular then away
			If abs(deltay)> abs(deltax) Then
				If deltay > 0 Then
					order[1] = 2
					order[4] = 0
					If deltaX > 0 Then
						order[2] = 1
						order[3] = 3
					Else
						order[3] = 1
						order[2] = 3
					End If
				Else
					order[4] = 2
					order[1] = 0
				
					If deltaX > 0 Then
						order[2] = 1
						order[3] = 3
					Else
						order[3] = 1
						order[2] = 3
					End If
				End If
			Else
				If deltax >0 Then
					order[1] = 1
					order[4] = 3
					If deltay > 0 Then
						order[2] = 2
						order[3] = 0
					Else
						order[3] = 2
						order[2] = 0
					End If
				Else
					order[4] = 1
					order[1] = 3
				
					If deltay > 0 Then
						order[2] = 2
						order[3] = 0
					Else
						order[3] = 2
						order[2] = 0
					End If
				End If
			End If
		Else
			//random walk
			//last priority is backwards
			//second is forwards
			//first and third are left/right- random order
			If e.Direction>1 Then
				order[4] = e.Direction - 2
			Else
				order[4] = e.Direction + 2
			End If
			order[2] = e.direction
			Define n As Integer = random(0,3)
			
			If n = order[4] Then
				n += 1
			Else If n = order[2] Then
				n += 1
			End If			
			If n >= 4 Then
				n -=4
			End If
		
			order[1] = n
			n+=2
			If n >= 4 Then
				n -=4
			End If
			order[3] = n
			
		
		End If
		//return the order
		Return order
	End Function
		
	
	Function getPossibles(e As enemy, p As player[]) As Integer[]
		Define order As Integer[4]
		Define i As Integer
		Define l As Level = currentlevel()
		Define closeAttack As Boolean = False
		Define deltax As Decimal = p[1].xpos - e.xpos
		Define deltay As Decimal = p[1].ypos - e.ypos
		For i = 1 To arraylength(p)
			Define deltaxt As Decimal = p[i].xpos - e.xpos
			Define deltayt As Decimal = p[i].ypos - e.ypos
			//If within change, will attack player
			//outside will do random	
		
			//allows for wraparound
			If deltax > l.columns/2.0 Then
				deltax -=l.columns
			End If
			If deltax < -l.columns/2.0 Then
				deltax +=l.columns
			Else If deltay > l.rows/2.0 Then
				deltay -= l.rows
			Else If deltay < -l.rows/2.0 Then
				deltay += l.rows
			End If
				
			If abs(deltax)<=currentDifficulty().aiTransfer And abs(deltay)<=currentDifficulty().aiTransfer Then
				closeAttack = True
				If abs(deltax) > abs(deltaxt) Then
					deltax = deltaxt
				End If
				If abs(deltay) > abs(deltayt) Then
					deltay = deltayt
				End If
			End If
		Next
		If closeAttack Then
			//build order - tries to head straight at you, then sort of perpendicular, then reverse perpendicular then away
			If abs(deltay)> abs(deltax) Then
				If deltay > 0 Then
					order[1] = 2
					order[4] = 0
					If deltaX > 0 Then
						order[2] = 1
						order[3] = 3
					Else
						order[3] = 1
						order[2] = 3
					End If
				Else
					order[4] = 2
					order[1] = 0
				
					If deltaX > 0 Then
						order[2] = 1
						order[3] = 3
					Else
						order[3] = 1
						order[2] = 3
					End If
				End If
			Else
				If deltax >0 Then
					order[1] = 1
					order[4] = 3
					If deltay > 0 Then
						order[2] = 2
						order[3] = 0
					Else
						order[3] = 2
						order[2] = 0
					End If
				Else
					order[4] = 1
					order[1] = 3
				
					If deltay > 0 Then
						order[2] = 2
						order[3] = 0
					Else
						order[3] = 2
						order[2] = 0
					End If
				End If
			End If
		Else
			//random walk
			//last priority is backwards
			//second is forwards
			//first and third are left/right- random order
			If e.Direction>1 Then
				order[4] = e.Direction - 2
			Else
				order[4] = e.Direction + 2
			End If
			order[2] = e.direction
			Define n As Integer = random(0,3)
			
			If n = order[4] Then
				n += 1
			Else If n = order[2] Then
				n += 1
			End If			
			If n >= 4 Then
				n -=4
			End If
		
			order[1] = n
			n+=2
			If n >= 4 Then
				n -=4
			End If
			order[3] = n
			
		
		End If
		//return the order
		Return order
	End Function
	//makes sure that cells that have enemies are true (in theory)- useless - don't quiz on
	Method updateContainsEnemy()
		Define counter As Integer
		Define onColumn As Boolean
		Define onRow As Boolean
		Define l As Level = currentlevel()
		For counter = 1 To arraylength(currentlevel().maze)
			l.maze[counter].containsEnemy = False
		Next
		For counter = 1 To arraylength(l.enemyset)
			If l.enemyset[counter].active Then
				Define x As Integer = l.enemyset[counter].xpos 
				Define y As Integer = l.enemyset[counter].ypos
					getCell(floor(x),floor(y)).containsEnemy = True
					getCell(floor(x),ceiling(y)).containsEnemy = True
					getCell(ceiling(x),floor(y)).containsEnemy = True
					getCell(ceiling(x),ceiling(y)).containsEnemy = True
			End If
 		Next
	End Method
	
	//creates maze - room for adding, might just copy and paste gencells into this
	//runs during levelcreation
	Method CreateMaze() 
		GenerateCells()
		
	End Method
	
	//this sets defaults and rows/ columns for the maze
	//created 14Oct2009 by Kevin Meyer
	Method GenerateCells()
		Define i As Integer
		Define l As Level = currentlevel()
		//creates default values = full maze
		For i = 1 To l.rows * l.columns
			l.Maze[i].left = False//can move through
			l.Maze[i].up = False//can't move up
			l.Maze[i].index = i-1//might be useful
			l.Maze[i].row = l.Maze[i].index/l.columns +1 //row			
			l.Maze[i].column = l.Maze[i].index + 1 - ((l.Maze[i].row-1)*l.columns)//columns
			l.Maze[i].xpos = l.Maze[i].column//starting xpos
			l.Maze[i].ypos = l.Maze[i].row//starting ypos
		Next
		
		//method for changing default left and up booleans - by hand or if needed, randomly
		removeWalls(l.removeLeft , l.removeUp, l.removeRight, l.RemoveDown)		
		
		//sets default right and down booleans using appropiate left and up booleans
		//don't forget wrap-around issues
		For i = 1 To l.rows * l.columns
			If l.Maze[i].row = l.rows Then 
				l.Maze[i].down = l.Maze[i - (l.rows*(l.columns -1))].up
			Else
				l.Maze[i].down = l.Maze[i + l.columns].up	
			End If
						
			If l.Maze[i].column = l.columns Then 
				l.Maze[i].right = l.Maze[i - l.columns + 1].left
			Else
				l.Maze[i].right = l.Maze[i + 1].left
				
			End If
		Next
		For i = 1 To arrayLength(l.invalidLocations)
			l.invalidLocations[i].invalidLoc = True
		Next
	End Method
	
	Function getEnemyDirection(e As enemy, p As Player[]) As Integer
		// gives order of directions
		Define directions As Integer[4] = getPossibles(e, p)
		
		Define counter As Integer
		For counter = 1 To 4
			//checks to see if can move in that direction
			//checks each of directions in order from getPossibles
			Select directions[counter]
				Case 0
					If getEnemyCell(e.xpos, e.ypos, 0).up  = True Then
						Return 0
					End If
				End Case
				
				Case 1
					If (getEnemyCell(e.xpos, e.ypos, 1).right = True)Then
						Return 1
					End If
				End Case
				
				Case 2
					If getEnemyCell(e.xpos, e.ypos, 2).down = True Then
						Return 2
					End If
				End Case
							
				Case 3
					If getEnemyCell(e.xpos, e.ypos, 3).left = True Then
						Return 3
					End If
				End Case
				
					
			End Select
			//End If
		Next
		
		//If, you can't move, returns -12, will be rejected by moveEnemy
		Return -12
	End Function
	
	
	Method MoveEnemy(e As Enemy, p As player[])
		//If not at an intersection, con't change direction
		Define cellchanges As Boolean
		
		If abs((convertToDecimal(convertToInteger(e.xpos)) - e.xpos))< enemyspeed/2 And  abs((convertToDecimal(convertToInteger(e.ypos)) - e.ypos))< enemyspeed/2 Then
			//get new direction
			e.Direction = getEnemyDirection(e, p)
			
		End If
		//use direction to move.  
		If e.active Then
			Select e.Direction
				Case 0 
					//will the enemy change cells
					cellchanges = Not (ceiling(e.ypos) = ceiling(e.ypos-enemyspeed))
					//if it won't change cells or the new cell has no wall to bang up against, move normal
					If (Not cellchanges Or (getCell(round(e.xpos), floor(e.ypos - enemyspeed)).down And cellchanges)) Then
						changeEnemyPosition(round(e.xpos),e.ypos -enemyspeed, e)	
					Else//else move until the wall
						changeEnemyPosition(round(e.xpos),ceiling(e.ypos - enemyspeed), e)
					End If
					
				End Case
				//repeats above for every other direction
				Case 1 
					cellchanges = Not (floor(e.xpos) = floor(e.xpos+enemySpeed))
					If (Not cellchanges Or (getCell(ceiling(e.xpos + enemyspeed),round(e.ypos)).left And cellchanges))  Then
						changeEnemyPosition(e.xpos +enemyspeed, round(e.ypos),e)	
					Else
						changeEnemyPosition(floor(e.xpos +enemyspeed),round(e.ypos), e)
					End If
				End Case
			
				Case 2 
					cellchanges = Not (floor(e.ypos) = floor(e.ypos+enemySpeed))
					If (Not cellchanges Or (getCell(round(e.xpos), ceiling(e.ypos + enemyspeed)).up And cellchanges)) Then
						changeEnemyPosition(round(e.xpos),e.ypos +enemyspeed, e)	
					Else
						changeEnemyPosition(round(e.xpos),floor(e.ypos + enemyspeed), e)
					End If
				End Case
			
				Case 3 
					cellchanges = Not (ceiling(e.xpos) = ceiling(e.xpos-enemySpeed))
					If (Not cellchanges Or (getCell(floor(e.xpos - enemyspeed),round(e.ypos)).right And cellchanges))  Then
						changeEnemyPosition(e.xpos -enemyspeed, round(e.ypos),e)	
					Else
						changeEnemyPosition(ceiling(e.xpos - enemyspeed),round(e.ypos), e)
					End If
				End Case
			End Select
		Else
			e.psprite.Hide()
		End If
	End Method
	//will remove the left walls of all the positions in removeLeft, and all the upper walls in RemoveUp
	//created 12:56 AM 15OCT2009 by Kevin Meyer
	//edited 2:35 Pm, 15Oct2009 by Kevin Meyer - added removeRight and Down
	Method removeWalls(removeLeft As Cell[], removeUp As Cell[],removeRight As Cell[],removeDown As Cell[])
		Define n As Integer
		//removes the left walls from these cells
		If ArrayLength(removeLeft)>0 Then 
			For n = 1 To ArrayLength(removeLeft)
				removeLeft[n].left = True
			Next
		End If
		
		//right walls
		If ArrayLength(removeRight)>0 Then 
			For n = 1 To ArrayLength(removeRight)
				getCell(removeRight[n].column + 1, removeRight[n].row).left = True
			Next
		End If
		
		
		//upper walls
		If ArrayLength(removeUp)>0 Then
			For n = 1 To ArrayLength(removeUp)
				removeUp[n].up = True
			Next
		End If
		
		//down walls
		If ArrayLength(removeDown)>0 Then 
			For n = 1 To ArrayLength(removeDOwn)
				getCell(removeDown[n].column, removeDown[n].row + 1).up = True
			Next
		End If
	End Method
	
	//adds goodFoods to the appropriate level
	//called in initGame during level creation
	Function addGoodFoods(pts As cell[], pic As String) As goodfood[]
		Define i As Int
		Define i2 As Integer
		Define x As Integer
		Define y As Integer
		Define valid As Boolean
		Define loc As goodfood[arraylength(pts)]
		//puts goodfoods into cells in pts
		For i = 1 To arraylength(pts)
			Define g As goodfood
			g.loadFood(pts[i].column,pts[i].row,pic, cellsize)
			loc[i] = g
		Next
		
		Return loc
	End Function
	
	//draws maze, cell by cell
	//created 14Oct2009 by Kevin Meyer
	Method DrawMaze()
		Define l As Level = currentlevel()
		clearBackground(white)
		Define i As Integer
		penwidth(2)//sets penwidth = 2
		//draws cell
		For i =  1 To l.rows*l.columns
			DrawCell(l.Maze[i])
		Next
	End Method
	
	//draws an individual cell TheCell at it's location
	//created 14Oct2009 by Kevin Meyer
	Method DrawCell(TheCell As Cell)
		//converts columns and rows to x and y
		Define x As Integer= ConvertX(theCell.xpos)
		Define y As Integer = ConvertY(theCell.ypos)
		Define l As Level = currentLevel()
	
		//fills in invalid location cells
		If theCell.invalidLoc Then
			color(cyan)
			Pen(False)
			moveTo(x,y)
			Pen(True)
			Rectangle(cellsize,cellsize,True)
			If thecell.left Then
				DrawLine(x,y,x,y+cellsize)
			End If
			If  thecell.up Then
				DrawLine(x,y,x+cellSize,y)
			End If
			color(black)
		End If
		//draws upper wall if needed
		If Not theCell.up Then
			DrawLine(x,y,x+cellSize,y)
		End If	
		//draws left wall, if needed
		If Not TheCell.left Then
			DrawLine(x,y,x,y+cellsize)
		End If
		If thecell.column = l.columns And Not thecell.right Then
			DrawLine(x+cellsize,y,x+cellsize,y+cellsize)
		End If
		If thecell.row = l.rows And Not thecell.down Then
			DrawLine(x,y+cellsize,x+cellsize,y+cellsize)
		End If
		//right and lower wall will be taken care of by appropriate adjacent cells
		
		
		//will draw cell coordinates in cell when uncommented - useful dev tool
		If IsKeydown("Z") Then
			Pen(False)
			moveTo(x, y)
			Print("("+ theCell.column + "," + theCell.row + ")")
			Pen(True)
		End If
	End Method
	
	//returns cell in (column,row)
	//created 14Oct2009 by Kevin Meyer
	//called everywhere
	Function getCell( col As Integer, ro As Integer) As Cell
		//calls cell given inputted coordinates
		Return currentlevel().Maze[getI(col,ro)]
	End Function
	
	//deals with decimal player location to integer cell location issues
	//uses direction to return appropriate cell
	Function GetPlayercell(col As Decimal, ro As Decimal, p As player) As Cell
		Define l As Level = currentlevel()
		//
		If p.direction = 0 Then 
			Return l.Maze[getI(round(col),ceiling(ro))]
		Else If p.direction = 1 Then 
			Return l.Maze[getI(floor(col),round(ro))]
		Else If p.direction = 2 Then 
			Return l.Maze[getI(round(col),floor(ro))]
		Else	
			Return l.Maze[getI(ceiling(col),round(ro))]
		End If
	End Function
	
	//returns enemies cell, based upon decimal location and direction
	//created by Kevin Meyer, 17Oct2009
	Function GetEnemyCell(col As Decimal, ro As Decimal,direction As Integer) As Cell
		
		Define l As Level = currentlevel()
		If direction = 0 Then 
			Return l.Maze[getI(round(col),ceiling(ro))]
		Else If direction = 1 Then 
			Return l.Maze[getI(floor(col),round(ro))]
		Else If direction = 2 Then 
			Return l.Maze[getI(round(col),floor(ro))]
		Else	
			Return l.Maze[getI(ceiling(col),round(ro))]
		End If
	End Function
	
	//assumes position is in maze or will stop program
	//created 14Oct2009 by Kevin Meyer
	//(15Oct09, Boshen)changed parameters and return values slightly to work with changepos
	//returns appropriate array location given cell coordinates
	Function getI(col As Integer, ro As Integer) As Integer
		//position must be in maze, edits for wraparound
		Define l As Level = currentLevel()
		If col<=0.5 Then
			col += l.columns
		End If
		If col>l.columns+.5 Then
			col-= l.columns
		End If
		If ro<=0.5 Then
			ro+=l.rows
		End If
		If ro> l.rows +.5 Then
			ro-=l.rows
		End If
		//returns appropriate array location given cell coordinates
		Return l.columns * (ro-1) + col			

	End Function
	
	
	//use this to change the characters position 
	//created by Boshen Wang, 15Oct2009
	//deals with wraparounds
	Method changeCharacterPosition(x As Decimal, y As Decimal, p As player)
		Define l As Level = currentLevel()
		If x <= .5 Then
			x += l.columns
		Else If x - .5 > l.columns Then
			x -= l.columns
		End If
		If y <= .5 Then
			y += l.rows
		Else If y-.5 > l.rows Then
			y -= l.rows 
		End If
		p.changepos(x,y, Convertx(p.startx), convertY(p.starty))
		
	End Method
	
	Method changeCharacterPositionMulti(x As Decimal, y As Decimal, p As player)
		Define l As Level = currentLevel()
		If x <= 1 Then
			x += l.columns
		Else If x - 1 > l.columns Then
			x -= l.columns
		End If
		If y <= .5 Then
			y += l.rows
		Else If y-.5 > l.rows Then
			y -= l.rows 
		End If
		p.changepos(x,y, Convertx(x), convertY(y))
		
	End Method
	
	//created by Boshen Wang, 15Oct2009
	//edited by Kevin Meyer, 16Oct2009 for new decimal format
	//will change position to x and y, will not redraw
	//redraw in scrollgame
	Method changeEnemyPosition(x As Decimal, y As Decimal,e As enemy)
		Define l As Level = currentLevel()
		If x <= .5 Then
			x = l.columns +.5
		Else If x - .5 >= l.columns Then
			x = .5
		End If
		If y <= .5 Then
			y=l.rows +.5
		Else If y-.5 >= l.rows Then
			y = .5
		End If
		e.changepos(x,y)
	End Method
	
	//combo of really bad progress screen and general holding pin at end of level
	//just a transition
	Method PlayAgain()
		//a is used to see if the last key was q => exit to levelselect
		Define a As String = getKey()
		//oine last scorecheck
		//character.setScore(diff*diff*(0+character.Health*10+character.goodFoodsHit*100-character.enemiesHit*200-TotalGameTime*5))
		
		//leaves level
		
		//displays console
		ShowConsole()
		
		//win or lose- act and display accordingly
		If haswon Then
			ConsoleWrite("You beat " + toString(clevel))
			currentlevel().hasbeenbeaten[diff+1] = True
		Else
			character.lives -= 1
			ConsoleWrite("You Lost")
		
		End If
		//write progress
		ConsoleWrite("\n"+ convertToclock(totalGameTime)+"\nTotal Enemies Hit: " + character.enemiesHit + "\nTotal Good Foods Eaten: " + character.goodFoodsHit + "\nFInal Health: " + character.health + "\nMax Health: " + character.maxHealth + "\nMin Health: " + character.minHealth + "\nScore:"+ character.score+ "\n")
		//wipe old input
		clearMouseEvents()
		clearKeyboardEvents()
		//wait for input to advance
		ConsoleWrite("Hit any key to continue\n")
		If character.lives>0  And Not hasWon Then
			ConsoleWrite("or Q To quit")
		End If
		//elim keypress
		DElay(500)
		
		While getKey() = ""
			delay(1)
		End While
		If isKeyDown("q") Or getKey() = "q" Then
			a = "q"
		End If
		HideConsole()
		ClearConsole()
		
		//if quit is neccessary, then exit to levelselect
		If character.lives <=0  Or a = "q"  Or haswon Then
			currentmenu = "levelselect"
		End If
		Define credMusic As Sound
		credMusic.LoadFile("Track1.wav")
		Define credSprite As Sprite
		credSprite.Load("carrot.png")
		If currentlevel() = level5 And haswon Then
			scrollcredits(credSprite, credMusic)
		End If
		leavecurrentlevel()
	End Method
	
	
	//provides level string
	Function toString(l As Integer) As String
		Return "level " + l
	End Function
	
	//converts gametime to clock for progress screen
	Function convertToClock(l As Decimal) As String
		Define minutes As Integer = 0
		Define Seconds As Integer = 0
		While l>= 60
			minutes += 1
			l -= 60
		End While
		While l>= 1 
			seconds +=1
			l-=1
		End While
		If seconds < 10 Then
			Return minutes +":0" + seconds
		Else 
			Return minutes +":" + seconds
		End If
		
		//return("1:00")
	End Function
	
	//unloads all of currentlevel
	//pulls most of the sprites out of memory
	Method leaveCurrentLevel()
		//unloads lifesprite
		lifeSprite.Unload()
		//wipes background
		clearBackground(white)
		Define l As Level = currentlevel()
		Define counter As Integer
		//unloads enemies
		For counter = 1 To arrayLength(l.enemyset)
			If l.enemyset[counter].isLoaded Then 
				l.enemyset[counter].unload()
			End If
		Next
		//unloads goodfoods
		For counter = 1 To arraylength(l.goodFoods)
			If l.goodFoods[counter].isLoaded Then
				l.goodFoods[counter].unload()
			End If
		Next
		//unloads player(s)
		If l=multi Then
			If player1.hasBeenLoaded Then
				player1.psprite.unload()
			End If
			If player2.hasBeenLoaded Then
				player2.psprite.unload()
			End If
		Else
			If character.hasBeenLoaded Then
				character.psprite.unload()
			End If
		End If
		l.foodseaten=0
		//unloads all the various progress bars
		If progress.isloaded Then 
			progress.icon.Hide()
		End If
		If healthbar.isloaded Then
			healthbar.icon.Hide()
		End If
		If timebar.isloaded Then
			timebar.icon.Hide()
		End If
		If timebar2.isloaded Then
			timebar2.icon.Hide()
		End If
		If healthbar1.isloaded Then
			healthbar1.icon.Hide()
		End If
		If healthbar2.isloaded Then
			healthbar2.icon.Hide()
		End If
	End Method
	
	
	//will convert xpos in maze to xpos in plot
	//created 10:29AM 15Oct2009 by Kevin Meyer
	Function ConvertX(x As Decimal) As Integer
		Define l As Level = currentLevel()
		//overlap issues
		While x> l.columns +.5
			x -= l.columns
		End While
		While x <=.5
			x += l.columns
		End While
		//centers in plot
		Return (x * CellSize) - CellSize+2 + (screenwidth())/2 - cellsize*l.columns/2.0
	End Function
	
	//will convert ypos in maze to ypos in plot
	//created 10:29AM 15Oct2009 by Kevin Meyer
	Function ConvertY(y As Decimal) As Integer
		Define l As Level = currentLevel()
		//change
		While y> l.rows +.5
			y -= l.rows
		End While
		While y <=.5
			y += l.rows
		End While
		//pops out position centered in plot
		Return (y * CellSize) - CellSize + yGap -2+ (screenHeight()-yGap)/2 - cellsize*l.rows/2.0
	End Function
	
	
	//(20Oct09,Boshen) method will check if the player has been caught by an enemy
	
	Function caught(enemySet As enemy[], p As player) As Boolean
		Define i As Integer
		p.hasBeenHit = False//player can only be hit once per frame
		Define intersect As Boolean = False
		For i = 1 To arrayLength(enemySet)
			Define e As Enemy = enemySet[i]
			If e.active  And  intersectsPlayerEnemy(e, p) Then// if still alive and intersects player
				If Not e.IsBurger Then
					e.active = False//not alive
				End If
				If Not p.hasBeenHit Then// if first hit
					p.setPlayerHealth( p.health - currentDifficulty().enemyHurt)//hurt player
					p.hasbeenHit = True//can't be hit
				End If
				p.enemiesHit+=1//hit += 1
				intersect = True//yes, you intersected so play enemysound
			End If
		Next
		Return intersect//did you inntersect an enemy
	End Function
	
	
	//does player intersect enemy
	Function intersectsPlayerEnemy(e As enemy, p As player) As Boolean
		
		Define x As Decimal = p.xpos
		Define y As Decimal = p.ypos
		//within one cell or sprites intersected
		If abs(x-e.xpos) < 1 And abs(y-e.ypos)< 1 Or p.psprite.Intersects(e.psprite) Then
			Return True
		End If
		Return False
	End Function
	
	
	//loads selected menu - q equals advance
	Method loadcurrentmenu(music As Sound, playthis As sound)
		//sounds are various music
		//sends to main
		
		
		If currentmenu = "main" Then
			//reloads music 
			background.LoadFile("level2.wav")
			background2.LoadFile("level.wav")
			mainmenu(music, playthis)
		//sends to levelselect
		Else If currentmenu = "levelselect" Then
			//reloads music
			background.LoadFile("level2.wav")
			background2.LoadFile("level.wav")
			levelselect(music, playthis)
		//sends to difficulty
		Else If currentmenu = "difficulty" Then
			difficultymenu()
		End If
	End Method	
	
	//levelselect menu
	Method levelselect(StopThisSound As Sound, playThis As Sound)
		//butons to select levels
		Define lvl1 As button
		Define lvl2 As button
		Define lvl3 As button
		Define lvl4 As button
		Define lvl5 As button
		Define mainmenu As button
		Define buttonclicked As Boolean
		Define screensprite As String
		
		//change music
		StopThisSound.Stop()
		playthis.play()
		
		//clear inputs
		clearMouseEvents()
		
		
		beginframe()
		//load buttons
		lvl1.loadbutton(screenwidth()/2-(175*3/2),screenheight()/2-(175*3/2),"level.png")
		lvl2.loadbutton(screenwidth()/2+(175*1/2),screenheight()/2-(175*3/2),"level2.png")
		lvl3.loadbutton(screenwidth()/2-(175*3/2),screenheight()/2+(175*1/2),"level3.png")
		lvl4.loadbutton(screenwidth()/2+(175*1/2),screenheight()/2+(175*1/2),"level4.png")
		If haveunlocked() Then
			lvl5.loadbutton(screenwidth()/2-(175*1/2),screenheight()/2-(175*1/2),"level5.png")
		Else 
			lvl5.loadbutton(screenwidth()/2-(175*1/2),screenheight()/2-(175*1/2),"carrot.png")
		End If
		mainmenu.loadbutton(screenwidth()/2-(175*1/2),screenheight()/2+(175*1/2),"Main Menu.png")
		refreshscreen()
		
		If Not playthis.IsPlaying Then
			playthis.playLoop()
		End If
		
		//DO NOT DELETE - means old clicks don't carry over
		While  Not mouse.Event = "ButtonDown"
			delay(1)
		End While
		
		//while hasn't pushed a button
		While buttonclicked=False			
			If lvl1.isclicked()=True Then
				buttonclicked=True//biutton has been clicked
				screensprite = "Info Screen.png"//load as info screen
				currentmenu = "q"//move on out of menu loop
				setLevel(1)//set level according to button
				
				//applies to all buttons
			Else If lvl2.isclicked()=True Then
				buttonclicked=True
				screensprite = "Info Screen4.png"
				currentmenu = "q"
				setLevel(2)
			Else If lvl3.isclicked()=True Then
				buttonclicked=True
				screensprite = "Info Screen3.png"
				currentmenu = "q"
				setLevel(3)
			Else If lvl4.isclicked()=True Then
				buttonclicked=True
				screensprite = "Info Screen2.png"
				currentmenu = "q"
				setLevel(4)
			Else If lvl5.isclicked()=True Then
				If haveUnlocked() Then
					buttonclicked=True
					screensprite = "Info Screen5.png"
					currentmenu = "q"
					setLevel(5)
				Else
					alert("You have not unlocked level 5 yet", "Locked Feature")
				End If
			Else If mainmenu.isclicked()=True Then
				screensprite = ""
				buttonclicked = True
				currentmenu = "main"
				
				
			End If
		End While
		//unloads and displays info screen
		lvl1.buttonpic.Unload()
		lvl2.buttonpic.Unload()
		lvl3.buttonpic.Unload()
		lvl4.buttonpic.Unload()
		lvl5.buttonpic.Unload()
		mainmenu.buttonpic.Unload()
		buttonclicked=False
		clearMouseEvents()
		//displays info
		If Not screensprite = "" Then
			lvlinfo.load(screensprite)
		End If
		playthis.Stop()
		character.lives = 3
		//delay(100)
	End Method
	
	//checks to see if level5 is playable
	Function haveunlocked() As Boolean
		If (level1.hasbeenBeaten[diff+1] And level2.hasbeenBeaten[diff+1] And level3.hasbeenBeaten[diff+1] And level4.hasbeenBeaten[diff+1]) Or unlocked[diff +1]  Then
			Return True
		End If
		Return False
	End Function
	
	//currently useless scroll credits methods - please do NOT quiz on this
	//It does nothing
	//will eventually scroll credits
	Method scrollCredits(Image As Sprite, music As sound)
		Image.Scale(100*(screenwidth()/Image.width), 100*(screenwidth()/Image.Width))
		image.MoveTo(0,0)
		image.Show()
		music.PlayLoop()
		clearKeyboardEvents()
		clearMouseEvents()
		Define i As Integer 
		Define mouseclicked As Boolean
		For i = 0 To image.Height-screenheight()
			Image.moveTo(0, -i)
			If mouseclicked Or Not getKey() = "" Then
				i = Image.height
			End If
		Next
		While (Not mouseClicked) And getKey() = ""
			delay(1)
		End While
		clearkeyboardevents()
		clearmouseEvents()
	End Method
	
	//main menu
	//will get input and either stop or shift to main menu
	//go to difficulty select or quit
	
	Method mainmenu(playthis As Sound, stopThis As sound)
		Define buttonclicked As Boolean
		Define play As button
		Define quit As button
		Define multi As button
		Define screensprite As String
		clearMouseEvents()
		//beginframe()
		//load buttons
		play.loadButton((screenwidth()-125)/2,screenwidth()/2 - 150,"Play.png")
		quit.loadButton((screenwidth()-125)/2,screenwidth()/2 + 25,"Quit.png")
		multi.loadbutton(0,0,"Multiplayer.png")
		//refreshscreen()
		//background.LoadFile("level2.wav")
		//begin new music
		stopthis.Stop()
		If Not playthis.IsPlaying Then
			playthis.playLoop()
		End If
		//DO NOT DELETE - means old clicks don't carry over
		While  Not mouse.Event = "ButtonDown"
			delay(1)
		End While
		//get button input
		While buttonclicked = False
			If play.isclicked()=True Then
				buttonclicked=True//button has been clicked
				currentmenu = "difficulty"//go to difficulty
			End If
			If quit.isclicked()=True Then//or exit
				stop()
			End If
			If multi.isclicked() Then
				//stop()
				buttonclicked=True//button has been clicked
				currentmenu = "difficulty"//go to difficulty
				setLevel(6)//sets level as multiplayer
			End If
		End While
		//unload and clear input
		play.buttonpic.Unload()
		quit.buttonpic.Unload()
		multi.buttonpic.Unload()
		buttonclicked=False
		clearMouseEvents()
		
	End Method
	
	//difficulty menu
	//called from main menu
	Method difficultymenu()
		Define easy As button
		Define medium As button
		Define hard As button
		Define Chesney As button
		Define buttonclicked As Boolean
		clearMouseEvents()
		beginframe()
		//load buttons
		easy.loadbutton(300,50,"easy.png")
		medium.loadbutton(300,200,"normal.png")
		hard.loadbutton(300,350,"hard.png")
		Chesney.loadbutton(100,200, "Chesney.png")
		refreshscreen()
		//DO NOT DELETE - means old clicks don't carry over
		While  Not mouse.Event = "ButtonDown"
			delay(1)
		End While
		While buttonclicked = False
			If easy.isclicked()=True Then
				buttonclicked=True//button is clicked
				setdifficulty(1)//set difficulty
				currentmenu = "levelselect"//go to level select
				
				//repeat for all
			Else If medium.isclicked()=True Then
				buttonclicked=True
				setdifficulty(2)
				currentmenu = "levelselect"
			Else If hard.isclicked()=True Then
				buttonclicked=True
				setdifficulty(3)
				currentmenu = "levelselect"
			Else If Chesney.isclicked()=True Then
				buttonclicked=True
				setdifficulty(0)
				currentmenu = "levelselect"
			End If
		End While
		If currentLevel() = multi Then
			currentmenu= "q"
		End If
		//unload butons and destroy input
		easy.buttonpic.Unload()
		medium.buttonpic.Unload()
		hard.buttonpic.Unload()
		chesney.buttonpic.Unload()
		buttonclicked=False
		clearMouseEvents()
	End Method
End Program