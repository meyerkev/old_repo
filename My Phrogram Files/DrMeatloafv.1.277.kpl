/*
THings we want the beta testers to check out
Is this too hard, too easy (look, god ain't happening)

*/

Program DrMeatloaf
	
	Define muted As Boolean//is sound on - depending on who last edited
	//may be on or off
	
	
	//this is where we stored the difficulty
	Class Difficulty
		Define enemyhurt As Integer//how much the enemy will hurt the player at this difficulty
		Define goodFoodBonus As Integer//how the good food will help the player at this difficulty
		Define AITransfer As Decimal//the distance at which enemies begin to intercept the player
		//Define playerSpeeds As Decimal[3]
		//Define enemySpeed As Decimal
		
		//this loads these three catagories into the game
		Method loadDifficulty(hurt As Integer, bonus As Integer, transfer As Decimal)//
			enemyhurt = hurt
			goodFoodBonus = bonus
			AItransfer = transfer +1//account for player width
		End Method
		
		
	End Class
	
	
	//these are the goodfoods
	Class goodFood 
		Define xpos As Decimal// x position of the good food in the maze
		Define ypos As Decimal// y position of the good food in the maze
		
		Define psprite As Sprite//sprite that is defined to this good food
		Define cellsize As Integer//size of the cells
		Define active As Boolean = False//should the good food still be shown
		Define isReal As Boolean = False//does this good food exist at all
		Define picture As String//picture that goes with the sprite
		Define isLoaded As Boolean = False//is the picture loaded to the sprite
		Define DeadFrames As Integer = 100//number of frames a good food will wait before respawning on multiplayer
		Define DFrame As Integer = 0//Frames it's been dead for
		
		
		Method loadFood(x As Integer, y As Integer, pic As String, c As Integer)
			cellsize = c//input cell size
			picture = pic//adds the picture
			xpos = x//set initial x postion
			ypos = y//sets initial y position
			active = True//good food is alive
			isReal = True//good food exists
			
		End Method
		
		Method Load()
			psprite.Load(picture)//loads the sprites
			psprite.Scale(100*(cellsize-4)/This.psprite.Width,100*(cellsize-4)/This.psprite.Height)//scales them to the cell
			isLoaded = True//make sure sprite has been loaded
			active = True//sprite is active
			Dframe = 0//need to reset before every level
		End Method
		
		Method unload()
			psprite.hide()//hides the sprite
			psprite.Unload()//unloads picture from memory
			isLoaded = False//picture is now notloaded
		End Method
		
		Method changepos(x As Decimal, y As Decimal, movex As Integer, movey As Integer)//moves the sprite
			xpos = x//sets x position equal to x
			ypos = y//sets y position equal to y
			psprite.moveto( movex + cellsize/2 - psprite.Width/2, movey+ cellsize/2 - psprite.Height/2)//moves it apptoptiate position
		End Method
		
		Method changepos(x As Decimal, y As Decimal)//moves the sprite - not anymore
			xpos = x
			ypos = y
		End Method
		
	End Class
	
	//level class
	//contains maze, size, etc. for each level
	//created 19Oct2009 by Kevin Meyer
	Class Level
		Define rows As Integer = 15//gives you size
		Define columns As Integer = 15
		Define removeLeft As Cell[rows*columns]//what walls should be removed - removes name
		Define removeUp As Cell[rows * columns]
		Define removeRight As Cell[rows * columns]
		Define removeDown As Cell[rows * columns]
		Define enemyset As enemy[rows*columns]//what enemies for level
		Define invalidLocations As Cell[rows*columns]//use this to say what locations are actually in the maze
		//means an enemy or prize can't be put in a dead zone
		//Define goodpic As String
		Define goodFoods As goodFood[rows*columns]//what good foods for level
		Define SpawnLocations As Cell[rows*columns]//enemy spawn locations
		Define Maze As cell[rows *columns]//the maze
		Define totalfoods As Integer//total number of good foods
		Define foodseaten As Integer//number of foods eaten
		Define music As Sound//level music
		Define mus As String//string that says what music we've got for this level
		Define time As Integer//time limit
		Define barName As String//label of health bar
		//Define hasbeenBeaten As Boolean[5] 
		Define type As Integer = 1//Is this multiplayer
		Define questions As question[5]//question array
		Define linecolor As Integer//color of lines in maze
		Define cellcolor As Integer//color of invalid cells in maze
		Define backgroundcolor As Integer//bg color in maze
		
		//loadslevel
		//call this one for multiplayer
		Method loadLevelPt1(remLeft As cell[], remUp As cell[],remRight As cell[],remDown As cell[], music As String, t As Integer, bname As String, Invalid As cell[], lineCol As Integer, cellcol As Integer,backcol As Integer)
			//input what walls to remove
			removeLeft = remLeft
			removeUp = remUp
			removeRight = remRight
			removeDown = remDown
			mus = music//input music file
			time = t//set time limit
			barname = bname//set label on health bar
			invalidLocations = invalid//invalid locations
			linecolor = linecol//sets colors
			cellcolor = cellcol
			backgroundcolor = backcol
		End Method
		
		
		//cal this for singleplayer
		//loads the level pt1
		Method loadLevelPt1(remLeft As cell[], remUp As cell[],remRight As cell[],remDown As cell[], music As String, t As Integer, bname As String, Invalid As cell[], q As question[], lineCol As Integer, cellcol As Integer,backcol As Integer)
			//input what walls to remove
			removeLeft = remLeft
			removeUp = remUp
			removeRight = remRight
			removeDown = remDown
			mus = music//input music file
			time = t//set time limit
			barname = bname//set label on health bar
			invalidLocations = invalid//invalid locations
			questions = q//sets questions
			linecolor = linecol
			cellcolor = cellcol
			backgroundcolor = backcol
		End Method
		//inputs all those pesky enemysets that depend on cell location
		Method LoadLevelpt2(spawn As Cell[], enset As enemy[], foods As goodFood[])	
			goodfoods = foods//set of good foods
			enemyset = enset//set of enemies
			SpawnLocations = spawn//spawn locations
			totalfoods = arraylength(foods)//gets total number of foods
		End Method	
		
		//Notes: load level required two parts because part 1 gives yiu the info to assemble the maze which is required for all the stuff in part 2
		//all the arrays are rows * columns because can't create emptyended arrays
		
	End Class
	//cell class
	//created 14Oct2009 by Kevin Meyer
	Class Cell
		
		
		//Booleans for if can go through to the name direction
		Define left As Boolean//can go through left, true = yes
		Define up As Boolean//can go through up, true = yes
		Define right As Boolean//see above re right
		Define Down As Boolean//same re down
		
		//index within array(add one when calling)+row and column
		Define index As Integer//location
		Define row As Integer//Cell location in y direction top to bottom in array
		Define column As Integer//cell location in x left to right
		Define xpos As Decimal//relative x position
		Define ypos As Decimal//relative y position
		Define containsEnemy As Boolean = False//does this cell contain an enemy
		Define invalidLoc As Boolean = False//is this cell an invalis location, i.e not part of the maze
		Define containsGoodFood As Boolean = False//does thsi cell contain a good food
		
		
	End Class
	
	//the player
	Class Player
		
		Define startx As Decimal//staring x position
		Define starty As Decimal//starting y position
		Define xpos As Decimal//current xposition
		Define ypos As Decimal//current yposition
		Define Direction As Integer //0 = up, 1 = right, 2 = down, 3 = left
		Define psprite As Sprite//player sprite
		Define pspriteU As Sprite//up down left right version of player sprite
		Define pspriteL As Sprite
		Define pspriteR As Sprite
		Define pspriteD As Sprite
		Define cellsize As Integer//cell size
		Define health As Integer//health - scale 0 to 100
		Define playerSpeed As Decimal//how fast is player
		Define isReal As Boolean = False//check to see if player is real- hey, suff happens
		Define hasBeenLoaded As Boolean = False//has the sprite been loaded --error handling
		Define enemiesHit As Integer//how many enemies have you hit
		Define goodFoodsHit As Integer//how many goodfoods have you hit
		Define maxHealth As Integer//maxhealth
		Define MinHealth As Integer//minhealth
		Define score As Integer//current score in game
		Define lives As Integer//lives remaining
		Define hasBeenHit As Boolean//ensure can no be hit by enemies that can't be hit by more than one enemy in frame
		Define upKey As String//will move up, down etc. if you hit this key
		Define downKey As String//keys for movement
		Define rightKey As String
		Define leftKey As String
		Define invincible As Boolean = False//can you die
		//Define totalScores As Integer[5]
		Define type As Integer//what sprites should we call
		
		Method setPlayerSpeed()//set speed according to health
			If health > 65 Then
				playerspeed = .16
			Else If health >=35 Then
				playerspeed = .13
			Else 
				playerSpeed = .10
			End If
		End Method
		
		//loadplayer
		Method loadplayer(c As Integer)
			loadplayer(8,8,c)
		End Method
		//lets you pick position
		//loads player
		Method loadplayer(x As Integer, y As Integer, c As Integer)
			cellsize = c//sets cellsize
			loadSprites()//loads in sprites
			pspriteR.FlipHorizontal()//opp of left sprite
			pspriteU.Scale(100*(cellsize-4)/This.pspriteU.Width,100*(cellsize-4)/This.pspriteU.Height)//scale to cell
			pspriteD.Scale(100*(cellsize-4)/This.pspriteD.Width,100*(cellsize-4)/This.pspriteD.Height)
			pspriteL.Scale(100*(cellsize-4)/This.pspriteL.Width,100*(cellsize-4)/This.pspriteL.Height)
			pspriteR.Scale(100*(cellsize-4)/This.pspriteR.Width,100*(cellsize-4)/This.pspriteR.Height)
			health = 50//start health
			psprite= pspriteL
			xpos = x//set initial position
			ypos = y
			startx = xpos//remember initial position
			starty = ypos
			isReal = True//yep, I'm real
			hasBeenLoaded = True//and loaded
			maxHealth = health//reset max and minhealth
			minHealth = health
			enemiesHit = 0//haven't hit anything
			goodFoodsHit =0
			setPlayerSpeed()//how fast am I
			invincible = False//noyt invincible, you dummy
			
		End Method
		//loads sprites depending on your type
		//to hack this, in initlevel, say character.type = choice
		Method loadSprites()
			Select type
				Case 2
					pspriteU.Load("Nurse Back.gif")
					pspriteD.Load("Nurse Front.gif")
					pspriteL.Load("Nurse Side.gif")
					pspriteR.Load("Nurse Side.gif")
				End Case
				Case 3 
					pspriteU.Load("Potato Bag.png")
					pspriteD.Load("Potato Bag.png")
					pspriteL.Load("Potato Bag.png")
					pspriteR.Load("Potato Bag.png")
				End Case
				Case 4
					pspriteU.Load("Donut.png")
					pspriteD.Load("Donut.png")
					pspriteL.Load("Donut.png")
					pspriteR.Load("Donut.png")
					
				End Case
				Case 5
					pspriteU.Load("Fries.png")
					pspriteD.Load("Fries.png")
					pspriteL.Load("Fries.png")
					pspriteR.Load("Fries.png")
				End Case
				Case 6
					pspriteU.Load("Soda.png")
					pspriteD.Load("Soda.png")
					pspriteL.Load("Soda.png")
					pspriteR.Load("Soda.png")
				End Case
				Case 7
					pspriteU.Load("Burger.png")
					pspriteD.Load("Burger.png")
					pspriteL.Load("Burger.png")
					pspriteR.Load("Burger.png")
				End Case
				Case Else
					pspriteU.Load("Dr. Meatloaf Back.gif")
					pspriteD.Load("Dr. Meatloaf Front.gif")
					pspriteL.Load("Dr. Meatloaf Side.gif")
					pspriteR.Load("Dr. Meatloaf Side.gif")
				End Case
			End Select
			Define MyAnimationTimeline As Integer [4] 
			MyAnimationTimeline[1] = 200
			MyAnimationTimeline[2] = 200
			MyAnimationTimeline[3] = 200
			MyAnimationTimeline[4] = 200
			pspritel.AnimationTimeline = MyAnimationTimeline
			pspriter.AnimationTimeline = MyAnimationTimeline
			pspriteu.AnimationTimeline = MyAnimationTimeline
			psprited.AnimationTimeline = MyAnimationTimeline
			psprite.AnimationTimeline = MyAnimationTimeline
		End Method
		
		//changes positions
		Method changepos(x As Decimal, y As Decimal, movex As Integer, movey As Integer)//moves the sprite
			xpos = x//obvious
			ypos = y//obvious
			//centers sprites in cell
			//have to move them all at once
			psprite.moveto( movex + cellsize/2 - psprite.Width/2, movey+ cellsize/2 - psprite.Height/2)
			pspriteU.moveto(movex + cellsize/2 - pspriteU.Width/2, movey+ cellsize/2 - pspriteU.Height/2)
			pspriteD.moveto(movex + cellsize/2 - pspriteD.Width/2, movey+ cellsize/2 - pspriteD.Height/2)
			pspriteL.moveto(movex + cellsize/2 - pspriteL.Width/2, movey+ cellsize/2 - pspriteL.Height/2)
			pspriteR.moveto(movex + cellsize/2 - pspriteR.Width/2, movey+ cellsize/2 - pspriteR.Height/2)
		End Method
		
		Method changepos(x As Decimal, y As Decimal)//moves the sprite
			xpos = x//obvious
			ypos = y//obvious
		End Method
		
		//use to set score
		//If < 0, sets score = 0
		Method SetScore( n As Integer)
			If Not n > 0 Then
				score = 0
				Return
			End If
			score = n
		End Method
		
		//sets direction of player
		//see direction variable notes for meaning
		//if not a = {0,3}, then ignores
		Method setDirection(a As Integer)
			If a<= 3 And a >= 0 Then 
				direction = a
			End If
		End Method
		
		//used to load and scale sprites
		Method Load(pic As String)
			psprite.Hide()
			psprite.Load(pic)
			psprite.Scale(100*(cellsize-4)/This.psprite.Width,100*(cellsize-4)/This.psprite.Height)
			psprite.Show()
		End Method

		//will load keys for player movements
		Method setKeys(up As String, Right As String, down As String, Left As String)
			upKey = up
			rightKey = right
			downKey = down
			leftKey = Left
		End Method
		
		//sets health on scale 0 - 100
		//called when hit enemy or goodfood
		//h is intended health
		Method setPlayerHealth( h As Integer)
			//load health within{0,100}
			If h>100 Then
				health = 100
			Else If h<=0 Then
				health = 0
			Else 
				health = h	
			End If
			//update min and max health
			If health > maxHealth Then 
				maxHealth = health
			Else If health<MinHealth Then
				MinHealth = health
			End If
			setPlayerSpeed()
		End Method
		//pulls out total score, though why it's here I have no idea - BOSHEN?!?!?!
		Function totalScore(difficulty As Int,p As profile) As Integer
			Define i As Integer
			Define total As Integer
			For i = 1 To 5
				total += p.scores[i,difficulty]
			Next
			Return total
		End Function
		
		Method MovePlayerSimple(moveX As Integer,moveY As Integer)
			xpos = xpos + moveX
			ypos = ypos + movey
		End Method
		
		Method displayplayersimple()
			psprite.MoveTo(xpos,ypos)
			pspriteU.MoveTo(xpos,ypos)
			pspriteD.MoveTo(xpos,ypos)
			pspriteL.MoveTo(xpos,ypos)
			pspriteR.MoveTo(xpos,ypos)
		End Method
		
		Method loadplayersimple(startx As Integer,starty As Integer)
			loadsprites()
			pspriteR.FlipHorizontal()
			pspriteU.Scale(80,80)
			pspriteL.Scale(80,80)
			pspriteR.Scale(80,80)
			pspriteD.Scale(80,80)
			psprite = pspriteL
			xpos = startx
			ypos = starty
			hasbeenloaded=True
		End Method
		
	End Class
	
	//created by Kevin Meyer, 17Oct2009
	//added potato chip bag sprite instead of black box Chase 355 PM 19OCT2009
	Class Enemy
		Define xpos As Decimal//place in maze
		Define ypos As Decimal//place in maze
		Define Direction As Integer //0 = up, 1 = right, 2 = down, 3 = left
		Define psprite As Sprite//att. sprite
		Define cellsize As Integer//cellsize
		Define startX As Integer//starting xpos
		Define startY As Integer//starting ypos
		Define active As Boolean = False//iis alive
		Define isReal As Boolean = False//is real enemy in game or null if false
		Define picture As String//picture to be loaded
		Define isLoaded As Boolean = False//has it been loaded - use for errorhandling
		Define IsBurger As Boolean//are you a burger with all that implies
		Define DeadFrames As Integer = 100//frames before respawn
		Define DFrame As Integer = 0//fames you've been dead
		Define waiting As Boolean = False
		Define pauseframes As Integer = 50
		
		
		
		Method loadEnemy(x As Integer, y As Integer, pic As String, c As Integer)
			cellsize = c//inputs cell size
			picture = pic//loads pictur of enemy
			//psprite.Load(pic)
			startY = y//sets position
			startX = x
			xpos = x//sets starting position
			ypos = y
			direction = 0
			active = True//I'm active and real
			isReal = True
			dframe = 0//I haven't died yet.  
		End Method
		
		
		//same as player
		Method changepos(x As Decimal, y As Decimal, movex As Integer, movey As Integer)//moves the sprite
			xpos = x
			ypos = y
			If isloaded Then
				psprite.moveto( movex + cellsize/2 - psprite.Width/2, movey+ cellsize/2 - psprite.Height/2)
			End If
		End Method
		
		//just changes x and y - doesn't display
		Method changepos(x As Decimal, y As Decimal)//moves the sprite - not anymore
			xpos = x
			ypos = y
		End Method
		
		//wil load pic Method
		Method Load()
			//loads picture, and catches one of our annoying bugs
			If Not picture = "" Then
				psprite.Load(picture)
			End If
			
			//set to size
			If Not isBurger Then
				psprite.Scale(100*(cellsize-4)/This.psprite.Width,100*(cellsize-4)/This.psprite.Height)
			Else
				psprite.Scale(100*(3*(cellsize)-4)/This.psprite.Width,100*(3*(cellsize)-4)/This.psprite.Height)
			End If
			//loaded and active
			isLoaded = True
			active = True
		End Method
		
		//unloads sprite
		Method unload()
			//yeah, not so much
			If isloaded Then
				psprite.hide()
				psprite.Unload()
			End If
			isLoaded = False
		End Method
		
		//same as player
		Method setDirection(a As Integer)
			If a<= 3 And a >= 0 Then 
				direction = a
			End If
		End Method
		
	End Class
	
	
	//(26Oct09, Boshen) just displays a simple red bar showing how much health you have
	Class bar// use for progress/time/health
		Define width As Integer//width
		Define x As Integer//x of upper left corner
		Define y As Integer //y of upper left corner
		Define height As Integer
		Define label As String//label under healthbar
		Define icon As sprite//get sput next to bar
		Define pic As String//image for icon
		Define isloaded As Boolean = False//is pic loaded into icon - error handling
		
		
		//loads bar
		Method loadbar(xpos As Integer, ypos As Integer,w As Integer, h As Integer, l As String, picture As String)
			x=xpos
			y=ypos
			height = h
			label = l
			width = w
			pic = picture
		End Method
		
		Method loadbar(xpos As Integer, ypos As Integer,w As Integer, h As Integer)
			x=xpos
			y=ypos
			height = h			
			width = w
		End Method
		
		//converts to percentage for graphing
		Function converttodec(number As Decimal, max As Decimal) As Decimal// used For coverting health to decimal
			Return number/max
		End Function
		
		//loads icon
		Method Load()
			icon.Load(pic)
			icon.scale(100*30/icon.Width,100*30/icon.Height)
			icon.MoveTo(x-40,y)//loads the sprites
			isloaded = True
		End Method
		
		//unloads icon
		Method unload()
			icon.hide()//hides the sprite
			icon.Unload()//unloads picture from memory
			isLoaded = False//picture is now notloaded
		End Method
		
		//draws bar
		Method draw(hp As Decimal)
			//draw rectangle
			pen(False)
			moveto(x+1,y+1)
			If hp> 1 Then
				rectangle((width)-2,height-2,True)
			Else
				rectangle((hp*width)-2,height-2,True)
			End If
			color(black)
			pen(False)
			moveto(x,y)
			pen(True)
			moveto(x+width,y)
			moveto(x+width,y+height)
			moveto(x,y+height)
			moveto(x,y)
			pen(False)
			
			//print label
			moveto(x, y + 25)
			print(label)
		End Method
		Define blinkFrames As Integer = 7//number of frames to blink for
		Define blinkNumber As Integer = 0//current frame
		
		Method Blink(color As Integer)//will blink the  bar on or off every blinkFrames Frames
			//if too big reset
			While blinkNumber >= 2*blinkFrames
				blinkNumber -= 2*blinkFrames
			End While
			//set color acc. to blinkframes
			If blinkNumber < blinkFrames Then
				color(color)
			Else 
				color(white)
			End If
			//toggle blinknumber
			blinkNumber+=1
		End Method
		
	End Class
	
	
	//use for buttons
	Class button
		Define buttonpic As Sprite//sprite
		Define active As Boolean = True//is button usable
		
		//loads button
		Method loadbutton(x As Integer, y As Integer, pic As String)
			buttonpic.Load(pic)
			buttonpic.MoveTo(x,y)
			buttonpic.Show()
		End Method
		
		Method loadbutton(x As Integer, y As Integer)
			buttonpic.hide()
			buttonpic.MoveTo(x,y)
			buttonpic.Show()
		End Method
		
		//has the button been clicked
		Function isclicked() As Boolean
			If leftpressed=True And buttonpic.ContainsPoint(mousex,mousey) Then
				Return True
			End If
			Return False
		End Function
	End Class
	
	//shows a fullscreen sprite that has nutritional info on the screen
	Class infoscreen
		Define info As sprite
		Method load(s As String)
			
			Define tempScreenwidth As Integer = screenwidth()
			Define tempScreenheight As Integer = screenheight()
			build(s)
			//while no input, loop
			While getKey() = "" And Not mouse.Event = "ButtonDown"
				If Not (screenwidth() = tempscreenwidth And screenheight() = tempscreenheight) Then
					build()
					tempScreenwidth = screenwidth()
					tempScreenheight = screenheight()
				End If
				delay(1)
			End While
			//leave
			info.unload()
			clearmouseevents()
			clearkeyboardevents()
		End Method
		
		//doesn't x keys - for playtutorial
		Function loadnaught(s As String) As Boolean
			Define tempScreenwidth As Integer = screenwidth()
			Define tempScreenheight As Integer = screenheight()
			Define ret As Boolean = False
			//build it
			build(s)
			//while no input, loop
			While getKey() = "" And Not mouse.Event = "ButtonDown"
				If Not (screenwidth() = tempscreenwidth And screenheight() = tempscreenheight) Then
					build()
					tempScreenwidth = screenwidth()
					tempScreenheight = screenheight()
				End If
				delay(1)
			End While
			If iskeydown(escape) Then
				ret = True
			End If
			//leave
			info.unload()
			Return ret
		End Function
		
		
		Method build(s As String)
			clearMouseEvents()
			clearKeyBoardEvents()
			info.Load(s)
			info.scale(100.0*(min(screenheight(),screenwidth())/convertToDecimal(info.Width)),100.0*(min(screenwidth(),screenheight())/convertToDecimal(info.Height)))
			If info.Width > screenwidth()  And screenwidth() < screenheight() Then
				info.scale(100.0 * screenwidth()/info.width,100.0 * screenwidth()/info.width)
			Else If info.Height > screenheight() Then
				info.scale(100.0 * screenheight()/info.height,100.0 * screenheight()/info.height)
			End If
			info.MoveTo(max((screenwidth() - info.width)/2,0),max((screenheight() - info.height)/2, 0))
					
			info.MoveTo((screenwidth() - info.width)/2,(screenheight() - info.height)/2)
			info.Show()
		End Method
		
		Method build()
			clearMouseEvents()
			clearKeyBoardEvents()
			info.scale(100*(min(screenheight(),screenwidth())/convertToDecimal(info.Width)),100*(screenheight()/convertToDecimal(info.Height)))
			info.MoveTo((screenwidth() - info.width)/2,(screenheight() - info.height)/2)
			info.Show()
		End Method
	End Class
	
	//highscore, just name and string
	Class HighScore
		Define name As String
		Define score As Integer
	End Class
	
	//profile
	Class profile
		Define name As String = "whoCares"
		Define savefilename As String = "saves.txt"
		Define line As String
		Define file As savefile
		Define hasbeaten As Boolean[5,5]
		Define profilenum As Integer
		Define totalScores As Integer[5]
		Define scores As Integer[5,5]//first is level, then difficulty		
		Define arcadescore As Integer
		
		//will update the totalscore array
		Method updatetotalscores()
			Define i As Integer
			Define i2 As Integer
			For i2 = 1 To arraylength(scores, 1)
				Define total As Integer
				For i  = 1 To arraylength(scores, 2)
					total += scores[i,i2]
				Next
				totalscores[i2] = total
			Next
		End Method
		
	End Class
	
	Class savefile
		Define file As TextInputFile
		Define writefile As TextoutputFile
		Define savefilename As String = "saves.txt"
		Define lastlinenum As Integer
		Define currentmenu As String
		Define savelines As StringList
		Define highscorename As String = "highscore.txt"
		Define highscores As HighScore[7,5]
		Method loadsaves()
			loadhighscores()
			If Not fileexists(savefilename) Then
				writefile = createtextfile(savefilename)
				writefile.Close()
			End If
			savelines.clear()
			file = opentextfile(savefilename)
			While Not file.EndOfFile
				savelines.Add(file.ReadLine())
			End While
			file.Close()
		End Method
		
		Method selectmenu(p As profile)
			Define input As Integer
			console.Clear()
			displaysaves(True,True,True,False,p, False)
			input = console.ReadInt("Enter option number: ")
			If input < lastlinenum And input > 0 Then
				loadprofile(input,p)
			Else If input = lastlinenum Then
				currentmenu = "create"
			Else If input = lastlinenum + 1 Then
				currentmenu = "delete"
			Else If input = lastlinenum + 2 Then
				currentmenu = "main"
			Else 
				alert("Invalid input","Input error")
			End If
		End Method
		
		Method displaysaves(c As Boolean, d As Boolean, m As Boolean, b As Boolean,p As profile, creating As Boolean)
			Define i As Integer
			Define input As Integer
			console.Clear()
			If creating Then
				console.ConsoleWriteline("Enter Profile name:")
			Else
				console.ConsoleWriteline("Enter option number:")
			End If
			For i=1 To savelines.Count
				console.ConsoleWriteline(i+". " +getname(savelines.Item(i)))
			Next	
			lastlinenum=i
			If c = True Then
				console.WriteLine(i+". " + "Create New Profile")
				i=i+1
			End If
			If d = True Then
				console.WriteLine(i+". " + " Delete Profile")
				i=i+1
			End If
			If b = True Then
				console.WriteLine(i+". " + " Go Back")
				i=i+1
			End If
			If m = True Then
				console.WriteLine(i+". " + "Main Menu")
				i=i+1
			End If
		End Method
		
		Method save(p As profile)
			Define i As Integer
			Define j As Integer
			Define s As String
			//recreates the profile save based on what you currently have accomplished
			s=p.name+ " hasbeaten "
			For i = 1 To 5
				For j = 1 To 5
					If p.hasbeaten[i,j] = True Then
						s = s + "t"
					Else
						s = s + "f"
					End If
				Next
			Next
			s = s + " "
			For i =1 To 5
				For j=1 To 5
					s = s + p.scores[i,j] + "/"
				Next
			Next
			s = s + p.arcadescore + "/"
			savelines.setitem(p.profilenum,s)
			p.updatetotalscores()
		End Method	
		
		Method save()
			savehighscores()
			writefile = createtextfile(savefilename)
			Define i As Integer
			If savelines.Count>=2 Then
				writefile.Write(savelines.Item(1))
				For i = 2 To savelines.Count
					writefile.Writeline("")
					writefile.Write(savelines.Item(i))
				Next
			Else If savelines.Count=1 Then
				writefile.Write(savelines.Item(1))
			End If
			writefile.Close()
		End Method
		
		Method loadhighscores()
			Define diff As Integer
			Define line As String
			Define level As Integer
			If Not fileexists(highscorename) Then
				writefile = createtextfile(highscorename)
				For diff = 1 To 5
					For level = 1 To 6
						If diff = 1 And level = 1 Then
							writefile.Write("None " + diff + " " + level + " " +"0/")
						Else
							writefile.Writeline("")
							writefile.Write("None " + diff + " " + level + " " +"0/")
						End If
					Next
				Next
				writefile.Writeline("")
				writefile.Write("None " + 1 + " " + 7 + " " +"0/")
				writefile.Close()
			End If
			file = opentextfile(highscorename)
			While Not file.EndOfFile
				For diff = 1 To 5
					For level = 1 To 6
						line = file.ReadLine()
						highscores[level,diff].name = getname(line)
						highscores[level,diff].score = getscore(line)
					Next
				Next
				line = file.ReadLine()
				highscores[7,1].name = getname(line)
				highscores[7,1].score = getscore(line)
			End While
			file.Close()
		End Method
		
		Method savehighscores()
			writefile = createtextfile(highscorename)
			Define level As Integer
			Define diff As Integer
			For diff = 1 To 5
				For level = 1 To 6
					If diff = 1 And level = 1 Then
						writefile.write(highscores[level,diff].name + " " + diff + " " + level + " " + highscores[level,diff].score + "/")
					Else
						writefile.WriteLine("")
						writefile.write(highscores[level,diff].name + " " + diff + " " + level + " " + highscores[level,diff].score + "/")
					End If
				Next
			Next
			writefile.WriteLine("")
			writefile.write(highscores[7,1].name + " " + 1 + " " + 7 + " " + highscores[7,1].score + "/")
			writefile.Close()
		End Method
		
		Function getscore(line As String) As Integer
			Define index As Integer
			Define s As String
			index = length(getname(line)) + 6
			While Not substring(line,index,1) = "/"
				s = s + substring(line,index,1)
				index = index + 1
			End While
			Return converttointeger(s)
		End Function
		
		Method loadprofile(num As Integer, p As profile)
			Define i As Integer
			Define j As Integer
			Define index As Integer
			Define s As String
			p.name = getname(savelines.Item(num))
			p.profilenum = num
			i = strings.indexof(savelines.Item(num),"hasbeaten",1)
			index = i+10
			For i =1 To 5
				For j=1 To 5
					If substring(savelines.Item(num),index,1) = "f" Then
						p.hasbeaten[i,j]=False
					Else
						p.hasbeaten[i,j]=True
					End If
					index+=1
				Next
			Next
			index+=1
			For i = 1 To 5
				For j = 1 To 5
					While Not substring(savelines.Item(num),index,1) = "/"
						s = s + substring(savelines.Item(num),index,1)
						index+=1
					End While
					index+=1
					p.scores[i,j] = converttointeger(s)
					s = ""
				Next
			Next
			While Not substring(savelines.Item(num),index,1) = "/"
				s = s + substring(savelines.Item(num),index,1)
				index+=1
			End While
			p.arcadescore = converttointeger(s)
			p.updatetotalscores()
			currentmenu = "done"
		End Method
		
		Method createprofile (p As profile)
			console.Clear()
			Define input As String
			Define valid As Boolean = False
			Define i As Integer
			displaysaves(False,False,False,True,p, True)
			While valid = False
				valid = True
				input = console.ReadString("Enter profile name:")
				If input = "" Then
					valid = False
					alert("Pleas input a name","Input error")
				End If
				For i = 1 To length(input)
					If substring(input,i,1) = " " Or substring(input,i,1) = "/" Then
						valid = False
						alert("Please do not use spaces or slashes in your name","Input error")
					End If
				Next
				For i = 1 To savelines.Count
					If input = getname(savelines.Item(i)) Then
						valid = False
						alert("Name already taken","Input error")
					End If	
				Next
			End While
			If Not equals(input,lastlinenum) Then
				savelines.Add(input + " hasbeaten " + repeat("f",25)+ " " + repeat("0/",52))
				save()
				loadsaves()
				loadprofile(savelines.Count,p)
			Else
				currentmenu = "select"
			End If
		End Method
		
		Method deletemenu(p As profile)
			Define input As Integer
			Define valid As Boolean = False
			console.Clear()
			displaysaves(False,False,False,True,p, False)
			While valid = False
				valid = True
				input = console.ReadInt("Choose a profile to delete ")
				If input > lastlinenum Then
					valid = False
					alert("Invalid Input","Input error")
				End If
			End While
			If input < lastlinenum Then
				savelines.RemoveAt(input)
				save()
				loadsaves()
			Else If input = lastlinenum Then
				currentmenu = "select"
			End If
		End Method
		
		Function getname(s As String) As String
			Define i As Integer
			Define s2 As String
			For i=1 To length(s)
				If Not substring(s,i,1) = " " Then
					s2=s2+substring(s,i,1)
				Else 
					i = 9999	
				End If
			Next
			Return s2
		End Function
		
	End Class
	
	//stores the question 
	Class question
		//Define question As String
		Define answer As Integer//which is the answer top to bottom
		Define backgroundSprite As Sprite//sprite
		Define wrongImage As String = "QuizScreenIncorrect.png"
		Define correctImage As String  =  "QuizScreenCorrect.png"
		Define image As String//image for question
		Define buttons As button[4]//button []
		
		//loads question
		Method loadquestion(qImage As String, ans As Integer)
			image = qImage
			answer = ans
		End Method
		
		//loads question
		Method loadquestion(qImage As String, ans As Integer, wrong As String)
			image = qImage
			answer = ans
			wrongImage = wrong
		End Method
		
		Method unloadquestion()
			backgroundsprite.Unload()
			Define i As Integer
			For i = 1 To arraylength(buttons)
				buttons[i].buttonpic.Unload()
			Next
		End Method
		
		//shows questions
		Method displayQuestion()
			//load and display background
			backgroundSprite.Load(image)
			backgroundSprite.Scale(100.0*min(screenwidth(), screenheight())/backgroundSprite.Width,100.0*min(screenwidth(), screenheight())/backgroundSprite.height )
			backgroundSprite.MoveTo((screenwidth() - backgroundsprite.Width)/2,(screenheight() - backgroundsprite.height)/2)
			BackgroundSprite.Show()
			Define i As Integer
			For i = 1 To arraylength(buttons)
				buttons[i].loadbutton( backgroundsprite.X + 50 * backgroundsprite.width/600.0, backgroundsprite.y + (210 + 55*(i-1))* backgroundsprite.height/600.0,"QuizButton.png")
			Next
		End Method
		
		//show question fedback, dependent on right or wrong
		Method displayfeedback(correct As Boolean)
			unloadquestion()
			If correct Then
				backgroundSprite.Load("QuizScreenCorrect.png")
			Else 
				backgroundSprite.Load(wrongImage)
			End If
			backgroundSprite.Scale(100.0*min(screenwidth(), screenheight())/backgroundSprite.Width,100.0*min(screenwidth(), screenheight())/backgroundSprite.height )
			backgroundSprite.MoveTo((screenwidth() - backgroundsprite.Width)/2,(screenheight() - backgroundsprite.height)/2)
			BackgroundSprite.Show()
		End Method
		
		//checks answer against input-be careful
		Function checkanswer(a As Integer) As Boolean
			Return a = answer
		End Function
	End Class
	
	Class arcadeobj
		Define angle As Decimal
		Define speed As Integer = 7
		Define goodfoodname As String[5] = {"carrot.png","fish.png","green apple.png","milk.png","strawberry.png"}
		Define badfoodname As String[5] = {"soda.png","potato bag.png","fries.png","donut.png","burger.png"}
		Define objsprite As sprite
		Define type As Integer
		Define xpos As Integer
		Define ypos As Integer
		Define hittingwall As String
		Define minxbound As Integer
		Define minybound As Integer
		Define maxxbound As Integer
		Define maxybound As Integer
		Define counter As Integer
		Define alive As Boolean = True
		Method loadsprite()
			If type = 1 Then
				objsprite.Load(goodfoodname[random(1,arraylength(goodfoodname))])
			Else
				objsprite.Load(badfoodname[random(1,arraylength(badfoodname))])
			End If
			objsprite.hide()
			objsprite.Scale(30,30)
			angle = random(0,360)
		End Method	
		Method MoveobjectSimple(moveX As Integer,moveY As Integer, setpos As Boolean)
			If setpos = True Then
				xpos = movex
				ypos = movey
				movex=0
				movey=0
			End If
			If xpos+movex >= maxxbound Then
				xpos = maxxbound
				movex = 0
				angle = 180-angle
			End If
			If xpos+movex <= minxbound Then
				xpos = minxbound
				movex = 0
				angle = 180-angle
			End If
			If ypos+movey >= maxybound Then
				ypos = maxybound
				movey = 0
				angle = -angle
			End If
			If ypos+movey <= minybound Then
				ypos = minybound
				movey = 0
				angle = -angle
			End If	
			objsprite.MoveTo(xpos+moveX,ypos+moveY)
			xpos = objsprite.X
			ypos = objsprite.y
			If alive Then
				objsprite.Show()
			Else 
				objsprite.Hide()
			End If
		End Method
		Function calcmovex() As Decimal
			anglemeasureunit = degrees
			Return cos(angle)*speed
		End Function
		Function calcmovey() As Decimal
			anglemeasureunit=degrees
			Return -1*(sin(angle)*speed)
		End Function
		Function intersect(p As Player) As Boolean
			If alive Then
				Return p.psprite.Intersects(objsprite)
			Else
				Return False
			End If	
		End Function
		Method respawn(p As player)
			If counter < 100 And Not alive Then
				counter=counter+1
			Else If Not alive Then
				loadsprite()
				If type = 2 Then
					While abs(xpos - p.xpos)<100
						xpos = random(minxbound,maxxbound)
					End While
					While abs(ypos - p.ypos)<100
						ypos = random(minybound,maxybound)
					End While
				End If
				counter = 0
				alive = True
			End If
		End Method
		Function checkstatus(p As player) As Boolean
			Define ret As Boolean = False
			If intersect(p) And alive Then
				ret = True
				alive = False
				objsprite.hide()
				If type = 1 Then
					p.health = min(p.health + Global.currentdifficulty().goodfoodbonus,100)
					p.goodFoodsHit +=1
				Else
					p.health = max(p.health - Global.currentdifficulty().enemyhurt,0)
					p.enemiesHit+=1
				End If	
			End If
			If p.health <= 0 Then
			//	p.loadplayersimple(screenwidth()/2,(screenheight()-Global.ygap)/2)
			//	p.moveplayersimple(0,0)
			//	Global.displayplayer(p)
				//p.health = 50
				p.lives = p.lives - 1
			End If
			respawn(p)
			Return ret
		End Function
		Method load(objtype As Int, sidegap As Integer)
			type = objtype
			loadsprite()
			minxbound = sidegap
			minybound = Global.ygap
			maxxbound = screenwidth()-sidegap-objsprite.Width
			maxybound = screenheight()-sidegap-objsprite.height
			xpos = random(minxbound,maxxbound)
			ypos = random(minybound,maxybound)
			moveobjectsimple(xpos,ypos,True)
		End Method
		
		
		
	End Class
	
	
	//variables
	
	Define isCaught As Boolean = False//are you dead
	Define haswon As Boolean = False//have you won
	Define paused As Boolean = False//is the game paused
	
	
	Define yGap As Integer = 100//size of top for menus
	
	
	//size of cells - can change
	Define cellSize As Integer = 50
	
	
	Define character As player//single player player
	Define player1 As Player//multiplayer players
	Define player2 As Player
	Define Players As Player[2] = {player1,player2}
	//Players[1] = character
	
	
	Define EnemySpeed As Decimal = .08//speed of enemies /cells per frame/
	
	
	//Define levels here
	Define Level1 As Level
	Define Level2 As Level
	Define Level3 As Level
	Define Level4 As Level
	Define Level5 As Level
	Define Multi1 As Level
	Define Multi2 As Level
	Define Multi3 As Level
	Define Multi4 As Level
	Define Multi5 As Level
	//etc. 
	//infoscreens for each level
	Define lvlinfo As infoscreen
	
	//Define linecolor As Integer=18
	//Define cellcolor As Integer=129
	//Define backgroundcolor As Integer
	
	
	Define diff As Integer//determines difficulty, 1 to 5 ,Chesney to god
	Define hard As Difficulty
	Define medium As Difficulty
	Define easy As Difficulty
	Define Chesney As Difficulty
	//we built Chesney so you(the graders) could test like crazy, and not have to worry about death or the timer
	//seriously, that's why it's caled Chesney
	//Also, level3 (and 1) is a pain. Don't say I didn't warn you
	Define god As Difficulty
	Define arcadediff As Difficulty
	
	Define cLevel As Integer//use for currentlevel()
	
	
	//sound 
	Define background As Sound//background musics for menus
	Define background2 As Sound//
	
	Define healthbar As bar//health bar
	Define progress As bar//progress in level
	Define timeBar As bar//time remaining
	
	Define healthbar1 As bar//multi for you know what
	Define healthbar2 As bar
	Define timebar2 As bar
	
	Define totalGameTime As Decimal//time in level
	Define GameTimer As Timer//timer for the game
	
	Define currentmenu As String//what menu
	
	Define lifeSprite As Sprite//sprite for lives
	
	//use for level5 unlock cheatcode
	Define unlocked As Boolean[5]={False,False,False,False,False}
	
	Define profile As profile//generic profile
	Define savefile As savefile//generic savefile
	
	
	Define mpressed As Boolean = False//is mpressed(for mutage)
	
	Define cheats As Boolean = False//are cheats on
	Define godEnabled As Boolean = False//is god on
	
	
	Define credMusic As String = "track1.wav"
	Define credString As String
	
	Define loadsprite As sprite
	
	
	//main method
	//created 14Oct2009 by Kevin Meyer
	Method Main()
		
		
		//currentlevel() = level1
		SetFont ( "Arial", 10, False, False, False )
		initGame()//loads game
		
		mainmenu(background,bgmusic)//calls menu
		While True
			While Not currentmenu = "q"//menu loading
				loadcurrentmenu()
			End While
			Define q As Boolean
			If currentlevel().type = 2 Then//starts level
				initLevelMulti()
				q = runGameMulti()
				If q Then 
					currentmenu = "levelselectMulti"
					leavecurrentlevel()
				Else
					delay(500)//quick transition is scary
					//seriously, erase the above line and see
					playAgainMulti()
				End If
			Else If currentlevel().type = 1 Then
				initLevel()
				//runGame()//runs game
			
				q = runGame()
				If q Then
					currentmenu = "levelselect"
					savefile.save(profile)
					savefile.save()
					leavecurrentlevel()
				Else
					delay(500)//quick transition is scary
					//seriously, erase the above line and see
					playAgain()
				End If
			Else
				//physics minigame here
				//addtolevelinfo()
				//initlevelfreestyle()
				//rungamefreestyle()
				InitMinigame()
			End If//progress screen
		End While
		stop()
	End Method
	
	Define question1 As question 
	Define question2 As question
	Define question3 As question 
	Define question4 As question 
	Define question5 As question
	Define question6 As question  
	Define question7 As question 
	Define question8 As question
	Define question9 As question 
	Define question10 As question 
	Define question11 As question
	Define question12 As question  
	Define question13 As question 
	Define question14 As question
	Define question15 As question 
	Define question16 As question 
	Define question17 As question
	Define question18 As question  
	Define question19 As question  
	Define question20 As question 
	Define question21 As question
	Define question22 As question 
	Define question23 As question 
	Define question24 As question
	Define question25 As question
	
	//general initialization
	//used to load and build entire game before entering
	//occasionally crashes - why???
	Method initGame()
		setScreenSize(600, 600)
		loadsprite.Load("Loading.png")
		loadsprite.Scale(100.0*screenwidth()/loadsprite.Width,100.0*screenheight()/loadsprite.height)
		loadsprite.Show()
		delay(1)
		mini.type = 3
		hidetoolbar()
		muted = False
		//builds questions - CHASE?!
		question1.loadquestion("quizscreen11.png",3, "quizscreenincorrect11.png")
		question2.loadquestion("quizscreen12.png",3, "quizscreenincorrect12.png")
		question3.loadquestion("quizscreen13.png",2, "quizscreenincorrect13.png")
		question4.loadquestion("quizscreen14.png",3, "quizscreenincorrect14.png")
		question5.loadquestion("quizscreen15.png",1, "quizscreenincorrect15.png")
		Define level1Questions As question[] = {question1, question2, question3, question4, question5}
		question6.loadquestion("quizscreen21.png",1, "quizscreenincorrect21.png")
		question7.loadquestion("quizscreen22.png",4, "quizscreenincorrect22.png")
		question8.loadquestion("quizscreen23.png",4, "quizscreenincorrect23.png")
		question9.loadquestion("quizscreen24.png",1, "quizscreenincorrect24.png")
		question10.loadquestion("quizscreen25.png",2, "quizscreenincorrect25.png")
		Define level2Questions As question[] = {question6, question7, question8, question9, question10}
		question11.loadquestion("quizscreen31.png",2, "quizscreenincorrect31.png")
		question12.loadquestion("quizscreen32.png",1, "quizscreenincorrect32.png")
		question13.loadquestion("quizscreen33.png",4, "quizscreenincorrect33.png")
		question14.loadquestion("quizscreen34.png",2, "quizscreenincorrect34.png")
		question15.loadquestion("quizscreen35.png",3, "quizscreenincorrect35.png")
		Define level3Questions As question[] = {question11, question12, question13, question14, question15}
		question16.loadquestion("quizscreen41.png",3, "quizscreenincorrect41.png")
		question17.loadquestion("quizscreen42.png",1, "quizscreenincorrect42.png")
		question18.loadquestion("quizscreen43.png",4, "quizscreenincorrect43.png")
		question19.loadquestion("quizscreen44.png",3, "quizscreenincorrect44.png")
		question20.loadquestion("quizscreen45.png",3, "quizscreenincorrect45.png")
		Define level4Questions As question[] = {question16, question17, question18, question19, question20}
		question21.loadquestion("quizscreen51.png",3, "quizscreenincorrect51.png")
		question22.loadquestion("quizscreen52.png",3, "quizscreenincorrect52.png")
		question23.loadquestion("quizscreen53.png",1, "quizscreenincorrect53.png")
		question24.loadquestion("quizscreen54.png",2, "quizscreenincorrect54.png")
		question25.loadquestion("quizscreen55.png",4, "quizscreenincorrect55.png")
		Define level5Questions As question[] = {question21, question22, question23, question24, question25}
		//size screen to size of maze
		//CellSize = getPlayerSize() * someNumber
		//reset screensize
		
		SetConsoleFont( "Arial", 14)
		SetConsoleFontStyle(True, False, False)
		SetConsoleBackgroundColor(steelblue)
		SetConsoleFontColor( White )
		SetConsoleTextAlignment( "Center" )
		//load sounds
		background.LoadFile("level2.wav")
		background2.LoadFile("level.wav")
		//load difficulties
		hard.loadDifficulty(40, 5, 3.0)
		medium.loadDifficulty(30, 10, 2.0)
		easy.loadDifficulty(20, 15, 1.5)
		Chesney.loadDifficulty(10, 20, 1.0)
		god.loadDifficulty(100, 0 , 4.0)
		arcadediff.loadDifficulty(20,15,2.0)
		//load bars
		healthbar.loadbar(425 *screenwidth()/600,0,150*screenwidth()/600,25,"Hypertension","Carrot.png")
		progress.loadbar(225*screenwidth()/600,0,150*screenwidth()/600,25,"Healthy Foods Found","Carrot")
		timeBar.loadbar(25*screenwidth()/600,0,150*screenwidth()/600,25, "Time Left","Carrot.png")
		healthbar1.loadbar(25, 0 , 150*screenwidth()/600, 25, "Player 1 Health","Carrot.png")
		healthbar2.loadbar(425, 0 , 150*screenwidth()/600, 25, "Player 2 Health","Carrot.png")
		timebar2.loadbar(225, 0 , 150*screenwidth()/600, 25, "TimeLeft","Carrot.png")
		//set up keys
		character.setkeys(up,right,down,left)
		player1.setKeys("w","d","s","a")
		player2.setKeys(up,right,down,left)
		
		//load the savefile
		savefile.loadsaves()
		
		
		//update the multiplayer levels to be multiplayer
		//comment out the rows and columns for hilarity
		multi1.type = 2
		multi1.columns = 10
		multi1.rows= 10
		
		multi2.type = 2
		multi2.columns = 10
		multi2.rows= 10
		
		multi3.type = 2
		multi3.columns = 10
		multi3.rows= 10
		
		multi4.type = 2
		multi4.columns = 10
		multi4.rows= 10
		
		multi5.type = 2
		multi5.columns = 10
		multi5.rows= 10
		
		//loads the level - look, it works*10
		setlevel(1)
		Define removeLeft As Cell[rows*columns] = {getCell(8,1),getcell(10,13),getcell(12,14),getCell(5,7),getcell(5,15),getCell(10,1),getcell(3,14),getCell(5,6),getCell(2,4),getcell(1,13),getcell(14,14),getcell(14,15),getcell(1,14),getCell(8,5),getCell(7,2),getcell(12,4),getcell(12,5),getcell(6,14),getcell(5,14),getcell(6,13),getCell(2,1),getcell(11,3),getCell(3,2),getcell(14,11),getcell(14,10),getcell(15,12),getcell(14,12),getCell(6,2),getcell(11,1),getcell(12,1),getCell(6,9),getcell(13,7),getcell(14,8),getcell(15,2),getcell(14,2),getcell(15,3),getCell(8,3),getCell(10,3),getCell(7,8),getCell(10,8),getcell(10,11),getcell(11,11),getcell(12,11),getCell(9,8),getcell(15,9),getcell(4,10),getcell(14,9),getcell(13,9),getCell(9,3),getCell(4,2),getCell(3,1),getCell(5,1),getCell(4,1),getCell(2,7),getCell(10,6),getCell(1,6),getCell(4,8),getCell(6,5),getCell(10,9),getCell(7,6),getCell(8,7),getCell(9,5)}
		//will remove the upper wall of these positions
		Define removeUp As Cell[rows*columns] = {getCell(7,3),getcell(10,15),getcell(12,12),getcell(9,15),getCell(1,9),getcell(2,15),getCell(1,10),getcell(15,12),getcell(15,11),getCell(4,9),getCell(13,5),getcell(14,13),getcell(14,14),getcell(12,15),getcell(1,15),getcell(7,14),getcell(7,13),getcell(13,6),getcell(12,5),getcell(7,12),getcell(5,13),getcell(4,14),getcell(4,13),getcell(4,12),getcell(4,11),getcell(11,5),getcell(13,4),getcell(14,11),getcell(13,11),getCell(5,7),getCell(3,8),getCell(3,7),getcell(15,2),getcell(13,2),getcell(13,3),getcell(12,8),getcell(12,7),getcell(13,7),getcell(14,8),getCell(1,2), getCell(2,6),getCell(2,5),getCell(5,4),getCell(9,6),getCell(7,10),getCell(8,9),getCell(5,6),getCell(9,8),getCell(1,10),getCell(6,1),getCell(6,4),getCell(6,3),getCell(6,5),getCell(5,3),getCell(6,6),getCell(6,7),getCell(6,8),getCell(9,10),getCell(6,10),getCell(6,9),getCell(5,2),getCEll(4,5), getCell(8,7), getCell(9,7)}
		//remove Right walls of these cells
		Define removeRight As Cell[rows*columns] = {getCell(8,2),getcell(10,13),getcell(10,12),getcell(12,13),getcell(12,12),getcell(6,11),getcell(7,11),getcell(8,11),getcell(3,14),getcell(4,14),getcell(3,15),getCell(10,6),getcell(14,15),getcell(14,14),getcell(12,14),getcell(3,14),getcell(7,15),getcell(6,14),getCell(11,6),getCell(13,6),getcell(5,12),getCell(14,6),getCell(15,6),getCell(5,7),getcell(11,3),getcell(12,3),getcell(4,11),getcell(5,11),getCell(1,10),getcell(13,4),getcell(11,2),getcell(10,7),getcell(11,8),getcell(10,8),getcell(12,1),getcell(15,1),getcell(14,4),getcell(14,5),getcell(15,5),getcell(15,4),getCell(2,9),getcell(15,8),getcell(15,10),getCell(4,9),getCell(2,10),getcell(10,10),getCell(2,8),getCell(1,8),getCell(3,7),getCell(8,1),getCell(7,10),getCell(9,5),getCell(7,8),getCell(8,4),getCell(8,9),getCell(3,6),getCell(2,6),getCell(1,6),getCell(1,3),getCell(2,3),getCell(3,3),getCell(4,3),getcell(1,1)}
		//remove Down walls of these cells
		Define removeDown As Cell[rows*columns] =  {getCell(1,1),getcell(11,15),getcell(11,13),getcell(11,14),getCell(9,11),getcell(2,10),getcell(2,11),getcell(2,12),getcell(2,13),getcell(1,11),getcell(1,12),getcell(14,15),getcell(1,15),getcell(12,15),getcell(2,15),getCell(6,10),getcell(3,11),getcell(3,12),getcell(8,12),getcell(8,13),getcell(8,14),getCell(6,12),getCell(6,14),getCell(6,15),getCell(9,12),getCell(9,13),getCell(9,14),getCell(9,15),getCell(10,3),getCell(3,3),getCell(4,9),getCell(3,4),getCell(3,5),getCell(7,5),getcell(15,6),getcell(15,7),getcell(15,8),getcell(15,9),getCell(7,4),getCell(5,4),getCell(1,3),getCell(10,4),getCell(10,1),getCell(6,1),getCell(7,1),getcell(11,9),getcell(12,9),getcell(12,10),getcell(12,8),getCell(7,3),getCell(9,10),getCell(10,8),getCell(10,2), getCell(1,2)}
		//locations that aren't actually part of the maze, isolated by walls etc.  
		Define InvalidLocations As Cell[rows*columns] = {getcell(3,15),getcell(4,15),getcell(5,15),getcell(5,12),getcell(6,12),getcell(1,11),getcell(1,12),getcell(1,13),getcell(5,13),getcell(6,13),getcell(7,15),getcell(3,11),getcell(3,12),getcell(3,13),getcell(8,12),getcell(8,13),getcell(8,14),getcell(8,15),getcell(11,2),getcell(11,7),getcell(11,4),getcell(11,5),getcell(11,9),getcell(11,10),getcell(11,12),getcell(12,2),getcell(12,4),getcell(12,5),getcell(12,13),getcell(13,8),getcell(13,10),getcell(13,11),getcell(13,13),getcell(13,15),getcell(14,1),getcell(14,3),getcell(14,5),getcell(14,7),getcell(14,8),getcell(14,10),getcell(14,11),getcell(14,15),getcell(15,3),getcell(15,5),getcell(15,13),getcell(15,13),getcell(15,15),getcell(10,12),getcell(10,14),getcell(10,15),getCell(2,2), getCell(3,2),getCell(4,2), getCell(4,4), getCell(4,5), getCell(1,5), getCell(8,2), getCell(9,2), getCell(8,4), getCell(9,4), getCell(1,7), getCell(2,7), getCell(2,9), getCell(3,9), getCell(7,7), getCell(8,7), getCell(8,6), getCell(5,8), getCell(5,10), getCell(10,7), getCell(10,10), getCell(7,9), getCell(7,10), getCell(8,10)} 
		currentlevel().loadLevelPt1(removeLeft,removeUp, removeRight, removeDown, "level6.wav", 45, "Hypertension", InvalidLocations, level1questions,77,52,white)
		createMaze()//will build the maze
		//places for enemies to spawn
		Define SpawnLocations As Cell[10] = {getCell(3,8) ,getCell(5,3)  ,getCell(2,6) ,getCell(9,1), getCell(6,9),getcell(14,14),getcell(9,13),getcell(10,3),getcell(1,6),getcell(9,1)}
		//locations of good foods
		Define goodFoodLocations As Cell[20] = {getCell(5,1),getcell(7,1),getcell(11,11),getcell(14,9),getcell(12,14),getCell(3,4) ,getCell(10,1)  ,getCell(10,9)  ,getCell(1,8)  ,getCell(5,7),getcell(13,5),getcell(1,14),getcell(14,12),getcell(1,1),getcell(9,13),getcell(4,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6)}
		//gets actual good foods
		Define goodfoods As goodFood[20] = addGoodFoods(goodFoodLocations,"Carrot.png")
		//builds enemies
		Define enemySet As Enemy[10] = createEnemySet(10,SpawnLocations, "Potato Bag.png")
		//puts them all into level
		currentlevel().LoadLevelpt2(SpawnLocations, enemySet, goodfoods)
		//repaeat the above notes for every other single level in here
		
		
		setlevel(2)
		Define removeLeft2 As Cell[rows*columns] = {getcell(2,1),getcell(3,1),getcell(4,1),getcell(5,1),getcell(6,1),getcell(7,1),getcell(8,1),getcell(9,1),getcell(10,1),getcell(11,1),getcell(12,1),getcell(13,1),getcell(14,1),getcell(15,1),getcell(3,2),getcell(4,2),getcell(5,2),getcell(6,2),getcell(7,2),getcell(8,2),getcell(9,2),getcell(10,2),getcell(11,2),getcell(12,2),getcell(13,2),getcell(14,2),getcell(4,3),getcell(5,3),getcell(6,3),getcell(7,3),getcell(8,3),getcell(9,3),getcell(10,3),getcell(11,3),getcell(12,3),getcell(13,3),getcell(5,4),getcell(6,4),getcell(7,4),getcell(8,4),getcell(9,4),getcell(10,4),getcell(11,4),getcell(12,4),getcell(6,5),getcell(7,5),getcell(8,5),getcell(9,5),getcell(10,5),getcell(11,5),getcell(7,6),getcell(7,8),getcell(7,10),getcell(8,6),getcell(9,6),getcell(10,6),getcell(8,8),getcell(6,8),getcell(11,8),getcell(5,5),getcell(5,11),getcell(4,8),getcell(3,3),getcell(3,13),getcell(2,8),getcell(1,1)}		
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp2 As Cell[rows*columns] = {getcell(8,1),getcell(1,2),getcell(1,3),getcell(1,4),getcell(1,5),getcell(1,6),getcell(1,7),getcell(1,8),getcell(1,9),getcell(1,10),getcell(1,11),getcell(1,12),getcell(1,13),getcell(1,14),getcell(1,15),getcell(2,3),getcell(2,4),getcell(2,5),getcell(2,6),getcell(2,7),getcell(2,8),getcell(2,9),getcell(2,10),getcell(2,11),getcell(2,12),getcell(2,13),getcell(2,14),getcell(13,4),getcell(13,5),getcell(13,6),getcell(13,7),getcell(13,8),getcell(13,9),getcell(13,10),getcell(13,11),getcell(13,12),getcell(13,13),getcell(12,5),getcell(12,6),getcell(12,7),getcell(12,8),getcell(12,9),getcell(12,10),getcell(12,11),getcell(12,12),getcell(5,6),getcell(5,7),getcell(5,8),getcell(5,9),getcell(5,10),getcell(5,11),getcell(10,7),getcell(10,8),getcell(10,9),getcell(10,10),getcell(6,7),getcell(6,8),getcell(6,9),getcell(6,10),getcell(8,4),getcell(1,15)}
		//remove Right walls of these cells
		Define removeRight2 As Cell[rows*columns] = {getcell(1,15),getcell(2,15),getcell(3,15),getcell(4,15),getcell(5,15),getcell(6,15),getcell(7,15),getcell(8,15),getcell(9,15),getcell(10,15),getcell(11,15),getcell(12,15),getcell(13,15),getcell(14,15),getcell(2,14),getcell(3,14),getcell(4,14),getcell(5,14),getcell(6,14),getcell(7,14),getcell(8,14),getcell(9,14),getcell(10,14),getcell(11,14),getcell(12,14),getcell(13,14),getcell(3,13),getcell(4,13),getcell(5,13),getcell(6,13),getcell(7,13),getcell(8,13),getcell(9,13),getcell(10,13),getcell(11,13),getcell(12,13),getcell(4,12),getcell(5,12),getcell(6,12),getcell(7,12),getcell(8,12),getcell(9,12),getcell(10,12),getcell(11,12),getcell(5,11),getcell(6,11),getcell(7,11),getcell(8,11),getcell(9,11),getcell(10,11),getcell(8,8),getcell(9,8),getcell(7,10),getcell(8,10),getcell(9,10),getcell(11,5),getcell(11,11),getcell(12,8),getcell(13,3),getcell(13,13),getcell(14,8),getcell(15,1),getcell(15,15)}
		//remove Down walls of these cells
		Define removeDown2 As Cell[rows*columns] =  {getcell(15,1),getcell(15,2),getcell(15,3),getcell(15,4),getcell(15,5),getcell(15,6),getcell(15,7),getcell(15,8),getcell(15,9),getcell(15,10),getcell(15,11),getcell(15,12),getcell(15,13),getcell(15,14),getcell(14,2),getcell(14,3),getcell(14,4),getcell(14,5),getcell(14,6),getcell(14,7),getcell(14,8),getcell(14,9),getcell(14,10),getcell(14,11),getcell(14,12),getcell(14,13),getcell(3,3),getcell(3,4),getcell(3,5),getcell(3,6),getcell(3,7),getcell(3,8),getcell(3,9),getcell(3,10),getcell(3,11),getcell(3,12),getcell(4,4),getcell(4,5),getcell(4,6),getcell(4,7),getcell(4,8),getcell(4,9),getcell(4,10),getcell(4,11),getcell(11,5),getcell(11,6),getcell(11,7),getcell(11,8),getcell(11,9),getcell(11,10),getcell(8,6),getcell(8,7),getcell(8,8),getcell(8,9),getcell(8,10),getcell(8,5),getcell(8,12)}
		Define InvalidLocations2 As Cell[4] = {getCell(7,7), getCell(7,9),getCell(9,7),getCell(9,9)}
		currentlevel().loadLevelPt1(removeLeft2,removeUp2, removeRight2, removeDown2, "level4.wav", 45, "Obesity", InvalidLocations2, Level2Questions,goldenrod,gold,white)
		
		createMaze()
		Define SpawnLocations2 As Cell[10] = {getCell(3,8) ,getCell(5,3)  ,getCell(2,6) ,getCell(9,1), getCell(6,9),getcell(14,14),getcell(9,13),getcell(10,3),getcell(1,6),getcell(9,1)}
		Define goodFoodLocations2 As Cell[20] = {getCell(5,1),getcell(7,1),getcell(11,11),getcell(14,9),getcell(12,14),getCell(3,4) ,getCell(10,1)  ,getCell(10,9)  ,getCell(1,8)  ,getCell(5,7),getcell(13,5),getcell(1,14),getcell(14,12),getcell(1,1),getcell(9,13),getcell(4,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6)}
		Define goodfoods2 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations2,"Strawberry.png")
		Define enemySet2 As Enemy[10] = createEnemySet(10,SpawnLocations, "Donut.png")
		currentlevel().LoadLevelpt2(SpawnLocations2, enemySet2, goodfoods2)
				
		setlevel(3)
		Define removeLeft3 As Cell[rows*columns] = {getcell(3,11),getcell(4,11),getcell(3,8),getcell(2,7),getcell(1,11),getcell(4,13),getcell(1,12),getcell(3,5),getcell(2,5),getcell(1,13),getcell(15,12),getcell(5,5),getcell(6,6),getcell(5,6),getcell(3,1),getcell(5,2),getcell(4,2),getcell(4,4),getcell(5,11),getcell(5,7),getcell(6,7),getcell(7,7),getcell(6,8),getcell(6,2),getcell(8,13),getcell(6,13),getcell(7,12),getcell(7,13),getcell(7,14),getcell(7,15),getcell(7,2),getcell(8,1),getcell(9,1),getcell(10,1),getcell(13,14),getcell(14,2),getcell(11,14),getcell(13,13),getcell(7,11),getcell(8,11),getcell(9,11),getcell(15,1),getcell(13,9),getcell(15,2),getcell(14,5),getcell(15,4),getcell(12,7),getcell(14,7),getcell(13,7),getcell(10,12),getcell(11,12),getcell(12,12),getcell(11,11),getcell(9,8),getcell(1,1),getcell(8,8),getcell(9,4),getcell(8,10),getcell(10,3),getcell(11,3),getcell(8,3),getcell(9,2)}		
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp3 As Cell[rows*columns] = {getcell(2,12),getcell(2,11),getcell(2,10),getcell(1,11),getcell(4,13),getcell(2,14),getcell(2,13),getcell(1,15),getcell(15,14),getcell(15,15),getcell(3,2),getcell(4,11),getcell(4,10),getcell(4,9),getcell(4,8),getcell(5,13),getcell(5,12),getcell(9,15),getcell(9,14),getcell(7,2),getcell(14,10),getcell(14,11),getcell(14,12),getcell(14,13),getcell(14,14),getcell(14,1),getcell(6,10),getcell(6,11),getcell(11,2),getcell(11,1),getcell(13,2),getcell(14,6),getcell(14,7),getcell(11,11),getcell(1,1),getcell(2,3),getcell(7,8),getcell(7,7),getcell(7,6),getcell(8,7),getcell(8,6),getcell(9,5),getcell(9,6),getcell(9,7),getcell(9,8),getcell(11,4),getcell(11,5),getcell(11,6),getcell(11,7),getcell(11,8),getcell(11,9),getcell(9,4),getcell(10,1),getcell(10,2),getcell(10,3),getcell(10,15)}
		//remove Right walls of these cells
		Define removeRight3 As Cell[rows*columns] = {getcell(1,9),getcell(2,9),getcell(3,9),getcell(2,7),getcell(15,10),getcell(3,12),getcell(1,12),getcell(3,7),getcell(2,15),getcell(3,15),getcell(2,14),getcell(3,14),getcell(4,14),getcell(1,14),getcell(5,5),getcell(5,11),getcell(7,12),getcell(9,13),getcell(6,4),getcell(13,14),getcell(6,9),getcell(11,14),getcell(14,9),getcell(15,9),getcell(13,3),getcell(14,3),getcell(15,3),getcell(13,9),getcell(12,8),getcell(13,8),getcell(14,8),getcell(10,10),getcell(1,1),getcell(2,3),getcell(7,4),getcell(9,9),getcell(10,9),getcell(11,9),getcell(12,6),getcell(11,3),getcell(12,3)}
		//remove Down walls of these cells
		Define removeDown3 As Cell[rows*columns] =  {getcell(15,10),getcell(3,12),getcell(3,5),getcell(3,4),getcell(3,6),getcell(5,4),getcell(4,5),getcell(5,5),getcell(6,5),getcell(4,15),getcell(5,3),getcell(4,2),getcell(4,3),getcell(5,8),getcell(5,9),getcell(5,13),getcell(5,14),getcell(5,15),getcell(5,1),getcell(6,14),getcell(7,14),getcell(8,13),getcell(8,14),getcell(8,15),getcell(6,2),getcell(6,3),getcell(6,15),getcell(14,14),getcell(11,12),getcell(13,15),getcell(11,13),getcell(13,12),getcell(12,14),getcell(12,15),getcell(12,1),getcell(12,2),getcell(13,10),getcell(13,11),getcell(13,11),getcell(1,3),getcell(1,4),getcell(1,5),getcell(1,6),getcell(1,7),getcell(1,8),getcell(1,2),getcell(15,4),getcell(15,5),getcell(15,6),getcell(15,7),getcell(12,9),getcell(12,10),getcell(12,11),getcell(13,3),getcell(13,4),getcell(10,10),getcell(9,8),getcell(1,1),getcell(2,3),getcell(8,9),getcell(7,4),getcell(8,2),getcell(9,9),getcell(9,10),getcell(9,11),getcell(7,8),getcell(10,4),getcell(10,5),getcell(10,6),getcell(10,7),getcell(12,4),getcell(12,5)}
		Define InvalidLocations3 As Cell[rows*columns] = {getcell(1,10),getcell(1,11),getcell(1,13),getcell(2,2),getcell(2,3),getcell(2,4),getcell(2,6),getcell(2,8),getcell(2,15),getcell(3,3),getcell(3,8),getcell(3,10),getcell(3,12),getcell(3,13),getcell(3,15),getcell(4,1),getcell(4,5),getcell(4,6),getcell(4,12),getcell(4,13),getcell(4,15),getcell(5,3),getcell(5,4),getcell(5,5),getcell(5,6),getcell(5,8),getcell(5,9),getcell(5,10),getcell(6,1),getcell(6,5),getcell(6,6),getcell(6,8),getcell(6,12),getcell(6,14),getcell(6,15),getcell(7,3),getcell(7,10),getcell(7,12),getcell(7,14),getcell(7,15),getcell(8,2),getcell(8,3),getcell(8,5),getcell(8,6),getcell(8,7),getcell(8,9),getcell(8,10),getcell(8,12),getcell(9,2),getcell(9,13),getcell(9,14),getcell(9,15),getcell(10,4),getcell(10,5),getcell(10,6),getcell(10,7),getcell(10,8),getcell(10,10),getcell(10,11),getcell(10,13),getcell(11,1),getcell(11,2),getcell(11,10),getcell(11,11),getcell(11,15),getcell(12,4),getcell(12,5),getcell(12,6),getcell(12,8),getcell(12,13),getcell(13,1),getcell(13,2),getcell(13,6),getcell(13,8),getcell(13,10),getcell(13,11),getcell(13,12),getcell(13,13),getcell(13,15),getcell(14,2),getcell(14,4),getcell(14,8),getcell(15,2),getcell(15,4),getcell(15,5),getcell(15,6),getcell(15,7),getcell(15,8),getcell(15,10),getcell(15,11),getcell(15,13),getcell(15,14),getcell(15,15)} 
		currentlevel().loadLevelPt1(removeLeft3,removeUp3, removeRight3, removeDown3, "level5.wav", 45, "Diabetes", InvalidLocations3, level3Questions,lightgray,silver,white)
		createMaze()
		Define SpawnLocations3 As Cell[10] = {getCell(4,8) ,getCell(4,3)  ,getCell(3,6) ,getCell(9,1), getCell(6,9),getcell(14,14),getcell(11,13),getcell(10,3),getcell(1,6),getcell(9,1)}
		Define goodFoodLocations3 As Cell[20] = {getCell(5,1),getcell(7,1),getcell(11,12),getcell(14,9),getcell(12,14),getCell(3,4) ,getCell(10,1)  ,getCell(10,9)  ,getCell(1,8)  ,getCell(5,7),getcell(13,5),getcell(1,14),getcell(14,12),getcell(1,1),getcell(8,13),getcell(5,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6)}
		Define goodfoods3 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations3,"Milk.png")
		Define enemySet3 As Enemy[] = createEnemySet(8,SpawnLocations3, "Soda.png")
		currentlevel().LoadLevelpt2(SpawnLocations3, enemySet3, goodfoods3)
				
		setlevel(4)
		Define removeLeft4 As Cell[rows*columns] = {getcell(1,1),getcell(1,3),getcell(1,5),getcell(1,7),getcell(1,9),getcell(1,11),getcell(1,13),getcell(1,15),getcell(1,2),getcell(2,2),getcell(3,2),getcell(4,2),getcell(5,2),getcell(6,2),getcell(7,2),getcell(8,2),getcell(9,2),getcell(10,2),getcell(11,2),getcell(12,2),getcell(13,2),getcell(14,2),getcell(15,2),getcell(1,4),getcell(2,4),getcell(3,4),getcell(4,4),getcell(5,4),getcell(6,4),getcell(7,4),getcell(8,4),getcell(9,4),getcell(10,4),getcell(11,4),getcell(12,4),getcell(13,4),getcell(14,4),getcell(15,4),getcell(1,6),getcell(2,6),getcell(3,6),getcell(4,6),getcell(5,6),getcell(6,6),getcell(7,6),getcell(8,6),getcell(9,6),getcell(10,6),getcell(11,6),getcell(12,6),getcell(13,6),getcell(14,6),getcell(15,6),getcell(1,8),getcell(2,8),getcell(3,8),getcell(4,8),getcell(5,8),getcell(6,8),getcell(7,8),getcell(8,8),getcell(9,8),getcell(10,8),getcell(11,8),getcell(12,8),getcell(13,8),getcell(14,8),getcell(15,8),getcell(1,10),getcell(2,10),getcell(3,10),getcell(4,10),getcell(5,10),getcell(6,10),getcell(7,10),getcell(8,10),getcell(9,10),getcell(10,10),getcell(11,10),getcell(12,10),getcell(13,10),getcell(14,10),getcell(15,10),getcell(1,12),getcell(2,12),getcell(3,12),getcell(4,12),getcell(5,12),getcell(6,12),getcell(7,12),getcell(8,12),getcell(9,12),getcell(10,12),getcell(11,12),getcell(12,12),getcell(13,12),getcell(14,12),getcell(15,12),getcell(1,14),getcell(2,14),getcell(3,14),getcell(4,14),getcell(5,14),getcell(6,14),getcell(7,14),getcell(8,14),getcell(9,14),getcell(10,14),getcell(11,14),getcell(12,14),getcell(13,14),getcell(14,14),getcell(15,14)}
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp4 As Cell[rows*columns] = {getcell(2,1),getcell(2,2)}
		//remove Right walls of these cells
		Define removeRight4 As Cell[rows*columns] = {getcell(1,2),getcell(2,2)}
		//remove Down walls of these cells
		Define removeDown4 As Cell[rows*columns] =  {getcell(1,15),getcell(3,15),getcell(5,15),getcell(7,15),getcell(9,15),getcell(11,15),getcell(13,15),getcell(15,15),getcell(2,1),getcell(2,2),getcell(2,3),getcell(2,4),getcell(2,5),getcell(2,6),getcell(2,7),getcell(2,8),getcell(2,9),getcell(2,10),getcell(2,11),getcell(2,12),getcell(2,13),getcell(2,14),getcell(2,15),getcell(4,1),getcell(4,2),getcell(4,3),getcell(4,4),getcell(4,5),getcell(4,6),getcell(4,7),getcell(4,8),getcell(4,9),getcell(4,10),getcell(4,11),getcell(4,12),getcell(4,13),getcell(4,14),getcell(4,15),getcell(6,1),getcell(6,2),getcell(6,3),getcell(6,4),getcell(6,5),getcell(6,6),getcell(6,7),getcell(6,8),getcell(6,9),getcell(6,10),getcell(6,11),getcell(6,12),getcell(6,13),getcell(6,14),getcell(6,15),getcell(8,1),getcell(8,2),getcell(8,3),getcell(8,4),getcell(8,5),getcell(8,6),getcell(8,7),getcell(8,8),getcell(8,9),getcell(8,10),getcell(8,11),getcell(8,12),getcell(8,13),getcell(8,14),getcell(8,15),getcell(10,1),getcell(10,2),getcell(10,3),getcell(10,4),getcell(10,5),getcell(10,6),getcell(10,7),getcell(10,8),getcell(10,9),getcell(10,10),getcell(10,11),getcell(10,12),getcell(10,13),getcell(10,14),getcell(10,15),getcell(12,1),getcell(12,2),getcell(12,3),getcell(12,4),getcell(12,5),getcell(12,6),getcell(12,7),getcell(12,8),getcell(12,9),getcell(12,10),getcell(12,11),getcell(12,12),getcell(12,13),getcell(12,14),getcell(12,15),getcell(14,1),getcell(14,2),getcell(14,3),getcell(14,4),getcell(14,5),getcell(14,6),getcell(14,7),getcell(14,8),getcell(14,9),getcell(14,10),getcell(14,11),getcell(14,12),getcell(14,13),getcell(14,14),getcell(14,15)}
		Define InvalidLocations4 As Cell[] = level4invalid()//= {getCell(2,2), getCell(3,2),getCell(4,2), getCell(4,4), getCell(4,5), getCell(1,5), getCell(8,2), getCell(9,2), getCell(8,4), getCell(9,4), getCell(1,7), getCell(2,7), getCell(2,9), getCell(3,9), getCell(7,7), getCell(8,7), getCell(8,6), getCell(5,8), getCell(5,10), getCell(10,7), getCell(10,10), getCell(7,9), getCell(7,10), getCell(8,10)} 
		currentlevel().loadLevelPt1(removeLeft4,removeUp4, removeRight4, removeDown4, "level9.wav", 45,"Atherosclerosis", invalidLocations4,level4questions,18,129,white)
		createMaze()
		Define SpawnLocations4 As Cell[10] = {getCell(3,8) ,getCell(6,3)  ,getCell(2,6) ,getCell(10,1), getCell(6,9),getcell(14,14),getcell(10,13),getcell(10,3),getcell(1,6),getcell(10,1)}
		Define goodFoodLocations4 As Cell[20] = {getCell(6,1),getcell(8,1),getcell(12,11),getcell(14,9),getcell(12,14),getCell(3,4) ,getCell(10,15),getCell(10,9),getCell(1,8),getCell(6,7),getcell(14,5),getcell(1,14),getcell(14,12),getcell(2,1),getcell(10,13),getcell(4,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6)}
		Define goodfoods4 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations4,"Green Apple.png")
		Define enemySet4 As Enemy[10] = createEnemySet(10,SpawnLocations4, "Fries.png")
		currentlevel().LoadLevelpt2(SpawnLocations4, enemySet4, goodfoods4)
				
		setlevel(5)
		Define removeLeft5 As Cell[rows*columns] = {getcell(1,8),getcell(3,7),getcell(2,7),getcell(15,7),getcell(14,7),getcell(2,9),getcell(1,9),getcell(15,9),getcell(1,14),getcell(1,15),getcell(2,2),getcell(1,2),getcell(15,2),getcell(14,2),getcell(1,11),getcell(1,12),getcell(4,2),getcell(6,2),getcell(5,2),getcell(13,2),getcell(12,3),getcell(7,2),getcell(8,2),getcell(9,2),getcell(10,2),getcell(14,13),getcell(4,13),getcell(13,13),getcell(3,13),getcell(11,4),getcell(10,4),getcell(9,4),getcell(8,4),getcell(7,4),getcell(6,4),getcell(13,5),getcell(12,5),getcell(6,6),getcell(7,6),getcell(8,6),getcell(9,6),getcell(10,6),getcell(11,6),getcell(11,10),getcell(10,10),getcell(9,10),getcell(8,10),getcell(7,10),getcell(6,10),getcell(8,8),getcell(9,8),getcell(1,1)}
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp5 As Cell[rows*columns] = {getcell(14,6),getcell(14,5),getcell(14,4),getcell(2,6),getcell(2,5),getcell(2,4),getcell(1,7),getcell(1,6),getcell(1,5),getcell(1,4),getcell(1,3),getcell(15,7),getcell(15,6),getcell(15,5),getcell(15,4),getcell(15,3),getcell(15,8),getcell(1,8),getcell(13,5),getcell(13,4),getcell(13,3),getcell(6,4),getcell(6,3),getcell(10,4),getcell(10,3),getcell(12,13),getcell(4,13),getcell(5,5),getcell(11,5),getcell(4,9),getcell(4,8),getcell(4,7),getcell(12,9),getcell(12,8),getcell(12,7),getcell(12,12),getcell(12,11),getcell(4,12),getcell(4,11),getcell(6,12),getcell(6,11),getcell(10,12),getcell(10,11),getcell(11,10),getcell(11,9),getcell(11,8),getcell(11,7),getcell(5,10),getcell(5,9),getcell(5,8),getcell(5,7),getcell(1,1),getcell(2,1)}
		//remove Right walls of these cells
		Define removeRight5 As Cell[rows*columns] = {getcell(2,2),getcell(14,13),getcell(15,13),getcell(1,13),getcell(14,10),getcell(15,10),getcell(1,10),getcell(4,14),getcell(5,14),getcell(6,14),getcell(7,14),getcell(8,14),getcell(9,14),getcell(10,14),getcell(11,14),getcell(5,13),getcell(6,13),getcell(7,13),getcell(8,13),getcell(9,13),getcell(10,13),getcell(4,3),getcell(10,2),getcell(11,2),getcell(7,3),getcell(8,3),getcell(2,10),getcell(13,10),getcell(3,5),getcell(4,5),getcell(6,5),getcell(7,5),getcell(8,5),getcell(9,5),getcell(3,10),getcell(12,10),getcell(4,10),getcell(11,10),getcell(4,12),getcell(5,12),getcell(6,12),getcell(7,12),getcell(8,12),getcell(9,12),getcell(10,12),getcell(11,12),getcell(7,11),getcell(8,11),getcell(6,7),getcell(7,7),getcell(8,7),getcell(9,7)}
		//remove Down walls of these cells
		Define removeDown5 As Cell[rows*columns] =  {getcell(14,8),getcell(2,8),getcell(1,14),getcell(15,14),getcell(15,15),getcell(2,13),getcell(2,14),getcell(14,13),getcell(14,14),getcell(14,15),getcell(14,1),getcell(13,14),getcell(13,15),getcell(3,14),getcell(3,15),getcell(1,11),getcell(15,11),getcell(5,15),getcell(7,15),getcell(9,15),getcell(11,15),getcell(4,14),getcell(4,15),getcell(4,1),getcell(6,14),getcell(6,15),getcell(6,1),getcell(8,14),getcell(8,15),getcell(8,1),getcell(10,14),getcell(10,15),getcell(10,1),getcell(12,14),getcell(12,15),getcell(12,1),getcell(4,13),getcell(12,13),getcell(3,2),getcell(3,3),getcell(3,4),getcell(4,3),getcell(12,3),getcell(14,10),getcell(14,11),getcell(14,12),getcell(2,10),getcell(2,11),getcell(2,12),getcell(3,11),getcell(13,11),getcell(11,5),getcell(5,5),getcell(3,5),getcell(3,6),getcell(3,7),getcell(3,8),getcell(3,9),getcell(13,5),getcell(13,6),getcell(13,7),getcell(13,8),getcell(13,9),getcell(7,8),getcell(7,9),getcell(9,8),getcell(9,9),getcell(6,7),getcell(6,8),getcell(10,7),getcell(10,8),getcell(2,1)}
		Define InvalidLocations5 As Cell[rows*columns] = { getcell(1,1),getcell(1,9),getcell(1,11),getcell(1,12),getcell(1,14),getcell(1,15),getcell(2,3),getcell(2,4),getcell(2,5),getcell(2,6),getcell(2,8),getcell(2,9),getcell(3,1),getcell(3,11),getcell(3,12),getcell(3,14),getcell(3,15),getcell(4,3),getcell(4,4),getcell(4,6),getcell(4,7),getcell(4,8),getcell(4,9),getcell(5,1),getcell(5,3),getcell(5,11),getcell(5,13),getcell(5,15),getcell(6,5),getcell(6,7),getcell(6,8),getcell(6,9),getcell(6,13),getcell(7,1),getcell(7,3),getcell(7,5),getcell(7,7),getcell(7,11),getcell(7,13),getcell(7,15),getcell(8,3),getcell(8,5),getcell(8,7),getcell(8,9),getcell(8,11),getcell(8,13),getcell(9,1),getcell(9,3),getcell(9,5),getcell(9,7),getcell(9,11),getcell(9,13),getcell(9,15),getcell(10,5),getcell(10,7),getcell(10,8),getcell(10,9),getcell(10,13),getcell(11,1),getcell(11,3),getcell(11,11),getcell(11,13),getcell(11,15),getcell(12,3),getcell(12,4),getcell(12,6),getcell(12,7),getcell(12,8),getcell(12,9),getcell(13,1),getcell(13,11),getcell(13,12),getcell(13,14),getcell(13,15),getcell(14,3),getcell(14,4),getcell(14,5),getcell(14,6),getcell(14,8),getcell(14,9),getcell(15,1),getcell(15,9),getcell(15,11),getcell(15,12),getcell(15,14),getcell(15,15) } 
		currentlevel().loadLevelPt1(removeLeft5,removeUp5, removeRight5, removeDown5, "level8.wav", 45, "Cholesterol", InvalidLocations5, level5questions,orangered,red,white)
		createMaze()
		Define SpawnLocations5 As Cell[] = {getCell(6,3)  ,getCell(2,7) ,getCell(10,1), getCell(5,9),getcell(12,13),getcell(10,3),getcell(1,6),getcell(10,1),getcell(14,14)}
		Define goodFoodLocations5 As Cell[20] = {getCell(6,1),getcell(8,1),getcell(12,11),getcell(13,9),getcell(12,14),getCell(3,4) ,getCell(10,15),getCell(11,9),getCell(1,8),getCell(5,7),getcell(13,5),getcell(2,14),getcell(14,12),getcell(2,1),getcell(10,12),getcell(4,13),getcell(7,4),getcell(2,10),getcell(6,11),getcell(9,6),getCell(10,1)}
		Define goodfoods5 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations5,"Fish.png")
		Define enemySet5 As Enemy[9] = createEnemySetLevel5(9,SpawnLocations5)
		currentlevel().LoadLevelpt2(SpawnLocations5, enemySet5, goodfoods5)
		
		setLevel(6)
		Define removeLeft6 As Cell[rows*columns] = {getCell(8,1),getCell(5,7),getCell(10,1), getCell(5,6),getCell(2,4),getCell(8,5),getCell(7,2),getCell(2,1),getCell(3,2),getCell(6,2),getCell(6,9),getCell(8,3),getCell(10,3),getCell(7,8),getCell(10,8),getCell(9,8),getCell(9,3),getCell(4,2),getCell(3,1),getCell(5,1),getCell(4,1),getCell(2,7),getCell(10,6),getCell(1,6),getCell(4,8),getCell(6,5),getCell(10,9),getCell(7,6),getCell(8,7),getCell(9,5)}
		//will remove the upper wall of these positions
		//If you add o6 remove positions, RESIZE
		Define removeUp6 As Cell[rows*columns] = {getCell(7,3),getCell(1,9),getCell(1,10),getCell(4,9),getCell(5,7),getCell(3,8),getCell(3,7),getCell(1,2), getCell(2,6),getCell(2,5),getCell(5,4),getCell(9,6),getCell(7,10),getCell(8,9),getCell(5,6),getCell(9,8),getCell(1,10),getCell(6,1),getCell(6,4),getCell(6,3),getCell(6,5),getCell(5,3),getCell(6,6),getCell(6,7),getCell(6,8),getCell(9,10),getCell(6,10),getCell(6,9),getCell(5,2),getCEll(4,5), getCell(8,7), getCell(9,7)}
		//remove Right walls of these cells
		Define removeRight6 As Cell[rows*columns] = {getCell(8,2),getCell(5,7),getCell(1,10),getCell(2,9),getCell(4,9),getCell(2,10),getCell(3,10),getCell(2,8),getCell(1,8),getCell(3,7),getCell(8,1),getCell(7,10),getCell(9,5),getCell(7,8),getCell(8,4),getCell(8,9),getCell(3,6),getCell(2,6),getCell(1,6),getCell(1,3),getCell(2,3),getCell(3,3),getCell(4,3),getcell(1,1)}
		//remove Down walls of these cells
		Define removeDown6 As Cell[rows*columns] = {getCell(1,1),getCell(10,3),getCell(3,3),getCell(4,9),getCell(3,4),getCell(3,5),getCell(7,5),getCell(7,4),getCell(5,4),getCell(1,3),getCell(10,4),getCell(10,1),getCell(6,1),getCell(7,1),getCell(7,3),getCell(9,10),getCell(10,8),getCell(10,2), getCell(1,2)}
		Define InvalidLocations6 As Cell[rows*columns] = {getCell(2,2), getCell(3,2),getCell(4,2), getCell(4,4), getCell(4,5), getCell(1,5), getCell(8,2), getCell(9,2), getCell(8,4), getCell(9,4), getCell(1,7), getCell(2,7), getCell(2,9), getCell(3,9), getCell(7,7), getCell(8,7), getCell(8,6), getCell(5,8), getCell(5,10), getCell(10,7), getCell(10,10), getCell(7,9), getCell(7,10), getCell(8,10)} 
		
		currentlevel().loadLevelPt1(removeLeft6,removeUp6, removeRight6, removeDown6,"level6.wav", 30,"", InvalidLocations6,lime,green,white)
		createMaze()
		Define SpawnLocations6 As Cell[4] = {getCell(3,8) ,getCell(5,3)  ,getCell(2,6) ,getCell(9,6)}//   ,getCell(9,1)   ,getCell(8,5)   ,getCell(7,8)   ,getCell(6,9)}
		Define goodFoodLocations6 As Cell[] = {getCell(5,1)  ,getCell(3,4) ,getCell(10,1)  ,getCell(10,9)  ,getCell(1,8)  ,getCell(5,7)}
		Define enemySet6 As enemy[] = createEnemySet(4,SpawnLocations6, "Potato Bag.png")
		Define goodfoods6 As goodFood[] = addGoodFoods(goodFoodLocations6,"Carrot.png")
		currentlevel().LoadLevelpt2(SpawnLocations6, enemySet6, goodfoods6)
		
		setLevel(7)
		Define removeLeft7 As Cell[rows*columns] = {getcell(6,1),getcell(2,1),getcell(3,1),getcell(4,1),getcell(5,1),getcell(6,3),getcell(7,1),getcell(8,1),getcell(9,1),getcell(3,2),getcell(4,2),getcell(5,2),getcell(6,2),getcell(7,2),getcell(8,2),getcell(4,3),getcell(4,5),getcell(4,7),getcell(5,3),getcell(6,3),getcell(7,3),getcell(5,5),getcell(3,5),getcell(8,5),getcell(2,2),getcell(2,8),getcell(1,5)}		
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp7 As Cell[rows*columns] = {getcell(10,1),getcell(10,2),getcell(10,3),getcell(10,4),getcell(10,5),getcell(10,6),getcell(10,7),getcell(10,8),getcell(10,9),getcell(10,10),getcell(9,2),getcell(9,3),getcell(9,4),getcell(9,5),getcell(9,6),getcell(9,7),getcell(9,8),getcell(9,9),getcell(2,3),getcell(2,4),getcell(2,5),getcell(2,6),getcell(2,7),getcell(2,8),getcell(7,4),getcell(7,5),getcell(7,6),getcell(7,7),getcell(3,4),getcell(3,5),getcell(3,6),getcell(3,7),getcell(5,1)}
		//remove Right walls of these cells
		Define removeRight7 As Cell[rows*columns] = {getcell(1,10),getcell(2,10),getcell(3,10),getcell(4,10),getcell(5,10),getcell(6,10),getcell(7,10),getcell(8,10),getcell(9,10),getcell(1,9),getcell(2,9),getcell(3,9),getcell(4,9),getcell(5,9),getcell(6,9),getcell(7,9),getcell(8,9),getcell(2,8),getcell(3,8),getcell(4,8),getcell(5,8),getcell(6,8),getcell(7,8),getcell(5,5),getcell(6,5),getcell(4,7),getcell(5,7),getcell(6,7),getcell(8,2),getcell(8,8),getcell(9,5),getcell(10,10)}
		//remove Down walls of these cells
		Define removeDown7 As Cell[rows*columns] =  {getcell(1,1),getcell(1,2),getcell(1,3),getcell(1,4),getcell(1,5),getcell(1,6),getcell(1,7),getcell(1,8),getcell(8,2),getcell(8,3),getcell(8,4),getcell(8,5),getcell(8,6),getcell(8,7),getcell(5,3),getcell(5,4),getcell(5,5),getcell(5,6),getcell(5,7),getcell(5,2),getcell(5,9)}
		Define InvalidLocations7 As Cell[4] = {getCell(4,4), getCell(4,6),getCell(6,4),getCell(6,6)}
		currentlevel().loadLevelPt1(removeLeft7,removeUp7, removeRight7, removeDown7, "level4.wav", 30, "Obesity", InvalidLocations7,goldenrod,gold,white)
		
		createMaze()
		Define SpawnLocations7 As Cell[4] = {getCell(3,8) ,getCell(5,3),getCell(6,9),getcell(10,3)}
		Define goodFoodLocations7 As Cell[6] = {getCell(7,1)  ,getCell(7,9),getCell(2,7),getcell(5,4),getcell(3,1),getcell(7,6)}
		Define goodfoods7 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations7,"Strawberry.png")
		Define enemySet7 As Enemy[10] = createEnemySet(4,SpawnLocations7, "Donut.png")
		currentlevel().LoadLevelpt2(SpawnLocations7, enemySet7, goodfoods7)
		
		setLevel(8)
		Define removeLeft8 As Cell[rows*columns] = {getcell(3,8),getcell(2,7),getcell(3,5),getcell(2,5),getcell(5,5),getcell(6,6),getcell(5,6),getcell(3,1),getcell(5,2),getcell(4,2),getcell(4,4),getcell(5,7),getcell(6,7),getcell(7,7),getcell(6,8),getcell(6,2),getcell(7,2),getcell(8,1),getcell(9,1),getcell(10,1),getcell(9,8),getcell(1,1),getcell(8,8),getcell(9,4),getcell(8,10),getcell(10,3),getcell(8,3),getcell(9,2)}		
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp8 As Cell[rows*columns] = {getcell(2,10),getcell(3,2),getcell(4,10),getcell(4,9),getcell(4,8),getcell(7,2),getcell(6,10),getcell(2,3),getcell(7,8),getcell(7,7),getcell(7,6),getcell(8,7),getcell(8,6),getcell(9,5),getcell(9,6),getcell(9,7),getcell(9,8),getcell(9,4),getcell(10,2),getcell(10,3)}
		//remove Right walls of these cells
		Define removeRight8 As Cell[rows*columns] = {getcell(1,9),getcell(2,9),getcell(3,9),getcell(2,7),getcell(3,7),getcell(5,5),getcell(6,4),getcell(6,9),getcell(10,10),getcell(1,1),getcell(2,3),getcell(7,4),getcell(9,9),getcell(10,9)}
		//remove Down walls of these cells
		Define removeDown8 As Cell[rows*columns] =  {getcell(3,5),getcell(3,4),getcell(3,6),getcell(5,4),getcell(4,5),getcell(5,5),getcell(6,5),getcell(5,3),getcell(4,2),getcell(4,3),getcell(5,8),getcell(5,9),getcell(5,1),getcell(6,2),getcell(6,3),getcell(1,3),getcell(1,4),getcell(1,5),getcell(1,6),getcell(1,7),getcell(1,8),getcell(1,2),getcell(2,10),getcell(9,8),getcell(1,1),getcell(2,3),getcell(8,9),getcell(7,4),getcell(8,2),getcell(9,9),getcell(9,10),getcell(7,8),getcell(10,4),getcell(10,5),getcell(10,6),getcell(10,7)}
		Define InvalidLocations8 As Cell[rows*columns] = {getcell(1,10),getcell(2,2),getcell(2,3),getcell(2,4),getcell(2,6),getcell(2,8),getcell(3,3),getcell(3,8),getcell(3,10),getcell(4,1),getcell(4,5),getcell(4,6),getcell(5,3),getcell(5,4),getcell(5,5),getcell(5,6),getcell(5,8),getcell(5,9),getcell(5,10),getcell(6,1),getcell(6,5),getcell(6,6),getcell(6,8),getcell(7,3),getcell(7,10),getcell(8,2),getcell(8,3),getcell(8,5),getcell(8,6),getcell(8,7),getcell(8,9),getcell(8,10),getcell(9,2),getcell(10,4),getcell(10,5),getcell(10,6),getcell(10,7),getcell(10,8),getcell(10,10)} 
		currentlevel().loadLevelPt1(removeLeft8,removeUp8, removeRight8, removeDown8, "level5.wav", 30, "Diabetes", InvalidLocations8,lightgray,silver,white)
		createMaze()
		Define SpawnLocations8 As Cell[4] = {getCell(4,8), getCell(6,9),getcell(10,3),getcell(1,6)}
		Define goodFoodLocations8 As Cell[6] = {getCell(5,1),getCell(3,4),getCell(1,8)  ,getCell(5,7),getcell(7,4),getcell(9,6)}
		Define goodfoods8 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations8,"Milk.png")
		Define enemySet8 As Enemy[4] = createEnemySet(4,SpawnLocations8, "Soda.png")
		currentlevel().LoadLevelpt2(SpawnLocations8, enemySet8, goodfoods8)
				
		setLevel(9)
		Define removeLeft9 As Cell[rows*columns] = {getcell(1,2),getcell(2,2),getcell(3,2),getcell(4,2),getcell(5,2),getcell(6,2),getcell(7,2),getcell(8,2),getcell(9,2),getcell(10,2),getcell(11,2),getcell(12,2),getcell(13,2),getcell(14,2),getcell(15,2),getcell(1,4),getcell(2,4),getcell(3,4),getcell(4,4),getcell(5,4),getcell(6,4),getcell(7,4),getcell(8,4),getcell(9,4),getcell(10,4),getcell(11,4),getcell(12,4),getcell(13,4),getcell(14,4),getcell(15,4),getcell(1,6),getcell(2,6),getcell(3,6),getcell(4,6),getcell(5,6),getcell(6,6),getcell(7,6),getcell(8,6),getcell(9,6),getcell(10,6),getcell(11,6),getcell(12,6),getcell(13,6),getcell(14,6),getcell(15,6),getcell(1,8),getcell(2,8),getcell(3,8),getcell(4,8),getcell(5,8),getcell(6,8),getcell(7,8),getcell(8,8),getcell(9,8),getcell(10,8),getcell(11,8),getcell(12,8),getcell(13,8),getcell(14,8),getcell(15,8),getcell(1,10),getcell(2,10),getcell(3,10),getcell(4,10),getcell(5,10),getcell(6,10),getcell(7,10),getcell(8,10),getcell(9,10),getcell(10,10),getcell(11,10),getcell(12,10),getcell(13,10),getcell(14,10),getcell(15,10),getcell(1,12),getcell(2,12),getcell(3,12),getcell(4,12),getcell(5,12),getcell(6,12),getcell(7,12),getcell(8,12),getcell(9,12),getcell(10,12),getcell(11,12),getcell(12,12),getcell(13,12),getcell(14,12),getcell(15,12),getcell(1,14),getcell(2,14),getcell(3,14),getcell(4,14),getcell(5,14),getcell(6,14),getcell(7,14),getcell(8,14),getcell(9,14),getcell(10,14),getcell(11,14),getcell(12,14),getcell(13,14),getcell(14,14),getcell(15,14)}
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp9 As Cell[rows*columns] = {getcell(2,1),getcell(2,2)}
		//remove Right walls of these cells
		Define removeRight9 As Cell[rows*columns] = {getcell(1,2),getcell(2,2)}
		//remove Down walls of these cells
		Define removeDown9 As Cell[rows*columns] =  {getcell(15,15),getcell(2,1),getcell(2,2),getcell(2,3),getcell(2,4),getcell(2,5),getcell(2,6),getcell(2,7),getcell(2,8),getcell(2,9),getcell(2,10),getcell(2,11),getcell(2,12),getcell(2,13),getcell(2,14),getcell(2,15),getcell(4,1),getcell(4,2),getcell(4,3),getcell(4,4),getcell(4,5),getcell(4,6),getcell(4,7),getcell(4,8),getcell(4,9),getcell(4,10),getcell(4,11),getcell(4,12),getcell(4,13),getcell(4,14),getcell(4,15),getcell(6,1),getcell(6,2),getcell(6,3),getcell(6,4),getcell(6,5),getcell(6,6),getcell(6,7),getcell(6,8),getcell(6,9),getcell(6,10),getcell(6,11),getcell(6,12),getcell(6,13),getcell(6,14),getcell(6,15),getcell(8,1),getcell(8,2),getcell(8,3),getcell(8,4),getcell(8,5),getcell(8,6),getcell(8,7),getcell(8,8),getcell(8,9),getcell(8,10),getcell(8,11),getcell(8,12),getcell(8,13),getcell(8,14),getcell(8,15),getcell(10,1),getcell(10,2),getcell(10,3),getcell(10,4),getcell(10,5),getcell(10,6),getcell(10,7),getcell(10,8),getcell(10,9),getcell(10,10),getcell(10,11),getcell(10,12),getcell(10,13),getcell(10,14),getcell(10,15)}
		Define InvalidLocations9 As Cell[] = level4invalid()//= {getCell(2,2), getCell(3,2),getCell(4,2), getCell(4,4), getCell(4,5), getCell(1,5), getCell(8,2), getCell(9,2), getCell(8,4), getCell(9,4), getCell(1,7), getCell(2,7), getCell(2,9), getCell(3,9), getCell(7,7), getCell(8,7), getCell(8,6), getCell(5,8), getCell(5,10), getCell(10,7), getCell(10,10), getCell(7,9), getCell(7,10), getCell(8,10)} 
		currentlevel().loadLevelPt1(removeLeft9,removeUp9, removeRight9, removeDown9, "level9.wav", 30,"Atherosclerosis", invalidLocations9,18,129,white)
		createMaze()
		Define SpawnLocations9 As Cell[4] = {getCell(3,8) ,getCell(6,3) ,getCell(10,1), getCell(6,9),getcell(1,6),getcell(10,1)}
		Define goodFoodLocations9 As Cell[6] = {getCell(6,1),getCell(3,4) ,getCell(10,9),getcell(7,4),getcell(2,10),getcell(9,6)}
		Define goodfoods9 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations9,"Green Apple.png")
		Define enemySet9 As Enemy[10] = createEnemySet(4,SpawnLocations9, "Fries.png")
		currentlevel().LoadLevelpt2(SpawnLocations9, enemySet9, goodfoods9)
		
		setLevel(10)
		Define removeLeft10 As Cell[rows*columns] = {getcell(3,7),getcell(2,7),getcell(2,9),getcell(1,9),getcell(2,2),getcell(1,2),getcell(4,2),getcell(6,2),getcell(5,2),getcell(7,2),getcell(8,2),getcell(9,2),getcell(10,2),getcell(10,4),getcell(9,4),getcell(8,4),getcell(7,4),getcell(6,4),getcell(6,6),getcell(7,6),getcell(8,6),getcell(9,6),getcell(10,6),getcell(10,10),getcell(9,10),getcell(8,10),getcell(7,10),getcell(6,10),getcell(8,8),getcell(9,8),getcell(1,6)}
		//will remove the upper wall of these positions
		//If you add or remove positions, RESIZE
		Define removeUp10 As Cell[rows*columns] = {getcell(2,6),getcell(2,5),getcell(2,4),getcell(1,7),getcell(1,6),getcell(1,5),getcell(1,4),getcell(1,3),getcell(1,8),getcell(6,4),getcell(6,3),getcell(10,4),getcell(10,3),getcell(5,5),getcell(4,9),getcell(4,8),getcell(4,7),getcell(5,10),getcell(5,9),getcell(5,8),getcell(5,7),getcell(2,1)}
		//remove Right walls of these cells
		Define removeRight10 As Cell[rows*columns] = {getcell(2,2),getcell(1,10),getcell(4,3),getcell(10,2),getcell(7,3),getcell(8,3),getcell(2,10),getcell(3,5),getcell(4,5),getcell(6,5),getcell(7,5),getcell(8,5),getcell(9,5),getcell(3,10),getcell(4,10),getcell(6,7),getcell(7,7),getcell(8,7),getcell(9,7)}
		//remove Down walls of these cells
		Define removeDown10 As Cell[rows*columns] =  {getcell(2,8),getcell(4,1),getcell(6,1),getcell(8,1),getcell(10,1),getcell(3,2),getcell(3,3),getcell(3,4),getcell(4,3),getcell(2,10),getcell(5,5),getcell(3,5),getcell(3,6),getcell(3,7),getcell(3,8),getcell(3,9),getcell(7,8),getcell(7,9),getcell(9,8),getcell(9,9),getcell(6,7),getcell(6,8),getcell(10,7),getcell(10,8),getcell(2,1)}
		Define InvalidLocations10 As Cell[rows*columns] = { getcell(1,1),getcell(1,9),getcell(2,3),getcell(2,4),getcell(2,5),getcell(2,6),getcell(2,8),getcell(2,9),getcell(3,1),getcell(4,3),getcell(4,4),getcell(4,6),getcell(4,7),getcell(4,8),getcell(4,9),getcell(5,1),getcell(5,3),getcell(6,5),getcell(6,7),getcell(6,8),getcell(6,9),getcell(7,1),getcell(7,3),getcell(7,5),getcell(7,7),getcell(8,3),getcell(8,5),getcell(8,7),getcell(8,9),getcell(9,1),getcell(9,3),getcell(9,5),getcell(9,7),getcell(10,5),getcell(10,7),getcell(10,8),getcell(10,9)} 
		currentlevel().loadLevelPt1(removeLeft10,removeUp10, removeRight10, removeDown10, "level8.wav", 30, "Cholesterol", InvalidLocations10,orangered,red,black)
		createMaze()
		Define SpawnLocations10 As Cell[4] = {getCell(3,8) ,getCell(6,3) ,getCell(5,9),getcell(10,3)}
		Define goodFoodLocations10 As Cell[6] = {getCell(6,1),getCell(3,4) ,getCell(5,7),getcell(7,4),getcell(2,10),getcell(9,6)}
		Define goodfoods10 As goodFood[rows*columns] = addGoodFoods(goodFoodLocations10,"Fish.png")
		Define enemySet10 As Enemy[4] = createEnemySet(4,SpawnLocations10,"Burger.png")
		currentlevel().LoadLevelpt2(SpawnLocations10, enemySet10, goodfoods10)
		loadsprite.Hide()
	End Method
	
	
	//returnslevel4 invalid
	//Because of the nature of level4, it was easier to do it this way
	Function level4invalid() As Cell[]
		Define inv As Cell[((currentlevel().columns+1)/2)*(currentlevel().rows+1)/2]
		Define i As Integer
		Define i2 As Integer
		Define loc As Integer = 1
		For i = 1 To ((currentlevel().columns+1)/2)
			For i2 = 1 To ((currentlevel().rows+1)/2)
				inv[loc] = getcell(2*i-1, 2*i2-1)
				loc +=1
			Next
		Next
		Return inv
	End Function
	
	//returns difficulty
	Function currentDifficulty() As Difficulty
		If diff = 1 Then
			Return Chesney
		Else If diff = 2 Then
			Return easy
		Else If diff = 3 Then
			Return medium
		Else If diff = 4 Then
			Return hard
		Else If diff = 5 Then
			Return god
		Else 
			Return arcadediff
		End If
	End Function
	
	//sets diff as int
	Method setDifficulty(difficulty As Integer) 
		If difficulty <= 5 And difficulty >=0 Then
			diff = difficulty
		End If
	End Method	
	
	//returns currentlevel - uses clevel as pointer
	Function currentlevel() As level
		If clevel = 1 Then 
			Return level1
		Else If clevel = 2Then 
			Return level2
		Else If clevel = 3 Then 
			Return level3
		Else If clevel = 4 Then 
			Return level4
		Else If clevel = 5 Then 
			Return level5
		Else If clevel = 6 Then
			Return multi1
		Else If clevel = 7 Then
			Return multi2
		Else If clevel = 8 Then
			Return multi3
		Else If clevel = 9 Then
			Return multi4
		Else If clevel = 10 Then
			Return multi5
		Else 
			Return mini
		End If
	End Function	
	
	//sets level as int
	Method setLevel(levelnew As Integer) 
		If levelnew >=0 And levelnew <=10 Then
			leaveCurrentLevel()
			clevel = levelnew
		End If
	End Method
	
	//reinits level
	//do everything in terms of currentlevel()
	//run before starting every level
	Method initLevel()
		loadsprite.Show()
		//loads various bars
		//progress.load()
		//healthbar.load()
		//timebar.load()
		//loads the lives spite-used to stamp out number of lives
		lifeSprite.Load("Dr. Meatloaf Lives.png")
		lifesprite.Scale(100*30/lifesprite.Width, 100*30/lifesprite.height)
		
		Define counter As Integer
		Define l As Level = currentLevel()
		//If  Not l.mus = "" Then
		l.music.loadFile(l.mus)//loads music for level
		//End If
		//loads good foods
		For counter = 1 To arraylength(l.maze)
			l.Maze[counter].containsEnemy = False
			l.Maze[counter].containsgoodfood = False
		Next
		
		
		For counter = 1 To arraylength(l.goodFoods)
			If l.goodFoods[counter].isReal Then//if real then load and move into position
				l.goodFoods[counter].load()
				l.goodfoods[counter].changepos(currentlevel().goodfoods[counter].xpos,currentlevel().goodfoods[counter].ypos, convertX(currentlevel().goodFoods[counter].xpos), convertY(currentlevel().goodFoods[counter].ypos))
			Else //else keep out of sight- probably unnecessary, but
				l.enemyset[counter].psprite.hide()
			End If
			
		Next
		
		
		//loads enemies
		For counter = 1 To arrayLength(currentlevel().enemyset)
			
			If l.enemyset[counter].isReal Then//saem as above
				l.enemyset[counter].Load()
				l.enemyset[counter].changepos(currentlevel().enemyset[counter].startX,currentlevel().enemyset[counter].startY, convertX(currentlevel().enemyset[counter].startX), convertY(currentlevel().enemyset[counter].startY))
				
			Else
				//l.enemyset[counter].psprite.hide()
			End If
			If currentlevel() = level5 Then
				l.enemyset[1].unload()
				l.enemyset[1].load()
				l.enemyset[1].changepos(currentlevel().enemyset[1].startX,currentlevel().enemyset[1].startY, convertX(currentlevel().enemyset[1].startX), convertY(currentlevel().enemyset[1].startY))
				
			End If
		Next
		//loads player
		character.loadplayer(cellsize)
		//you haven't wonm, but you haven't lost
		isCaught = False
		haswon = False
		//time in game = 0
		totalGameTime = 0
		//get healthbar label
		healthbar.label = l.barName
		//display the game
		loadsprite.Hide()
		scrollGame()
		//display the player
		changeCharacterPosition(character.xpos, character.ypos, character)
		updateContainsgoodFoods()
		updateContainsEnemy()
		//refresh the screen
		RefreshScreen()
		
	End Method
	
	//runs the actual game
	Function RunGame() As Boolean
		
		Define quit As Boolean = False
		Define Ipressed As Boolean = False
		
		//Define timeBuffer As Integer//should help prevent overlapping cheats
		Gametimer.start()//starts gametimer
		Define PauseSprite As Sprite
		pauseSprite.Load("Pause.png")
		Define goodFoodHit As Boolean
		Define enemyHit As Boolean 
		Define counter As Integer
		Define l As Level = currentlevel()
		If Not muted Then
			l.music.PlayLoop()
		End If
		//starts up music
		//clearKeyboardEvents()
		//wait until player moves to enter game - user input
		While getKey() = "" And GameTimer.Elapsed< 5 
			delay(1)
		End While
		//while you don't want to exit, you haven't won, and you haven't lost, and you haven''t run out of time(last is N/A on Chesney)
		While Not IsCaught And Not hasWon And (totalGameTime <= l.time Or currentDifficulty() = chesney)
			//pause code
			If isKeyDown("p") And paused Then
				paused = False
				clearKeyboardevents()
				gameTimer.Reset()
				pauseSprite.hide()
				l.music.LoadFile(l.mus)
				If Not muted Then 
					l.music.playLoop()
				End If
				//don't reset til players ready
				While getKey() = "" And GameTimer.Elapsed< 2 
					delay(1)
					scrollgame()
				End While
			Else If isKeyDown("p")Then
				l.music.Stop()
				paused = True
				clearKeyboardevents()
				pauseSprite.hide()
				pauseSprite.Scale(300,300)
				pauseSprite.moveTo((screenwidth()-pauseSprite.width)/2, (screenheight()+ygap-pauseSprite.height)/2)
				pauseSprite.Show()
			End If
			//quit code 
			If isKeyDown("q")Then
				//ubersmash you
				character.setPlayerHealth(0)
				character.lives = 0
				character.invincible = False
				totalgametime = l.time
				quit = True
			End If
			
			
			//HACKS
			//HACKS
			//HACKS
			//HACKS
			If cheats Then
				If isKeyDown("3") Then
					setDifficulty(4)
				End If
				If isKeyDown("2") Then
					setDifficulty(3)
				End If
				If isKeyDown("1") Then
					setDifficulty(2)
				End If
				If isKeyDown("4") Then
					setDifficulty(1)
				End If
				If isKeyDown("5") Then
					setDifficulty(5)
				End If
				If isKeyDown(".") Then
					character.setPlayerHealth(character.health+1)
				End If
				If isKeyDown(",") Then
					character.setPlayerHealth(character.health-1)
				End If
				If isKeyDown("t") Then
					totalGameTime-=1
				End If
				If isKeyDown("y") Then
					totalGameTime+=1
				End If
				If isKeyDown("i")  And Not Ipressed Then
					character.invincible = Not character.invincible
				
					Ipressed = True
				Else If Not isKeyDown("i") Then
					Ipressed = False
				End If
				If isKeyDown("u") Then
					unlocked[diff] = True
				End If
				If isKeyDown("e") Then
					For counter =1 To arraylength(l.enemyset)
						If l.enemyset[counter].isReal Then
							l.enemyset[counter].active = True
						End If
					Next
				End If
				If isKeyDown("g") Then
					For counter = 1 To arraylength(l.goodFoods) 
						If l.goodfoods[counter].isReal Then
							l.goodFoods[counter].active = True
						End If
					Next
				End If
			End If
			
			If isKeyDown("k") Then
				For counter = 1 To arraylength(l.goodFoods) 
					If l.goodfoods[counter].isReal Then
						l.goodFoods[counter].active = False
					End If
				Next
			End If
			
			//END HACKS
			//END HACKS
			//END HACKS
			
			
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(l.music, l.mus)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If Not paused Then
				//timer
				Define time As Decimal = GameTimer.elapsed
				Delay(30-1000*time)
				//igore extra long frames- testing etc. 
				If time < .5 Then
					totalGameTime+=time
				End If
				//reset timer
				GameTimer.reset()
				//moveplayer, then enemies, then display
				MovePlayer(character)
				moveEnemies(l.enemyset, character)
				
				//now check for goodfoods and enemies
				enemyHit = caught(l.enemyset, character)
				goodFoodHit = checkGoodFoodIntersection(character)
				//contains enemy does nothing- ignore
				updateContainsEnemy()
				updateContainsGoodFoods()
				//have you found all good foods
				haswon = IsComplete()
				//are you dead
				isCaught = isDead(character)
				scrollGame()
			Else
				scrollgame()
				pauseSprite.moveTo((screenwidth()-pauseSprite.width)/2, (screenheight()+ygap-pauseSprite.height)/2)
				pauseSprite.show()
				delay(1)
			End If
		End While
		//stop muzak
		l.music.Stop()
		paused = False
		pauseSprite.Unload()
		character.invincible= False
		Return quit
	End Function
	
	//initializes multiplayer levels
	Method initLevelMulti()
		loadsprite.Show()
		//loads various bars
		ygap = 90
		//healthbar1.load()
		//healthbar2.load()
		//timebar2.load()
		
		Define counter As Integer
		Define l As Level = currentLevel()
		l.music.loadFile(l.mus)//loads music for level
		
		//reloads maze
		For counter = 1 To arraylength(l.maze)
			l.Maze[counter].containsEnemy = False
			l.Maze[counter].containsgoodfood = False
		Next
		//loads good foods
		For counter = 1 To arraylength(l.goodFoods)
			If l.goodFoods[counter].isReal Then//if real then load and move into position
				l.goodFoods[counter].load()
				l.goodfoods[counter].changepos(l.goodfoods[counter].xpos,l.goodfoods[counter].ypos, convertX(l.goodFoods[counter].xpos), convertY(l.goodFoods[counter].ypos))
				getcell(l.goodFoods[counter].xpos, l.goodFoods[counter].ypos).containsgoodFood = True
			End If
			
		Next
		
		//loads enemies
		For counter = 1 To arrayLength(currentlevel().enemyset)
			Define p As Integer = arraylength(l.enemyset)
			If l.enemyset[counter].isReal Then//saem as above
				l.enemyset[counter].Load()
				l.enemyset[counter].changepos(currentlevel().enemyset[counter].startX,currentlevel().enemyset[counter].startY, convertX(currentlevel().enemyset[counter].startX), convertY(currentlevel().enemyset[counter].startY))
			End If
		Next
		//loads player
		player1.loadplayer(1, 2, cellsize)
		player2.loadplayer(8,8, cellsize)
		
		//time in game = 0
		totalGameTime = 0
		//display the game
		loadsprite.Hide()
		scrollGameMulti(players)
		//display the player
		changeCharacterPosition(player1.xpos, player1.ypos, player1)
		changeCharacterPosition(player2.xpos, player2.ypos, player2)
		//refresh the screen
		updateContainsEnemy()
		RefreshScreen()
		
	End Method
	
	//runs multiplayer game
	Function RunGameMulti() As Boolean
		Define quit As Boolean = False
		Gametimer.start()//starts gametimer
		Define PauseSprite As Sprite
		pauseSprite.Load("Pause.png")
		Define goodFoodHit1 As Boolean
		Define goodFoodHit2 As Boolean
		Define enemyHit1 As Boolean
		Define enemyHit2 As Boolean 
		Define l As Level = currentlevel()
		
		//Define timeA as Decimal = GameTimer.elapsed
		If Not muted Then
			l.music.PlayLoop()
		End If
		//starts up music
		//clearKeyboardEvents()
		//wait until player moves to enter game - user input
		While getKey() = "" And GameTimer.Elapsed< 5 
			delay(1)
		End While
		//while you don't want to exit, you haven't won, and you haven't lost, and you haven''t run out of time(last is N/A on Chesney)
		While (totalGameTime <= l.time)
			//pause code
			If isKeyDown("p") And paused Then
				paused = False
				clearKeyboardevents()
				gameTimer.Reset()
				pauseSprite.hide()
				l.music.LoadFile(l.mus)
				If Not muted Then 
					l.music.playLoop()
				End If
				//don't reset til players ready
				While getKey() = "" And GameTimer.Elapsed< 2 
					delay(1)
				End While
			Else If isKeyDown("p")Then
				l.music.Stop()
				paused = True
				clearKeyboardevents()
				pauseSprite.hide()
				pauseSprite.Scale(300,300)
				pauseSprite.moveTo((screenwidth()-pauseSprite.width)/2, (screenheight()+ygap-pauseSprite.height)/2)
				pauseSprite.Show()
			End If
			If iskeydown("q") Then
				totalGameTIme = l.time
				quit = True
			End If
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(l.music, l.mus)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If Not paused Then
				//timer
				Define time As Decimal = GameTimer.elapsed
				Delay(30-1000*time)
				//igore extra long frames- testing etc. 
				If time < .5 Then
					totalGameTime+=time
				End If
				//reset timer
				GameTimer.reset()
				//moveplayer, then enemies, then display
				MovePlayerMulti(player1)
				MovePlayerMulti(player2)
				moveEnemies(l.enemyset, player1)
				scrollGameMulti(players)
				//now check for goodfoods and enemies
				enemyHit1 = caught(l.enemyset, player1)
				goodFoodHit1 = checkGoodFoodIntersection(player1)
				enemyHit2 = caught(l.enemyset, player2)
				goodFoodHit2 = checkGoodFoodIntersection(player2)
				
				//update whether a cell contains a good food or an enemy
				updateContainsEnemy()
				updateContainsGoodFoods()
			Else
				pauseSprite.show()
			End If
		End While
		//stop muzak
		l.music.Stop()
		paused = False
		pauseSprite.Unload()
		ygap = 100
		Return quit
	End Function
	
	
	//are you dead
	Function isDead(p As Player) As Boolean
		If p.health> 0 Or p.invincible Then
			Return False
		End If
		Return True
	End Function
	
	//moves all enemies in enemyset
	Method moveEnemies(e As enemy[], p As Player)
		Define counter As Integer = 0
		For counter = 1 To arrayLength(e)
			moveEnemy(e[counter], p)
		Next
	End Method
	
	Method moveEnemies(e As enemy[], p As Player[])
		Define counter As Integer = 0
		For counter = 1 To arrayLength(e)
			moveEnemy(e[counter], p)
		Next
	End Method
	
	//updates maze position and draws
	Method MoveMaze()
		Define counter As Integer
		Define l As Level = currentlevel()
		For counter = 1 To arraylength(currentlevel().maze)
			l.maze[counter].xpos = l.maze[counter].column +(character.startx - character.xpos)
			l.maze[counter].ypos = l.maze[counter].row +(character.starty - character.ypos)
		Next
		DrawMaze()
	End Method
	
	//picks player sprite given direction
	Method DisplayPlayer(p As player)
		If p.hasbeenLoaded Then
			p.psprite.Hide()//hides
			If p.invincible Then
				p.psprite.opacity = 50
			Else 
				p.psprite.opacity = 100
			End If
		End If
		//switches value
		Select p.direction
			Case 0
				p.psprite = p.pspriteU
			End Case
			Case 1
				p.psprite = p.pspriteR
			End Case
			Case 2
				p.psprite = p.pspriteD
			End Case
			Case 3
				p.psprite = p.pspriteL
				
			End Case
		End Select
		
		p.psprite.Show()
		//refreshscreen()
		doevents()
	End Method
	
	//has finished level
	//call every frame
	Function isComplete() As Boolean
		Define i As Integer
		Define l As Level = currentlevel()
		//if any foods are stil active, you aren't done so return false
		For i = 1 To arraylength(currentlevel().goodFoods)
			If l.goodFoods[i].active Then
				Return False
			End If
		Next
		
		Return True
	End Function
	
	//checks good food intersections
	//returns boolean re if hit for sound playing
	Function checkgoodFoodIntersection(p As player) As Boolean
		Define n As Integer
		Define l As Level = currentlevel()
		Define intersected As Boolean = False
		For n =1 To arraylength(currentlevel().goodFoods)
			If intersectsPlayer(l.goodFoods[n], p) And l.goodFoods[n].active Then//getCell(currentlevel().goodFoods[n].xpos,currentlevel().goodFoods[n].ypos) = getPlayerCell(character.xpos, character.ypos) And currentlevel().goodFoods[n].active Then
				
				p.setPlayerHealth( p.health+ currentDifficulty().goodFoodBonus)
				l.goodFoods[n].active = False
				l.foodseaten+=1
				p.goodFoodsHit +=1
				intersected = True
			End If	
		Next
		Return intersected
		
	End Function
	
	
	Define hitDistance As Decimal = .92
	//checks if good food g intersects player p
	//called in checkgoodfoodintersection
	Function intersectsPlayer(g As goodFood, p As player) As Boolean

		Define x As Decimal = p.xpos
		Define y As Decimal = p.ypos
		//if within one cell or sprites intersect, is true else false
		If abs(x-g.xpos) < hitDistance And abs(y-g.ypos)< hitDistance Or g.psprite.Intersects(p.psprite) Then
			Return True
		End If
		Return False
	End Function
	
	//creates the set of enemies for a level
	//called in load game
	Function createEnemySet(n As Int, spawn As cell[], pic As String) As Enemy[]
		//so n is number of enemies, spawn is the locations they should appear in, and pic ois the picture tht goes with the enemies
		Define enSet As Enemy[n]
		Define counter As Integer 
		//if more enemies then spots, stop program
		If n  > arrayLength(spawn) Then
			stop()
		Else If n = arrayLength(spawn) Then
			//if equal size just fill spots
			For counter = 1 To n
				Define e As enemy
				e.loadenemy(spawn[counter].column,spawn[counter].row,pic, cellsize)
				enset[counter] = e
			Next
		Else
			//if more spots than player, randomly fill spots
			Define invalid As Boolean//checks for valid spawning
			Define c As Integer
			For counter = 1 To n
				Define e As Enemy
				Invalid = True
				While invalid = True
					invalid = False
					c = Random(1, arrayLength(spawn))// pick random location
					If spawn[c].containsEnemy Then//if filled then pick another one
						invalid = True
					End If
				End While
				
				spawn[c].containsEnemy = True//make this spot be full
				e.loadEnemy(spawn[c].column,spawn[c].row, pic,cellsize)//load enemy an put in enemyset
				enSet[counter] = e
			Next
		End If
		Return enset//return enset to act as that level's enemyset
	End Function
	
	//creates the set of enemies for a level
	//called in load game
	Function createEnemySetlevel5(n As Int, spawn As cell[]) As Enemy[]
		//so n is number of enemies, spawn is the locations they should appear in, and pic ois the picture tht goes with the enemies
		Define enSet As Enemy[n]
		Define counter As Integer 
		//if more enemies then spots, stop program
		If n  > arrayLength(spawn) Then
			stop()
		Else If n = arrayLength(spawn) Then
			//if equal size just fill spots
			For counter = 2 To n
				Define e As enemy
				If counter/2 = 1 Then 
					e.loadenemy(spawn[counter-1].column,spawn[counter-1].row,"Fries.png", cellsize)
				Else If counter/2 = 2 Then 
					e.loadenemy(spawn[counter-1].column,spawn[counter-1].row,"Soda.png", cellsize)
				Else If counter/2 = 3 Then 
					e.loadenemy(spawn[counter-1].column,spawn[counter-1].row,"Potato Bag.png", cellsize)
				Else If counter/2 = 4 Then 
					e.loadenemy(spawn[counter-1].column,spawn[counter-1].row,"Donut.png", cellsize)
				End If
				enset[counter-1] = e
			Next
			Define e As enemy
			e.loadenemy(spawn[n].column,spawn[n].row,"Burger.png", cellsize)
			e.IsBurger = True
			enset[n] = e
		Else
			//if more spots than player, randomly fill spots
			Define invalid As Boolean//checks for valid spawning
			Define c As Integer
			For counter =1 To n
				Define e As Enemy
				Invalid = True
				While invalid = True
					invalid = False
					c = Random(1, arrayLength(spawn))// pick random location
					If spawn[c].containsEnemy Then//if filled then pick another one
						invalid = True
					End If
				End While
				spawn[c].containsEnemy = True//make this spot be fullIf counter/2 = 0 Then 
				If (counter+1)/2 = 1 Then 
					e.loadenemy(spawn[c].column,spawn[c].row,"Fries.png", cellsize)
				Else If (counter+1)/2 = 2 Then 
					e.loadenemy(spawn[c].column,spawn[c].row,"Soda.png", cellsize)
				Else If (counter+1)/2 = 3 Then 
					e.loadenemy(spawn[c].column,spawn[c].row,"Potato Bag.png", cellsize)
				Else If (counter+1)/2 = 4 Then 
					e.loadenemy(spawn[c].column,spawn[c].row,"Donut.png", cellsize)
				Else
					e.loadenemy(spawn[c].column,spawn[c].row,"Burger.png", cellsize)
					e.IsBurger = True
				End If
				enset[counter] = e
			Next
		End If
		Return enset//return enset to act as that level's enemyset
	End Function
	
	//generic movePlayer code
	//moves player based on direction
	//ripped from rungame 19Oct2009
	Method MovePlayer( p As player)
		Define buffer As Decimal = .35
		Define a As Integer = p.direction
		Define cellchanges As Boolean
		Define b As Boolean
		If iskeydown(p.upKey) Then
			p.setDirection(0)
			cellchanges = Not (ceiling(p.ypos) = ceiling(p.ypos-p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).up  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer And (Not cellchanges Or (getCell(round(p.xpos), floor(p.ypos - p.playerspeed)).down And cellchanges)) Then
				changeCharacterPosition(round(p.xpos),p.ypos -p.playerSpeed, p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).up  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer Then
				changeCharacterPosition(round(p.xpos),ceiling(p.ypos -p.playerSpeed), p)
			Else
				p.setDirection(a)
			End If
					
		End If
		//same for down, right, left
		If iskeydown(p.downKey) Then
			p.setDirection(2)
			cellchanges = Not (floor(p.ypos) = floor(p.ypos+p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).down  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer And (Not cellchanges Or (getCell(round(p.xpos), ceiling(p.ypos + p.playerspeed)).up And cellchanges)) Then
				changeCharacterPosition(round(p.xpos),p.ypos +p.playerSpeed, p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).down  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer Then
				changeCharacterPosition(round(p.xpos),floor(p.ypos +p.playerSpeed), p)
			Else
				p.setDirection(a)
			End If
		End If
			
			
		If iskeydown(p.rightKey) Then
			p.setDirection(1)
			cellchanges = Not(floor(p.xpos) = floor(p.xpos+p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).right  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer And (Not cellchanges Or (getCell(ceiling(p.xpos + p.playerspeed),round(p.ypos)).left And cellchanges))  Then
				changeCharacterPosition(p.xpos +p.playerSpeed, round(p.ypos), p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).right  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer Then
				changeCharacterPosition(floor(p.xpos +p.playerSpeed), round(p.ypos), p)
			Else
				p.setDirection(a)
			End If
		End If
			
			
		If iskeydown(p.leftKey) Then
			p.setDirection(3)
			cellchanges = Not (ceiling(p.xpos) = ceiling(p.xpos-p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).left  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer And (Not cellchanges Or (getCell(floor(p.xpos - p.playerspeed),round(p.ypos)).right And cellchanges))Then
				changeCharacterPosition(p.xpos -p.playerSpeed, round(p.ypos), p)
			Else If getPlayerCell(p.xpos,p.ypos, p).left  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer Then
				changeCharacterPosition(ceiling(p.xpos -p.playerSpeed), round(p.ypos), p)
			Else
				p.setDirection(a)
			End If
		End If
		
	End Method
	
	//mutes without actually playing music
	Method Mute()
		 muted= Not muted 
	End Method
	
	
	Method Mute(currentmusic As Sound, filename As String)
		If muted Then
			muted =False
		Else 
			muted = True
		End If
		If Not muted Then 
			currentmusic.LoadFile(filename)
			currentmusic.PlayLoop()
		Else 
			currentmusic.Stop()
		End If
	End Method
	
	Method MovePlayerMulti( p As player)
		Define buffer As Decimal = .50
		Define a As Integer = p.direction
		Define cellchanges As Boolean
		Define b As Boolean
		If iskeydown(p.upKey) Then
			p.setDirection(0)
			cellchanges = Not (ceiling(p.ypos) = ceiling(p.ypos-p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).up  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer And (Not cellchanges Or (getCell(round(p.xpos), floor(p.ypos - p.playerspeed)).down And cellchanges)) Then
				changeCharacterPositionMulti(round(p.xpos),p.ypos -p.playerSpeed, p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).up  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer Then
				changeCharacterPositionMulti(round(p.xpos),ceiling(p.ypos -p.playerSpeed), p)
			Else
				p.setDirection(a)
			End If
					
		End If
		//same for down, right, left
		If iskeydown(p.downKey) Then
			p.setDirection(2)
			cellchanges = Not (floor(p.ypos) = floor(p.ypos+p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).down  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer And (Not cellchanges Or (getCell(round(p.xpos), ceiling(p.ypos + p.playerspeed)).up And cellchanges)) Then
				changeCharacterPositionMulti(round(p.xpos),p.ypos +p.playerSpeed, p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).down  And abs(convertToDecimal(round(p.xpos)) -  p.xpos) <=buffer Then
				changeCharacterPositionMulti(round(p.xpos),floor(p.ypos +p.playerSpeed), p)
			Else
				p.setDirection(a)
			End If
		End If
			
			
		If iskeydown(p.rightKey) Then
			p.setDirection(1)
			cellchanges = Not(floor(p.xpos) = floor(p.xpos+p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).right  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer And (Not cellchanges Or (getCell(ceiling(p.xpos + p.playerspeed),round(p.ypos)).left And cellchanges))  Then
				changeCharacterPositionMulti(p.xpos +p.playerSpeed, round(p.ypos), p)	
			Else If getPlayerCell(p.xpos,p.ypos, p).right  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer Then
				changeCharacterPositionMulti(floor(p.xpos +p.playerSpeed), round(p.ypos), p)
			Else
				p.setDirection(a)
			End If
		End If
			
			
		If iskeydown(p.leftKey) Then
			p.setDirection(3)
			cellchanges = Not (ceiling(p.xpos) = ceiling(p.xpos-p.playerSpeed))
			If getPlayerCell(p.xpos,p.ypos, p).left  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer And (Not cellchanges Or (getCell(floor(p.xpos - p.playerspeed),round(p.ypos)).right And cellchanges))Then
				changeCharacterPositionMulti(p.xpos -p.playerSpeed, round(p.ypos), p)
			Else If getPlayerCell(p.xpos,p.ypos, p).left  And abs(convertToDecimal(round(p.ypos)) -  p.ypos) <=buffer Then
				changeCharacterPositionMulti(ceiling(p.xpos -p.playerSpeed), round(p.ypos), p)
			Else
				p.setDirection(a)
			End If
		End If
		
	End Method
	
	
	//scrolls amd displays game
	//really should be called display game, cause it rewrites the game from the ground up
	Method ScrollGame()
		Define n As Integer
		Define l As Level = currentlevel()
		BeginFrame()
		//displays enemies
		For n = 1 To arraylength(l.enemyset)
			//changepos
			l.enemyset[n].changepos(l.enemyset[n].xpos,l.enemyset[n].ypos, convertX(l.enemyset[n].xpos + character.startx-character.xpos), convertY(l.enemyset[n].ypos+ character.starty-character.ypos))
			////If in upper block Or inactive, hide, Else show
			//If l.enemyset[n].isburger Then
			//	l.enemyset[n].load()
			//	l.enemyset[n].changepos(l.enemyset[n].xpos,l.enemyset[n].ypos, convertX(l.enemyset[n].xpos + character.startx-character.xpos),convertY(l.enemyset[n].ypos+ character.starty-character.ypos) )
			//	If l.enemyset[n].psprite.y <= ygap And l.enemyset[n].psprite.y + l.enemyset[n].psprite.height > ygap+ 50 Then
			//		l.enemyset[n].psprite.cropToArea(0, ygap - l.enemyset[n].psprite.y ,100,100.0*( l.enemyset[n].psprite.y + l.enemyset[n].psprite.height - ygap)/l.enemyset[n].psprite.height)
			//		l.enemyset[n].changepos(l.enemyset[n].xpos,l.enemyset[n].ypos, convertX(l.enemyset[n].xpos + character.startx-character.xpos), ygap+(cellsize/2 - l.enemyset[n].psprite.Height/2 + 50.0*( l.enemyset[n].psprite.y + l.enemyset[n].psprite.height - ygap)/l.enemyset[n].psprite.height))
					
			//		l.enemyset[n].psprite.Show()
			//		delay(1000)
			//	Else If  l.enemyset[n].psprite.y + l.enemyset[n].psprite.height <= ygap Then
			//		l.enemyset[n].psprite.Hide()
			//	Else
			//		l.enemyset[n].psprite.Show()
			//	End If
			//Else 
			If (l.enemyset[n].psprite.y <=yGap And Not l.enemyset[n].isburger) Or Not l.enemyset[n].active  Then
				l.enemyset[n].psprite.Hide()
			Else If l.enemyset[n].active Then
				l.enemyset[n].psprite.show()
			End If
		Next
		//display character
		DisplayPlayer(character)
		
		//display and scroll good foods- see enemies
		
		Define foodsgone As Integer = 0
		For n = 1 To arraylength(l.goodfoods)
			l.goodfoods[n].changepos(l.goodfoods[n].xpos,l.goodfoods[n].ypos, convertX(l.goodFoods[n].xpos + character.startx-character.xpos), convertY(l.goodFoods[n].ypos+ character.starty-character.ypos))
			If convertY(l.goodFoods[n].ypos+ character.starty-character.ypos) <=yGap Or Not l.goodfoods[n].active Then
				l.goodFoods[n].psprite.Hide()
			Else If l.goodFoods[n].active Then
				currentlevel().goodFoods[n].psprite.show()
			End If
			If Not l.goodFoods[n].active Then
				foodsGone+=1
			End If
		Next
		//move maze
		MoveMaze()
		//set score - need to tweak
		character.setScore(diff*((character.lives-1)*1000 + 0+character.Health*10+character.goodFoodsHit*100-character.enemiesHit*200-abs(TotalGameTime)*5))
		//draw menu rectangle on top of screen
		//set
		Color(white)
		Pen(False)
		moveTo(0,0)
		Pen(True)
		Rectangle(screenwidth(), yGap, True )
		Color(Black)
		moveto(0,yGap-5)
		Rectangle(screenwidth(), 5, True )
		//draw health bars,etc.
		If character.health > 65 Then
			color(limegreen)
		Else If character.health >=35 Then
			color(yellow)
		Else If character.health >=0 Then
			healthbar.blink(red)
		Else 
			color(red)
		End If
		//fill in health bar
		healthbar.draw(convertTodecimal(1)-healthbar.converttodec(character.health, 100))
		//bdraw levelprogress bar
		Define dec As Decimal
		
		dec = convertToDecimal(l.totalfoods-foodsGone)
		dec = dec/convertToDecimal(l.totalfoods)
		If 1-dec> 2.0/3.0 Then
			color(limegreen)
		Else If 1-dec >1.0/3.0 Then
			color(yellow)
		Else 
			color(red)
		End If
		//color(limegreen)
		healthbar.loadbar(425 *screenwidth()/600,0,150*screenwidth()/600,25)
		progress.loadbar(225*screenwidth()/600,0,150*screenwidth()/600,25)
		timeBar.loadbar(25*screenwidth()/600,0,150*screenwidth()/600,25)
		progress.draw(1-dec)
		Pen(False)
		moveTO(0,40)
		print("Score: " + character.score)
		moveTo(100, 40)
		Print("Lives: ")
		//stamp number of lives
		For n = 1 To character.lives
			lifeSprite.MoveTo(150 + (n-1)*1.5*lifesprite.Width, 40)
			lifeSprite.Stamp()
		Next
		
		//draw timebar
		If ( l.time - totalGameTime)/(l.time) > 2.0/3.0 Then
			color(limegreen)
		Else If ( l.time - totalGameTime)/(l.time) > 1.0/3.0 Then
			color(yellow)
		Else
			timeBar.blink(red)
		End If
		timeBar.draw(( l.time - totalGameTime)/(l.time))
		RefreshScreen()
	End Method
	
	Method ScrollGameMulti(p As player[])
		Define n As Integer
		Define l As Level = currentlevel()
		BeginFrame()
		//displays enemies
		For n = 1 To arraylength(l.enemyset)
			//changepos
			l.enemyset[n].changepos(l.enemyset[n].xpos,l.enemyset[n].ypos, convertX(l.enemyset[n].xpos), convertY(l.enemyset[n].ypos))
			//if in upper block or inactive, hide, else show
			If convertY(l.enemyset[n].ypos) <=yGap  Then
				l.enemyset[n].psprite.Hide()
			Else If l.enemyset[n].active Then
				l.enemyset[n].psprite.show()
			Else If Not l.enemyset[n].active  And Not l.enemyset[n].waiting Then
				l.enemyset[n].dframe +=1
				l.enemyset[n].psprite.Hide()
				If l.enemyset[n].dframe > l.enemyset[n].deadFrames Then
					getnewPosition(l.enemyset[n], p, 2)
					l.enemyset[n].waiting = True
					l.enemyset[n].dframe = 0
				End If
			Else If l.enemyset[n].waiting Then
				l.enemyset[n].dframe+=1
				If l.enemyset[n].dframe Mod 10 <5 Then
					l.enemyset[n].psprite.show()
				Else	
					l.enemyset[n].psprite.Hide()
				End If
				If l.enemyset[n].dframe > l.enemyset[n].pauseframes Then
					//getnewPosition(l.enemyset[n], p, 2)
					l.enemyset[n].active = True
					l.enemyset[n].waiting = False
					l.enemyset[n].dframe = 0
				End If
			End If
		Next
		//display character
		For n = 1 To arraylength(players)
			DisplayPlayer(players[n])
			players[n].changepos(players[n].xpos,players[n].ypos, convertx(players[n].xpos), converty(players[n].ypos))
		Next
		//display and scroll good foods- see enemies
		
		//Define foodsgone As Integer = 0
		For n = 1 To arraylength(l.goodfoods)
			l.goodfoods[n].changepos(l.goodfoods[n].xpos,l.goodfoods[n].ypos, convertX(l.goodFoods[n].xpos), convertY(l.goodFoods[n].ypos))
			If convertY(l.goodfoods[n].ypos) <=yGap  Then
				l.goodfoods[n].psprite.Hide()
			Else If l.goodFoods[n].active Then
				l.goodFoods[n].psprite.show()
			Else If Not l.goodFoods[n].active Then
				l.goodfoods[n].psprite.Hide()
				l.goodfoods[n].dframe +=1
				If l.goodfoods[n].dframe > l.goodfoods[n].deadFrames Then
					getnewPosition(l.goodfoods[n], p, 2)
					l.goodfoods[n].active = True
					l.goodfoods[n].dframe = 0
				End If
			End If
		Next
		//move maze
		color(black)
		DrawMaze()
		//set score - need to tweak
		player1.setScore((0+player1.Health*10+player1.goodFoodsHit*100-player1.enemiesHit*200))
		player2.setScore((0+player2.Health*10+player2.goodFoodsHit*100-player2.enemiesHit*200))
		//draw menu rectangle on top of screen
		Color(white)
		Pen(False)
		moveTo(0,0)
		Pen(True)
		Rectangle(screenwidth(), yGap, True )
		Color(Black)
		moveto(0,yGap-5)
		Rectangle(screenwidth(), 5, True )
		
		healthbar1.loadbar(25, 0 , 150*screenwidth()/600, 25)
		healthbar2.loadbar(425, 0 , 150*screenwidth()/600, 25)
		timebar2.loadbar(225, 0 , 150*screenwidth()/600, 25)
		
		//draw health bars,etc.
		If player1.health > 65 Then
			color(limegreen)
		Else If player1.health >=35 Then
			color(yellow)
		Else
			healthbar1.blink(red)
		End If
		//fill in health bar
		healthbar1.draw(convertTodecimal(1)-healthbar.converttodec(player1.health, 100))
		//scores
		Pen(False)
		moveTO(0,40)
		print("Score1: " + player1.score)
		moveTO(500,40)
		print("Score2: " + player2.score)
		
		//draw timebar
		If ( l.time - totalGameTime)/(l.time) > 2.0/3.0 Then
			color(limegreen)
		Else If ( l.time - totalGameTime)/(l.time) > 1.0/3.0 Then
			color(yellow)
		Else
			timeBar2.blink(red)
		End If
		timeBar2.draw(( l.time - totalGameTime)/(l.time))
		If player2.health > 65 Then
			color(limegreen)
		Else If player2.health >=35 Then
			color(yellow)
		Else
			healthbar2.blink(red)
		End If
		healthbar2.draw(convertTodecimal(1)-healthbar.converttodec(player2.health, 100))
		RefreshScreen()
	End Method
	
	
	
	Method getnewPosition(e As enemy, p As Player[], distance As Integer)
		Define x As Integer
		Define y As Integer
		Define good As Boolean
		Define n As Integer
		Define l As Level = currentlevel()
		While Not good
			good = True
			x = random(1, l.columns)
			y = random(1, l.rows)
			If getCell(x,y).invalidloc Or getcell(x,y).containsEnemy Then
				good = False
			End If
			If good Then
				For n = 1 To arraylength(p)
					If abs(x - p[n].xpos) < distance +1 And abs(y - p[n].ypos) < distance +1Then
						good = False
					End If
				Next
			End If
			
		End While
		e.changepos(x,y)
		getcell(x,y).containsEnemy = True
	End Method
	
	Method getnewPosition(g As goodfood, p As Player[], distance As Integer)
		Define x As Integer
		Define y As Integer
		Define good As Boolean
		Define l As Level = currentlevel()
		Define n As Integer
		While Not good
			good = True
			x = random(1, l.columns)
			y = random(1, l.rows)
			If getCell(x,y).invalidloc Or getcell(x,y).containsgoodFood Then
				good = False
			End If
			If good Then
				For n = 1 To arraylength(p)
					If abs(x - p[n].xpos) < distance +1 And abs(y - p[n].ypos) < distance +1Then
						good = False
					End If
				Next
			End If
		End While
		g.changepos(x,y)
		getcell(x,y).containsgoodFood = True
	End Method
	
	//moves enemy
	//created by Kevin Meyer, 18Oct2009
	//move enemy comes in 3 stages
	//If enemy is at intersection
	//first, it  gets the order to check the directions = get possibles
	//second, it checks those directions in order, and checks to see which way it should move getEnemyDirections
	//third, it then moves either enemyspeed, or until it hits a wall.  
	
	//run this every frame
	Method MoveEnemy(e As Enemy, p As player)
		//If not at an intersection, con't change direction
		Define cellchanges As Boolean
		
		If abs((convertToDecimal(convertToInteger(e.xpos)) - e.xpos))< enemyspeed/2 And  abs((convertToDecimal(convertToInteger(e.ypos)) - e.ypos))< enemyspeed/2 Then
			//get new direction
			e.Direction = getEnemyDirection(e, p)
			
		End If
		//use direction to move.  
		If e.active Then
			Select e.Direction
				Case 0 
					//will the enemy change cells
					cellchanges = Not (ceiling(e.ypos) = ceiling(e.ypos-enemyspeed))
					//if it won't change cells or the new cell has no wall to bang up against, move normal
					If (Not cellchanges Or (getCell(round(e.xpos), floor(e.ypos - enemyspeed)).down And cellchanges)) Or e.isburger Then
						changeEnemyPosition(round(e.xpos),e.ypos -enemyspeed, e)	
					Else//else move until the wall
						changeEnemyPosition(round(e.xpos),ceiling(e.ypos - enemyspeed), e)
					End If
					
				End Case
				//repeats above for every other direction
				Case 1 
					cellchanges = Not (floor(e.xpos) = floor(e.xpos+enemySpeed))
					If (Not cellchanges Or (getCell(ceiling(e.xpos + enemyspeed),round(e.ypos)).left And cellchanges)) Or e.isburger Then
						changeEnemyPosition(e.xpos +enemyspeed, round(e.ypos),e)	
					Else
						changeEnemyPosition(floor(e.xpos +enemyspeed),round(e.ypos), e)
					End If
				End Case
			
				Case 2 
					cellchanges = Not (floor(e.ypos) = floor(e.ypos+enemySpeed))
					If (Not cellchanges Or (getCell(round(e.xpos), ceiling(e.ypos + enemyspeed)).up And cellchanges)) Or e.isburger Then
						changeEnemyPosition(round(e.xpos),e.ypos +enemyspeed, e)	
					Else
						changeEnemyPosition(round(e.xpos),floor(e.ypos + enemyspeed), e)
					End If
				End Case
			
				Case 3 
					cellchanges = Not (ceiling(e.xpos) = ceiling(e.xpos-enemySpeed))
					If (Not cellchanges Or (getCell(floor(e.xpos - enemyspeed),round(e.ypos)).right And cellchanges)) Or e.isburger Then
						changeEnemyPosition(e.xpos -enemyspeed, round(e.ypos),e)	
					Else
						changeEnemyPosition(ceiling(e.xpos - enemyspeed),round(e.ypos), e)
					End If
				End Case
			End Select
		Else
			e.psprite.Hide()
		End If
	End Method

	//returns enemy's direction
	//created by Kevin Meyer, 18Oct2009
	Function getEnemyDirection(e As enemy, p As Player) As Integer
		// gives order of directions
		Define directions As Integer[4] = getPossibles(e, p)
		
		Define counter As Integer
		For counter = 1 To 4
			//checks to see if can move in that direction
			//checks each of directions in order from getPossibles
			Select directions[counter]
				Case 0
					If getEnemyCell(e.xpos, e.ypos, 0).up Or e.isburger = True Then
						Return 0
					End If
				End Case
				
				Case 1
					If (getEnemyCell(e.xpos, e.ypos, 1).right Or e.isburger = True)Then
						Return 1
					End If
				End Case
				
				Case 2
					If getEnemyCell(e.xpos, e.ypos, 2).down Or e.isburger = True Then
						Return 2
					End If
				End Case
							
				Case 3
					If getEnemyCell(e.xpos, e.ypos, 3).left Or e.isburger = True Then
						Return 3
					End If
				End Case
				
					
			End Select
			//End If
		Next
		
		//If, you can't move, returns -12, will be rejected by moveEnemy
		Return -12
	End Function
	
	//This will return the order in which the directions should be checked
	//for enemy movement	
	//created by Kevin Meyer, 18Oct2009
	Function getPossibles(e As enemy, p As player) As Integer[]
		Define order As Integer[4]
		Define l As Level = currentlevel()
		Define deltax As Decimal = p.xpos - e.xpos
		Define deltay As Decimal = p.ypos - e.ypos
		//If within change, will attack player
		//outside will do random	
		
		//allows for wraparound
		If deltax > l.columns/2.0 Then
			deltax -=l.columns
		End If
		If deltax < -l.columns/2.0 Then
			deltax +=l.columns
		Else If deltay > l.rows/2.0 Then
			deltay -= l.rows
		Else If deltay < -l.rows/2.0 Then
			deltay += l.rows
		End If
		If abs(deltax)<=currentDifficulty().aiTransfer And abs(deltay)<=currentDifficulty().aiTransfer  OR e.isburger Then
			//build order - tries to head straight at you, then sort of perpendicular, then reverse perpendicular then away
			If abs(deltay)> abs(deltax) Then
				If deltay > 0 Then
					order[1] = 2
					order[4] = 0
					If deltaX > 0 Then
						order[2] = 1
						order[3] = 3
					Else
						order[3] = 1
						order[2] = 3
					End If
				Else
					order[4] = 2
					order[1] = 0
				
					If deltaX > 0 Then
						order[2] = 1
						order[3] = 3
					Else
						order[3] = 1
						order[2] = 3
					End If
				End If
			Else
				If deltax >0 Then
					order[1] = 1
					order[4] = 3
					If deltay > 0 Then
						order[2] = 2
						order[3] = 0
					Else
						order[3] = 2
						order[2] = 0
					End If
				Else
					order[4] = 1
					order[1] = 3
				
					If deltay > 0 Then
						order[2] = 2
						order[3] = 0
					Else
						order[3] = 2
						order[2] = 0
					End If
				End If
			End If
		Else
			//random walk
			//last priority is backwards
			//second is forwards
			//first and third are left/right- random order
			If e.Direction>1 Then
				order[4] = e.Direction - 2
			Else
				order[4] = e.Direction + 2
			End If
			order[2] = e.direction
			Define n As Integer = random(0,3)
			
			If n = order[4] Then
				n += 1
			Else If n = order[2] Then
				n += 1
			End If			
			If n >= 4 Then
				n -=4
			End If
		
			order[1] = n
			n+=2
			If n >= 4 Then
				n -=4
			End If
			order[3] = n
			
		
		End If
		//return the order
		Return order
	End Function
		
	
	Function getPossibles(e As enemy, p As player[]) As Integer[]
		Define order As Integer[4]
		Define i As Integer
		Define l As Level = currentlevel()
		Define closeAttack As Boolean = False
		Define deltax As Decimal = p[1].xpos - e.xpos
		Define deltay As Decimal = p[1].ypos - e.ypos
		For i = 1 To arraylength(p)
			Define deltaxt As Decimal = p[i].xpos - e.xpos
			Define deltayt As Decimal = p[i].ypos - e.ypos
			//If within change, will attack player
			//outside will do random	
		
			//allows for wraparound
			If deltax > l.columns/2.0 Then
				deltax -=l.columns
			End If
			If deltax < -l.columns/2.0 Then
				deltax +=l.columns
			Else If deltay > l.rows/2.0 Then
				deltay -= l.rows
			Else If deltay < -l.rows/2.0 Then
				deltay += l.rows
			End If
				
			If abs(deltax)<=currentDifficulty().aiTransfer And abs(deltay)<=currentDifficulty().aiTransfer Then
				closeAttack = True
				If deltax*deltax + deltay*deltay < deltaxt*deltaxt + deltayt*deltayt Then
					deltax = deltaxt
					deltay = deltayt
				End If
			End If
		Next
		If closeAttack Or e.isburger Then
			//build order - tries to head straight at you, then sort of perpendicular, then reverse perpendicular then away
			If abs(deltay)> abs(deltax) Then
				If deltay > 0 Then
					order[1] = 2
					order[4] = 0
					If deltaX > 0 Then
						order[2] = 1
						order[3] = 3
					Else
						order[3] = 1
						order[2] = 3
					End If
				Else
					order[4] = 2
					order[1] = 0
				
					If deltaX > 0 Then
						order[2] = 1
						order[3] = 3
					Else
						order[3] = 1
						order[2] = 3
					End If
				End If
			Else
				If deltax >0 Then
					order[1] = 1
					order[4] = 3
					If deltay > 0 Then
						order[2] = 2
						order[3] = 0
					Else
						order[3] = 2
						order[2] = 0
					End If
				Else
					order[4] = 1
					order[1] = 3
				
					If deltay > 0 Then
						order[2] = 2
						order[3] = 0
					Else
						order[3] = 2
						order[2] = 0
					End If
				End If
			End If
		Else
			//random walk
			//last priority is backwards
			//second is forwards
			//first and third are left/right- random order
			If e.Direction>1 Then
				order[4] = e.Direction - 2
			Else
				order[4] = e.Direction + 2
			End If
			order[2] = e.direction
			Define n As Integer = random(0,3)
			
			If n = order[4] Then
				n += 1
			Else If n = order[2] Then
				n += 1
			End If			
			If n >= 4 Then
				n -=4
			End If
		
			order[1] = n
			n+=2
			If n >= 4 Then
				n -=4
			End If
			order[3] = n
			
		
		End If
		//return the order
		Return order
	End Function
	//makes sure that cells that have enemies are true (in theory)- useless - don't quiz on
	Method updateContainsEnemy()
		Define counter As Integer
		Define onColumn As Boolean
		Define onRow As Boolean
		Define l As Level = currentlevel()
		For counter = 1 To arraylength(currentlevel().maze)
			l.maze[counter].containsEnemy = False
		Next
		For counter = 1 To arraylength(l.enemyset)
			If l.enemyset[counter].active Then
				Define x As Integer = l.enemyset[counter].xpos 
				Define y As Integer = l.enemyset[counter].ypos
				If onrow And oncolumn Then
					getCell(floor(x),floor(y)).containsEnemy = True
				Else If onrow Then
					getCell(ceiling(x),floor(y)).containsEnemy = True
					getCell(floor(x),floor(y)).containsEnemy = True	
				Else If oncolumn Then
					getCell(floor(x),floor(y)).containsEnemy = True
					getCell(floor(x),ceiling(y)).containsEnemy = True	
				Else	
					getCell(floor(x),floor(y)).containsEnemy = True
					getCell(floor(x),ceiling(y)).containsEnemy = True
					getCell(ceiling(x),floor(y)).containsEnemy = True
					getCell(ceiling(x),ceiling(y)).containsEnemy = True
				End If
			End If
 		Next
	End Method
	
	
	//makes sure that cells that have goodfoods are true (in theory)- useless - don't quiz on
	Method updateContainsGoodFoods()
		Define counter As Integer
		Define onColumn As Boolean
		Define onRow As Boolean
		Define l As Level = currentlevel()
		For counter = 1 To arraylength(currentlevel().maze)
			l.maze[counter].containsGoodFood = False
		Next
		For counter = 1 To arraylength(l.enemyset)
			If l.goodfoods[counter].active Then
				Define x As Integer = l.goodfoods[counter].xpos 
				Define y As Integer = l.goodfoods[counter].ypos
				If onrow And oncolumn Then
					getCell(floor(x),floor(y)).containsGoodFood = True
				Else If onrow Then
					getCell(ceiling(x),floor(y)).containsGoodFood = True
					getCell(floor(x),floor(y)).containsGoodFood = True	
				Else If oncolumn Then
					getCell(floor(x),floor(y)).containsGoodFood = True
					getCell(floor(x),ceiling(y)).containsGoodFood = True	
				Else	
					getCell(floor(x),floor(y)).containsGoodFood = True
					getCell(floor(x),ceiling(y)).containsGoodFood = True
					getCell(ceiling(x),floor(y)).containsGoodFood = True
					getCell(ceiling(x),ceiling(y)).containsGoodFood = True
				End If
			End If
 		Next
	End Method
	
	//creates maze - room for adding, might just copy and paste gencells into this
	//runs during levelcreation
	Method CreateMaze() 
		GenerateCells()
		
	End Method
	
	//this sets defaults and rows/ columns for the maze
	//created 14Oct2009 by Kevin Meyer
	Method GenerateCells()
		Define i As Integer
		Define l As Level = currentlevel()
		//creates default values = full maze
		For i = 1 To l.rows * l.columns
			l.Maze[i].left = False//can move through
			l.Maze[i].up = False//can't move up
			l.Maze[i].index = i-1//might be useful
			l.Maze[i].row = l.Maze[i].index/l.columns +1 //row			
			l.Maze[i].column = l.Maze[i].index + 1 - ((l.Maze[i].row-1)*l.columns)//columns
			l.Maze[i].xpos = l.Maze[i].column//starting xpos
			l.Maze[i].ypos = l.Maze[i].row//starting ypos
		Next
		
		//method for changing default left and up booleans - by hand or if needed, randomly
		removeWalls(l.removeLeft , l.removeUp, l.removeRight, l.RemoveDown)		
		
		//sets default right and down booleans using appropiate left and up booleans
		//don't forget wrap-around issues
		For i = 1 To l.rows * l.columns
			If l.Maze[i].row = l.rows Then 
				l.Maze[i].down = l.Maze[i - (l.rows*(l.columns -1))].up
			Else
				l.Maze[i].down = l.Maze[i + l.columns].up	
			End If
						
			If l.Maze[i].column = l.columns Then 
				l.Maze[i].right = l.Maze[i - l.columns + 1].left
			Else
				l.Maze[i].right = l.Maze[i + 1].left
				
			End If
		Next
		For i = 1 To arrayLength(l.invalidLocations)
			l.invalidLocations[i].invalidLoc = True
		Next
	End Method
	
	Function getEnemyDirection(e As enemy, p As Player[]) As Integer
		// gives order of directions
		Define directions As Integer[4] = getPossibles(e, p)
		
		Define counter As Integer
		For counter = 1 To 4
			//checks to see if can move in that direction
			//checks each of directions in order from getPossibles
			Select directions[counter]
				Case 0
					If getEnemyCell(e.xpos, e.ypos, 0).up  = True Then
						Return 0
					End If
				End Case
				
				Case 1
					If (getEnemyCell(e.xpos, e.ypos, 1).right = True)Then
						Return 1
					End If
				End Case
				
				Case 2
					If getEnemyCell(e.xpos, e.ypos, 2).down = True Then
						Return 2
					End If
				End Case
							
				Case 3
					If getEnemyCell(e.xpos, e.ypos, 3).left = True Then
						Return 3
					End If
				End Case
				
					
			End Select
			//End If
		Next
		
		//If, you can't move, returns -12, will be rejected by moveEnemy
		Return -12
	End Function
	
	
	Method MoveEnemy(e As Enemy, p As player[])
		//If not at an intersection, con't change direction
		Define cellchanges As Boolean
		
		If abs((convertToDecimal(convertToInteger(e.xpos)) - e.xpos))< enemyspeed/2 And  abs((convertToDecimal(convertToInteger(e.ypos)) - e.ypos))< enemyspeed/2 Then
			//get new direction
			e.Direction = getEnemyDirection(e, p)
			
		End If
		//use direction to move.  
		If e.active Then
			Select e.Direction
				Case 0 
					//will the enemy change cells
					cellchanges = Not (ceiling(e.ypos) = ceiling(e.ypos-enemyspeed))
					//if it won't change cells or the new cell has no wall to bang up against, move normal
					If (Not cellchanges Or (getCell(round(e.xpos), floor(e.ypos - enemyspeed)).down And cellchanges)) Then
						changeEnemyPosition(round(e.xpos),e.ypos -enemyspeed, e)	
					Else//else move until the wall
						changeEnemyPosition(round(e.xpos),ceiling(e.ypos - enemyspeed), e)
					End If
					
				End Case
				//repeats above for every other direction
				Case 1 
					cellchanges = Not (floor(e.xpos) = floor(e.xpos+enemySpeed))
					If (Not cellchanges Or (getCell(ceiling(e.xpos + enemyspeed),round(e.ypos)).left And cellchanges))  Then
						changeEnemyPosition(e.xpos +enemyspeed, round(e.ypos),e)	
					Else
						changeEnemyPosition(floor(e.xpos +enemyspeed),round(e.ypos), e)
					End If
				End Case
			
				Case 2 
					cellchanges = Not (floor(e.ypos) = floor(e.ypos+enemySpeed))
					If (Not cellchanges Or (getCell(round(e.xpos), ceiling(e.ypos + enemyspeed)).up And cellchanges)) Then
						changeEnemyPosition(round(e.xpos),e.ypos +enemyspeed, e)	
					Else
						changeEnemyPosition(round(e.xpos),floor(e.ypos + enemyspeed), e)
					End If
				End Case
			
				Case 3 
					cellchanges = Not (ceiling(e.xpos) = ceiling(e.xpos-enemySpeed))
					If (Not cellchanges Or (getCell(floor(e.xpos - enemyspeed),round(e.ypos)).right And cellchanges))  Then
						changeEnemyPosition(e.xpos -enemyspeed, round(e.ypos),e)	
					Else
						changeEnemyPosition(ceiling(e.xpos - enemyspeed),round(e.ypos), e)
					End If
				End Case
			End Select
		Else
			e.psprite.Hide()
		End If
	End Method
	//will remove the left walls of all the positions in removeLeft, and all the upper walls in RemoveUp
	//created 12:56 AM 15OCT2009 by Kevin Meyer
	//edited 2:35 Pm, 15Oct2009 by Kevin Meyer - added removeRight and Down
	Method removeWalls(removeLeft As Cell[], removeUp As Cell[],removeRight As Cell[],removeDown As Cell[])
		Define n As Integer
		//removes the left walls from these cells
		If ArrayLength(removeLeft)>0 Then 
			For n = 1 To ArrayLength(removeLeft)
				removeLeft[n].left = True
			Next
		End If
		
		//right walls
		If ArrayLength(removeRight)>0 Then 
			For n = 1 To ArrayLength(removeRight)
				getCell(removeRight[n].column + 1, removeRight[n].row).left = True
			Next
		End If
		
		
		//upper walls
		If ArrayLength(removeUp)>0 Then
			For n = 1 To ArrayLength(removeUp)
				removeUp[n].up = True
			Next
		End If
		
		//down walls
		If ArrayLength(removeDown)>0 Then 
			For n = 1 To ArrayLength(removeDOwn)
				getCell(removeDown[n].column, removeDown[n].row + 1).up = True
			Next
		End If
	End Method
	
	//adds goodFoods to the appropriate level
	//called in initGame during level creation
	Function addGoodFoods(pts As cell[], pic As String) As goodfood[]
		Define i As Int
		Define i2 As Integer
		Define x As Integer
		Define y As Integer
		Define valid As Boolean
		Define loc As goodfood[arraylength(pts)]
		//puts goodfoods into cells in pts
		For i = 1 To arraylength(pts)
			Define g As goodfood
			g.loadFood(pts[i].column,pts[i].row,pic, cellsize)
			loc[i] = g
		Next
		
		Return loc
	End Function
	
	//draws maze, cell by cell
	//created 14Oct2009 by Kevin Meyer
	Method DrawMaze()
		Define l As Level = currentlevel()
		clearBackground(l.backgroundcolor)
		Define i As Integer
		penwidth(2)//sets penwidth = 2
		//draws cell
		For i =  1 To l.rows*l.columns
			DrawCell(l.Maze[i])
		Next
	End Method
	
	//draws an individual cell TheCell at it's location
	//created 14Oct2009 by Kevin Meyer
	Method DrawCell(TheCell As Cell)
		//converts columns and rows to x and y
		Define x As Integer= ConvertX(theCell.xpos)
		Define y As Integer = ConvertY(theCell.ypos)
		Define l As Level = currentLevel()
	
		//fills in invalid location cells
		If theCell.invalidLoc Then
			color(l.cellcolor)
			//setOpacity(50)
			Pen(False)
			moveTo(x,y)
			Pen(True)
			Rectangle(cellsize,cellsize,True)
			If thecell.left Then
				DrawLine(x,y,x,y+cellsize)
			End If
			If  thecell.up Then
				DrawLine(x,y,x+cellSize,y)
			End If
			
			
		End If
		color(l.linecolor)
		//draws upper wall if needed
		If Not theCell.up Then
			DrawLine(x,y,x+cellSize,y)
		End If	
		//draws left wall, if needed
		If Not TheCell.left Then
			DrawLine(x,y,x,y+cellsize)
		End If
		If thecell.column = l.columns And Not thecell.right Then
			DrawLine(x+cellsize,y,x+cellsize,y+cellsize)
		End If
		If thecell.row = l.rows And Not thecell.down Then
			DrawLine(x,y+cellsize,x+cellsize,y+cellsize)
		End If
		//right and lower wall will be taken care of by appropriate adjacent cells
		
		
		//will draw cell coordinates in cell when uncommented - useful dev tool
		If IsKeydown("Z") Then
			Pen(False)
			moveTo(x, y)
			Print("("+ theCell.column + "," + theCell.row + ")")
			Pen(True)
		End If
	End Method
	
	//returns cell in (column,row)
	//created 14Oct2009 by Kevin Meyer
	//called everywhere
	Function getCell( col As Integer, ro As Integer) As Cell
		//calls cell given inputted coordinates
		Return currentlevel().Maze[getI(col,ro)]
	End Function
	
	//deals with decimal player location to integer cell location issues
	//uses direction to return appropriate cell
	Function GetPlayercell(col As Decimal, ro As Decimal, p As player) As Cell
		Define l As Level = currentlevel()
		//
		If p.direction = 0 Then 
			Return l.Maze[getI(round(col),ceiling(ro))]
		Else If p.direction = 1 Then 
			Return l.Maze[getI(floor(col),round(ro))]
		Else If p.direction = 2 Then 
			Return l.Maze[getI(round(col),floor(ro))]
		Else	
			Return l.Maze[getI(ceiling(col),round(ro))]
		End If
	End Function
	
	//returns enemies cell, based upon decimal location and direction
	//created by Kevin Meyer, 17Oct2009
	Function GetEnemyCell(col As Decimal, ro As Decimal,direction As Integer) As Cell
		
		Define l As Level = currentlevel()
		If direction = 0 Then 
			Return l.Maze[getI(round(col),ceiling(ro))]
		Else If direction = 1 Then 
			Return l.Maze[getI(floor(col),round(ro))]
		Else If direction = 2 Then 
			Return l.Maze[getI(round(col),floor(ro))]
		Else	
			Return l.Maze[getI(ceiling(col),round(ro))]
		End If
	End Function
	
	//assumes position is in maze or will stop program
	//created 14Oct2009 by Kevin Meyer
	//(15Oct09, Boshen)changed parameters and return values slightly to work with changepos
	//returns appropriate array location given cell coordinates
	Function getI(col As Integer, ro As Integer) As Integer
		//position must be in maze, edits for wraparound
		Define l As Level = currentLevel()
		If col<=0.5 Then
			col += l.columns
		End If
		If col>l.columns+.5 Then
			col-= l.columns
		End If
		If ro<=0.5 Then
			ro+=l.rows
		End If
		If ro> l.rows +.5 Then
			ro-=l.rows
		End If
		//returns appropriate array location given cell coordinates
		Return l.columns * (ro-1) + col			

	End Function
	
	
	//use this to change the characters position 
	//created by Boshen Wang, 15Oct2009
	//deals with wraparounds
	Method changeCharacterPosition(x As Decimal, y As Decimal, p As player)
		Define l As Level = currentLevel()
		If x <= .5 Then
			x += l.columns
		Else If x - .5 > l.columns Then
			x -= l.columns
		End If
		If y <= .5 Then
			y += l.rows
		Else If y-.5 > l.rows Then
			y -= l.rows 
		End If
		p.changepos(x,y, Convertx(p.startx), convertY(p.starty))
		
	End Method
	
	Method changeCharacterPositionMulti(x As Decimal, y As Decimal, p As player)
		Define l As Level = currentLevel()
		If x <= 1 Then
			x += l.columns
		Else If x - 1 > l.columns Then
			x -= l.columns
		End If
		If y <= .5 Then
			y += l.rows
		Else If y-.5 > l.rows Then
			y -= l.rows 
		End If
		p.changepos(x,y)
		
	End Method
	
	//created by Boshen Wang, 15Oct2009
	//edited by Kevin Meyer, 16Oct2009 for new decimal format
	//will change position to x and y, will not redraw
	//redraw in scrollgame
	Method changeEnemyPosition(x As Decimal, y As Decimal,e As enemy)
		Define l As Level = currentLevel()
		If x <= .5 Then
			x = l.columns +.5
		Else If x - .5 >= l.columns Then
			x = .5
		End If
		If y <= .5 Then
			y=l.rows +.5
		Else If y-.5 >= l.rows Then
			y = .5
		End If
		e.changepos(x,y)
	End Method
	
	//combo of really bad progress screen and general holding pin at end of level
	//just a transition
	Method PlayAgain()
		Define a As String = getKey()
		If Not haswon Then 
			character.SetScore(0)
		End If
		savefile.save(profile)
		savefile.save()
		leavecurrentlevel()
		If haswon Then
			displayQuestion(currentlevel().questions[Random(1,5)])
		End If
		//profile.totalScores = 
		//a is used to see if the last key was q => exit to levelselect
		
		updateunlockables(True, False)
		If profile.scores[clevel,diff] < character.score  And haswon Then
			profile.scores[clevel,diff] = character.score
			//loadHighScore(character.score)
		End If
		//leaves level
		
		//displays console
		ShowConsole()
		
		//win or lose- act and display accordingly
		If hasWon And currentlevel() = level5 Then
			ConsoleWrite("Congratulations.\nYou beat Burger Bob!\n" + "Total Score: " + character.totalScore(diff,profile)+"\n")
			
			loadHighScore(character.score)
			loadTotalHighScore(character.totalScore(diff,profile))
		Else If haswon Then
			ConsoleWrite("You beat " + toString(clevel))
			ConsoleWrite("\n"+ convertToclock(totalGameTime)+"\nTotal Enemies Hit: " + character.enemiesHit + "\nTotal Good Foods Eaten: " + character.goodFoodsHit + "\nFInal Health: " + character.health + "\nMax Health: " + character.maxHealth + "\nMin Health: " + character.minHealth + "\nScore:"+ character.score+ "\nTotal Score: "+ character.totalscore(diff,profile) + "\n")
			loadHighScore(character.score)
			loadTotalHighScore(character.totalScore(diff,profile))
		Else
			character.lives -= 1
			ConsoleWrite("You Lost")
			ConsoleWrite("\nTotal Enemies Hit: " + character.enemiesHit + "\nTotal Good Foods Eaten: " + character.goodFoodsHit + "\n")//FInal Health: " + character.health + "\nMax Health: " + character.maxHealth + "\nMin Health: " + character.minHealth + "\nScore:"+ character.score+ "\nTotal Score: "+ character.totalscore(diff,profile) + "\n")
			If character.lives>0 Then
				COnsoleWriteLine("Tries Remaining: "+ character.lives)
			Else 
				ConsoleWriteLine("You Lost")
			End If
		End If
		//write progress
		If (character.enemiesHit > 5 Or Not haswon)  And Not a = "q" Then
			consolewrite("\nTry not to eat so many bad foods next time")
		End If
		If (totalgametime>= currentlevel().time)  And Not a = "q" Then
			consolewrite("\nTry to get the good foods faster next time")
		End If
		
		
		//wipe old input
		clearMouseEvents()
		clearKeyboardEvents()
		//wait for input to advance
		ConsoleWrite("\n\nHit any key to continue\n")
		//elim keypress
		If character.lives>0  And Not hasWon Then
			ConsoleWrite("or Q To quit")
		End If
		While Not mouse.Event = "ButtonDown" And getKey() = ""
			delay(1)
		End While
		If isKeyDown("q") Or getKey() = "q" Then
			a = "q"
		End If
		HideConsole()
		ClearConsole()
		
		//if quit is neccessary, then exit to levelselect
		If (character.lives <=0  Or a = "q"  Or haswon) Then
			currentmenu = "levelselect"
		End If
		If currentlevel() = level5 And haswon Then
			showHighScores(True)
			
			//If diff = 5 Then
			credstring = "Credits.png"
				scrollCredits(credString, credmusic)
			//End If
		End If
		savefile.save(profile)
		savefile.save()
	End Method
	
	//will display question
	Method DisplayQuestion( q As question)
		//init
		
		Define tempscreenwidth As Integer = screenwidth()
		Define tempscreenheight As Integer = screenheight()
		Define correct As Boolean//answer question correctly
		Define buttonpressed As Boolean = False
		clearbackground(black)
		q.displayQuestion()
		//while no input, do nothing\
		clearmouseevents()
		While  Not mouse.Event = "ButtonDown"
			If isKeyDown("m")  And Not Mpressed Then
				
				mute()
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If Not (tempscreenwidth = screenwidth() And tempscreenheight = screenheight()) Then
				clearbackground(black)
				q.displayQuestion()
				tempscreenwidth = screenwidth()
				tempscreenheight = screenheight()
			End If
			delay(1)
		End While
		//check for input
		Define i As Integer
		//which button did you press
		While Not buttonpressed
			For i = 1 To arraylength( q.buttons)
				If q.buttons[i].isclicked() Then
					buttonpressed = True
					//did you get it right
					correct = q.checkanswer(i)
					//if you got it right, then add to score
					If correct Then
						character.setscore(character.score+ diff* 1000)
					End If
				End If
			Next
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(currentlevel().music,currentlevel().mus)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If Not (tempscreenwidth = screenwidth() And tempscreenheight = screenheight()) Then
				clearbackground(black)
				q.displayQuestion()
				tempscreenwidth = screenwidth()
				tempscreenheight = screenheight()
			End If
			delay(1)
			 
		End While
		q.backgroundSprite.Hide()
		//display feedback
		q.displayfeedback(correct)
		//wait for input
		clearmouseevents()
		clearkeyboardevents()
		While  Not mouse.Event = "ButtonDown" And getkey() = ""
			If isKeyDown("m")  And Not Mpressed Then
				
				mute()
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			delay(1)
		End While
		//unload question
		q.unloadquestion()
	End Method
	
	//show highscores in text format
	Method ShowHighScores(word As Boolean)
		//at the moment, just displays total high scores
		Define levelnum As Integer
		Define diffnum As Integer
		Define rank As Integer
		
		
		//display highscores
		clearbackground(yellow)
		
		//display highscores
		SetFont ( "Arial", 20, False, False, False )
		Pen(False)
		moveto(0,0)
		For levelnum = arraylength(savefile.highscores, 1) To arraylength(savefile.highscores, 1)
			For diffnum = 1 To arraylength(savefile.highscores, 2)
				SetFont ( "Arial", 20, False, False, True )
				PrintLine(DiffString(diffnum))
				SetFont ( "Arial", 20, False, False, False )
				PrintLine( savefile.highscores[levelnum, diffnum].name + " " + savefile.highscores[levelnum, diffnum].score+"\n")
			Next
		Next
		If word Then
			
			PrintLine("")
			Printline("Press any key to continue")
		Else
			SetFont ( "Arial", 10, False, False, False )
			Return
		End If
		clearkeyboardevents()
		clearmouseevents()
		//wait for input
		While Not mouse.Event = "ButtonDown" And getKey() = ""
			delay(1)
			If isKeyDown("m")  And Not Mpressed Then
				
				mute()
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
		End While
		SetFont ( "Arial", 10, False, False, False )
		//clearbackground(white)
	End Method
	
	Method checkscreen()
		If Not screenwidth() = 600 Or Not screenheight() = 600 Then
			setscreensize(600,600)
		End If
	End Method
	
	//returns difficulty as string based on inputed integer
	Function DiffString(n As Integer) As String
		If n = 1 Then
			Return "Training"
		Else If n = 2 Then
			Return "Easy"
		Else If n = 3 Then
			Return "Normal"
		Else If n = 4 Then
			Return "Hard"
		Else 
			Return "Unfair"
		End If
	End Function
	
	//adds high score to high score array, if it goes in
	Method LoadHighScore(newScore As Int)
		//if greater than current, add
		If newScore > savefile.highScores[clevel, diff].score Then
			savefile.highscores[clevel,diff].name =profile.name
			savefile.highscores[clevel,diff].score = newScore
		End If
		
	End Method
	
	//adds total high score to high scores if it fits
	Method LoadtotalHighScore(newScore As Int)
		//if greater than current, add
		If newScore > savefile.highScores[arraylength(savefile.highscores,1), diff].score Then
			savefile.highscores[6,diff].name =profile.name
			savefile.highscores[6,diff].score = newScore
		End If
		
	End Method
	
	Function PrintHighScores() As String
		Define a As String
		Define i As Integer
		a +=savefile.highscores[clevel,diff].score + " " 
		Return a
	End Function
	//combo of really bad progress screen and general holding pin at end of level
	//just a transition
	Method PlayAgainMulti()
		leavecurrentlevel()
		ShowConsole()
		//write progress
		ConsoleWrite("Player 1's score: " + player1.score + "\n" + "Player 2's score: " + player2.score +"\n" )
		If player1.score> player2.score Then
			ConsoleWrite("Player 1 won")
		Else If player1.score= player2.score Then
			ConsoleWrite("It was a tie")
		Else
			ConsoleWrite("Player 2 won")
		End If
		//wipe old input
		clearMouseEvents()
		clearKeyboardEvents()
		//wait for input to advance
		ConsoleWrite("\nHit any key to continue\n")
		
		//elim keypress
		//DElay(500)
		
		While Not mouse.Event = "ButtonDown" And getKey() = ""
			delay(1)
		End While
		HideConsole()
		ClearConsole()
		
		//if quit is neccessary, then exit to levelselect
		
		currentmenu = "LevelSelectMulti"
	End Method
	
	
	//provides level string
	Function toString(l As Integer) As String
		Return "level " + l
	End Function
	
	//converts gametime to clock for progress screen
	Function convertToClock(l As Decimal) As String
		Define minutes As Integer = 0
		Define Seconds As Integer = 0
		While l>= 60
			minutes += 1
			l -= 60
		End While
		While l>= 1 
			seconds +=1
			l-=1
		End While
		If seconds < 10 Then
			Return minutes +":0" + seconds
		Else 
			Return minutes +":" + seconds
		End If
		
		//return("1:00")
	End Function
	
	//unloads all of currentlevel
	//pulls most of the sprites out of memory
	Method leaveCurrentLevel()
		//unloads lifesprite
		lifeSprite.Unload()
		//wipes background
		clearBackground(white)
		Define l As Level = currentlevel()
		Define counter As Integer
		//unloads enemies
		For counter = 1 To arrayLength(l.enemyset)
			If l.enemyset[counter].isLoaded Then 
				l.enemyset[counter].unload()
			End If
		Next
		//unloads goodfoods
		For counter = 1 To arraylength(l.goodFoods)
			If l.goodFoods[counter].isLoaded Then
				l.goodFoods[counter].unload()
			End If
		Next
		//unloads player(s)
		If l.type = 2 Then
			If player1.hasBeenLoaded Then
				player1.psprite.unload()
			End If
			If player2.hasBeenLoaded Then
				player2.psprite.unload()
			End If
		Else
			If character.hasBeenLoaded Then
				character.psprite.unload()
			End If
		End If
		l.foodseaten=0
		//unloads all the various progress bars
		If progress.isloaded Then 
			progress.icon.Hide()
		End If
		If healthbar.isloaded Then
			healthbar.icon.Hide()
		End If
		If timebar.isloaded Then
			timebar.icon.Hide()
		End If
		If timebar2.isloaded Then
			timebar2.icon.Hide()
		End If
		If healthbar1.isloaded Then
			healthbar1.icon.Hide()
		End If
		If healthbar2.isloaded Then
			healthbar2.icon.Hide()
		End If
		
		
		
	End Method
	
	
	//will convert xpos in maze to xpos in plot
	//created 10:29AM 15Oct2009 by Kevin Meyer
	Function ConvertX(x As Decimal) As Integer
		Define l As Level = currentLevel()
		//overlap issues
		While x> l.columns +.5
			x -= l.columns
		End While
		While x <=.5
			x += l.columns
		End While
		//centers in plot
		Return (x * CellSize) - CellSize+2 + (screenwidth())/2 - cellsize*l.columns/2.0
	End Function
	
	//will convert ypos in maze to ypos in plot
	//created 10:29AM 15Oct2009 by Kevin Meyer
	Function ConvertY(y As Decimal) As Integer
		Define l As Level = currentLevel()
		//change
		While y> l.rows +.5
			y -= l.rows
		End While
		While y <=.5
			y += l.rows
		End While
		//pops out position centered in plot
		Return (y * CellSize) - CellSize + yGap + (screenHeight()-yGap)/2 - cellsize*l.rows/2.0
	End Function
	
	
	//(20Oct09,Boshen) method will check if the player has been caught by an enemy
	
	Function caught(enemySet As enemy[], p As player) As Boolean
		Define i As Integer
		p.hasBeenHit = False//player can only be hit once per frame
		Define intersect As Boolean = False
		For i = 1 To arrayLength(enemySet)
			Define e As Enemy = enemySet[i]
			If e.active  And  intersectsPlayer(e, p) Then// if still alive and intersects player
				If Not e.IsBurger Then
					e.active = False//not alive
				End If
				//If Not p.hasBeenHit Or e.IsBurger Then// If first hit
				If e.isBurger Then 
					p.setPlayerHealth(0)//hurt player
				Else 
					If diff = 4 And currentDifficulty().enemyHurt = 0 Then
						Define g As goodFood
					End If//hurt player
					If currentlevel().type = 1 Then
						p.setPlayerHealth( p.health - (currentDifficulty().enemyHurt * (1.0- .5 * character.goodFoodsHit/currentlevel().totalfoods)))
					Else 
						p.setPlayerHealth( p.health - currentDifficulty().enemyHurt)
					End If
					p.hasbeenHit = True//can't be hit
					//End If
					p.enemiesHit+=1//hit += 1
					intersect = True//yes, you intersected so play enemysound
				End If
			End If
		Next
		Return intersect//did you inntersect an enemy
	End Function
	
	
	//does player intersect enemy
	Function intersectsPlayer(e As enemy, p As player) As Boolean
		//within one cell or sprites intersected
		If ((abs(p.xpos-e.xpos) < hitDistance And abs(p.ypos-e.ypos)< hitDistance))Or(((e.IsBurger And (abs(p.xpos-e.xpos) < 2 And abs(p.ypos-e.ypos)< 2)))) Or (p.psprite.Intersects(e.psprite)) Then
			Return True
		End If
		Return False
	End Function
	
	Define bgmusic As String = "shopvac.wav"
	Define levelmusic As String = "level.wav"
	Define diffmusic As sound
	Define diffmus As String = "level2.wav"
	//loads selected menu - q equals advance
	Method loadcurrentmenu()
		//sounds are various music
		//sends to main		
		If currentmenu = "main" Then
			//reloads music 
			mainmenu(background2, "shopvac.wav")
			//sends to levelselect
		Else If currentmenu = "levelselect" Then
			//reloads music
			levelselect(background2, levelmusic)
			//sends to difficulty
		Else If currentmenu = "difficulty" Then
			savefile.save(profile)
			savefile.save()
			difficultymenu(diffmusic, diffmus)
		Else If currentmenu = "profileselect" Then
			profileselect(diffmusic, diffmus)
		Else If currentmenu = "gametype" Then
			typemenu(diffmusic, diffmus)
		Else If currentmenu = "levelselectMulti" Then
			//reloads music
			background.LoadFile("level2.wav")
			background2.LoadFile("level.wav")
			levelselectMulti(background2, levelmusic)
		Else If currentmenu = "difficultyMulti" Then
			background.LoadFile("level2.wav")
			background2.LoadFile("level.wav")
			difficultymenuMulti(diffmusic, diffmus)
		Else If currentmenu = "characterSelect" Then
			background.LoadFile("level2.wav")
			background2.LoadFile("level.wav")
			characterSelect(diffmusic, diffmus)
		Else If currentmenu = "highscore" Then
			displayHighScores()
			currentmenu = "main"
		Else If currentmenu = "credits" Then
			credstring = "credits2.png"
			scrollCredits(credString, credmusic)
			currentmenu = "main"
		Else If currentmenu = "tutorial" Then
			playtutorial()
			currentmenu = "main"
		End If
		

	End Method	
	
	
	Define donutlocked As Boolean = True
	Define sodalocked As Boolean = True
	Define burgerlocked As Boolean = True
	Define friesLocked As Boolean = True
	
	Method characterselect(music As sound, file As String)
		Define tempScreenwidth As Integer = screenwidth()
		Define tempScreenheight As Integer = screenheight()
		Define enterpressed As Boolean = False
		Define spacepressed As Boolean = False
		Define meatloaf As button
		Define nurse As button
		Define levelselect As button
		Define player1i As Sprite
		Define player2i As sprite
		Define buttons As button[2,4]
		Define types As Integer[6] = {1,0,2,3,4,5, 6,7}
		Define pics As String [] = {"Dr. Meatloaf Front.png","Levelselect.png","Nurse Front.png", "Potato Bag.png", "donut.png", "Fries.png","Soda.png","Burger.png"}
		Define title As Sprite
		
		clearbackground(steelblue)

		pen(False)
		moveto(0,0)
		If donutlocked Then
			buttons[2,1].active=False
		End If
		If frieslocked Then
			buttons[2,2].active=False
		End If
		If	sodalocked Then
			buttons[2,3].active=False
		End If
		If burgerlocked Then
			buttons[2,4].active=False
		End If
		
		Define i As Integer
		Define i2 As Integer
		For i = 1 To arraylength(buttons,1) 
			For i2 = 1 To arraylength(buttons,2)
				buttons[i,i2].loadbutton(screenwidth()/2  +25/2 -150*(arraylength(buttons,2))/2 + 150*(i2-1),screenheight()/2 +25-175*(arraylength(buttons,1))/2+ 175 *(i-1), pics[arraylength(buttons,2)*(i-1) + i2])
				buttons[i,i2].buttonpic.Scale(100 *125/buttons[i,i2].buttonpic.width, 100 *125/buttons[i,i2].buttonpic.height)
				buttons[i,i2].buttonpic.Stamp()
				buttons[i,i2].buttonpic.hide()
			Next
		Next
		Define x As Sprite
		x.Load("locked.png")
		Define player1Selected As Boolean = False
		Define player2selected As Boolean = False
		Define player1location As Integer[] = {1,1}
		Define player2location As Integer[] = {1,3}
		
		
		player1i.Load("p1.png")
		Player2i.Load("p2.png")
	
		player1i.Hide()		
		player1i.Scale(100 * 30/player1i.Width, 100 * 30/player1i.Height)
		player1i.MoveTo(buttons[Player1Location[1],Player1Location[2]].buttonpic.x, buttons[Player1Location[1],Player1Location[2]].buttonpic.y)
		player1i.Show()
		
		player2i.Hide()
		player2i.Scale(100 * 30/player2i.Width, 100 * 30/player2i.Height)
		player2i.MoveTo(buttons[Player2Location[1],Player2Location[2]].buttonpic.x+ player1i.width, buttons[Player2Location[1],Player2Location[2]].buttonpic.y)
		player2i.show()
		title.Load("Characterselect.png")
		title.MoveTo(150-(300 - screenwidth()()/2),10-(300 - screenheight()/2))
		title.stamp()
		For i = 1 To arraylength(buttons,1) 
			For i2 = 1 To arraylength(buttons,2)
				If Not buttons[i,i2].active Then
					pen(False)
					x.Hide()
					x.moveTo(buttons[i,i2].buttonpic.x, buttons[i,i2].buttonpic.y)
					x.Stamp()
				End If
			Next
		Next
		Pen(False)
		MoveTo(300 - screenwidth()/2, 475 -(300 - screenheight()/2))
		SetFont ( "Arial", 15, False, False, False )
		Print("Player 1 uses WASD, and Player 2 uses the arrow keys.  \nPress Space to select Player 1, and Enter to select Player 2")
		SetFont ( "Arial", 10, False, False, False )
		While Not Player1selected Or Not Player2selected 
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(music, file)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If isKeyDown(Space) And Not spacepressed And Not ( Not player1selected And player2selected And player1location[1] = player2location[1] And player1location[2] = player2location[2]) Then
				player1selected = Not player1selected
				If player1selected Then
					player1.type = types[(player1location[1]-1)*arraylength(buttons,2)+ player1location[2]]
					player1i.opacity = 50
					If player1.type = 0 Then
						currentmenu = "levelselectMulti"
						For i = 1 To arraylength(buttons,1) 
							For i2 = 1 To arraylength(buttons,2)
								buttons[i,i2].buttonpic.Unload()
							Next
						Next
						player1i.Unload()
						player2i.Unload()	
						title.Unload()
						clearbackground(white)
						delay(100)
						Return
					End If
				Else 
					player1i.opacity = 100
				End If
				spacepressed = True
			Else If Not isKeyDown(space) Then
				spacepressed = False
			End If
			If  Not Player1selected And isKeyDown(player1.rightKey)  And buttons[Player1Location[1],(Player1Location[2] Mod arraylength(buttons,2))+1].active Then
				player1location[2]+=1
				If player1location[2] > arraylength(buttons,2) Then
					player1location[2] -=arraylength(buttons,2)
				End If	
			Else If	Not Player1selected And isKeyDown(player1.leftKey) And buttons[Player1Location[1],((Player1Location[2]-2 + arraylength(buttons,2)) Mod arraylength(buttons,2))+1].active Then
				player1location[2]-=1
				If player1location[2] < 1 Then
					player1location[2] +=arraylength(buttons,2)
				End If
			Else If	Not Player1selected And isKeyDown(player1.upKey) And buttons[((Player1Location[1]-2 + arraylength(buttons,1)) Mod arraylength(buttons,1))+1,Player1Location[2]].active Then
				player1location[1]-=1
				If player1location[1] < 1 Then
					player1location[1] +=arraylength(buttons,1)
				End If
			Else If	Not Player1selected And isKeyDown(player1.downKey)And buttons[(Player1Location[1] Mod arraylength(buttons,1))+1,Player1Location[2]].active Then
				player1location[1]+=1
				If player1location[1] > arraylength(buttons,1) Then
					player1location[1] -=arraylength(buttons,1)
				End If
			End If
			
			If isKeyDown(Enter) And Not enterpressed And Not (Not player2selected And player1selected And player1location[1] = player2location[1] And player1location[2] = player2location[2]) Then
				player2selected = Not player2selected
				If player2selected Then
					player2.type = types[(player2location[1]-1)*arraylength(buttons,2)+ player2location[2]]
					player2i.opacity = 50
					If player2.type = 0 Then
						currentmenu = "levelselectMulti"
						For i = 1 To arraylength(buttons,1) 
							For i2 = 1 To arraylength(buttons,2)
								buttons[i,i2].buttonpic.Unload()
							Next
						Next
						player1i.Unload()
						player2i.Unload()
						title.Unload()
						clearbackground(white)
						delay(100)
						Return
					End If
				Else 
					player2i.opacity = 100
				End If
				enterpressed = True
			Else If Not isKeyDown(Enter) Then
				enterpressed = False
			End If
			If  Not player2selected And isKeyDown(player2.rightKey)  And buttons[Player2Location[1],(Player2Location[2] Mod arraylength(buttons,2))+1].active Then
				player2location[2]+=1
				If player2location[2] > arraylength(buttons,2) Then
					player2location[2] -=arraylength(buttons,2)
				End If	
			Else If	Not player2selected And isKeyDown(player2.leftKey)And buttons[Player2Location[1],((Player2Location[2]-2+ arraylength(buttons,2)) Mod arraylength(buttons,2))+1].active Then
				player2location[2]-=1
				If player2location[2] < 1 Then
					player2location[2] +=arraylength(buttons,2)
				End If
			Else If	Not player2selected And isKeyDown(player2.upKey)  And buttons[((Player2Location[1]-2 + arraylength(buttons,1)) Mod arraylength(buttons,1))+1,Player2Location[2]].active Then
				player2location[1]-=1
				If player2location[1] < 1 Then
					player2location[1] +=arraylength(buttons,1)
				End If	
			Else If	Not player2selected And isKeyDown(player2.downKey) And buttons[(Player2Location[1] Mod arraylength(buttons,1))+1 ,Player2Location[2]].active Then
				player2location[1]+=1
				If player2location[1] > arraylength(buttons,1) Then
					player2location[1] -=arraylength(buttons,1)
				End If
			End If
				
			
			clearkeyboardevents()
			player2i.Show()
			player1i.Show()
			BeginFrame()
			If Not(tempscreenwidth = screenwidth() And tempscreenheight = screenheight()) Then
				clearbackground(steelblue)
				For i = 1 To arraylength(buttons,1) 
					For i2 = 1 To arraylength(buttons,2)
						buttons[i,i2].loadbutton(screenwidth()/2  +25/2 -150*(arraylength(buttons,2))/2 + 150*(i2-1),screenheight()/2 +25-175*(arraylength(buttons,1))/2+ 175 *(i-1))
						//buttons[i,i2].buttonpic.Scale(100 *125/buttons[i,i2].buttonpic.width, 100 *125/buttons[i,i2].buttonpic.height)
						buttons[i,i2].buttonpic.Stamp()
						buttons[i,i2].buttonpic.hide()
					Next
				Next
				title.MoveTo(150-(300 - screenwidth()()/2),10-(300 - screenheight()/2))
				title.stamp()
				For i = 1 To arraylength(buttons,1) 
					For i2 = 1 To arraylength(buttons,2)
						If Not buttons[i,i2].active Then
							pen(False)
							x.Hide()
							x.moveTo(buttons[i,i2].buttonpic.x, buttons[i,i2].buttonpic.y)
							x.Stamp()
						End If
					Next
				Next
				Pen(False)
				color(black)
				MoveTo(-(300 - screenwidth()/2), 475 -(300 - screenheight()/2))
				SetFont ( "Arial", 15, False, False, False )
				Print("Player 1 uses WASD, and Player 2 uses the arrow keys.  \nPress Space to select Player 1, and Enter to select Player 2")
				SetFont ( "Arial", 10, False, False, False )
				refreshscreen()
				tempscreenwidth = screenwidth()
				tempscreenheight = screenheight()
			End If
			player1i.Hide()
			player1i.MoveTo(buttons[Player1Location[1],Player1Location[2]].buttonpic.x, buttons[Player1Location[1],Player1Location[2]].buttonpic.y)
			player1i.Show()
			player2i.Hide()
			player2i.MoveTo(buttons[Player2Location[1],Player2Location[2]].buttonpic.x+ player1i.width, buttons[Player2Location[1],Player2Location[2]].buttonpic.y)
			player2i.Show()
			delay(1)
		End While
		
		currentMenu = "q"
		For i = 1 To arraylength(buttons,1) 
			For i2 = 1 To arraylength(buttons,2)
				buttons[i,i2].buttonpic.Unload()
			Next
		Next
		player1i.Unload()
		player2i.Unload()
		title.Unload()
		clearbackground(white)
		delay(100)
	End Method
	
	//levelselect menu
	Method levelselect(music As Sound, file As String)
		//butons to select levels
		Define lvl1 As button
		Define lvl2 As button
		Define lvl3 As button
		Define lvl4 As button
		Define lvl5 As button
		//Define mainmenu As button
		Define difficulty As button
		Define buttonclicked As Boolean
		Define screensprite As String
		Define title As Sprite
		Define title2 As Sprite
		
		title.Load("Levela.png")
		title2.Load("Selecta.png")
		title.MoveTo(65 + screenwidth()/2-300,250 + screenheight()/2-300)
		title2.MoveTo(400+ screenwidth()/2-300,250+ screenheight()/2-300)
		title.Show()
		title2.Show()
		clearbackground(orange)
		savefile.save(profile)
		savefile.save()
		//change music
		music.LoadFile(file)
		If Not muted Then
			music.playLoop()
		End If
		
		//clear inputs
		clearMouseEvents()
		
		
		beginframe()
		//load buttons
		lvl1.loadbutton(screenwidth()/2-175-125/2,screenheight()/2-(175)-125/2,"level.png")
		lvl2.loadbutton(screenwidth()/2+175 - 125/2,screenheight()/2-(175*2/2)-125/2,"level2.png")
		lvl3.loadbutton(screenwidth()/2-(175*2/2)-125/2,screenheight()/2+175 - 125/2,"level3.png")
		lvl4.loadbutton(screenwidth()/2+175-125/2,screenheight()/2+(175)-125/2,"level4.png")
		If haveunlocked(profile) Then
			lvl5.loadbutton(screenwidth()/2-125/2,screenheight()/2-125/2,"level5.png")
		Else 
			lvl5.loadbutton(screenwidth()/2-125/2,screenheight()/2-125/2,"level5locked.png")
		End If
		//mainmenu.loadbutton(screenwidth()/2-125/2,screenheight()/2+175 -125/2,"Main Menu.png")
		difficulty.loadbutton(screenwidth()/2-125/2-8,screenheight()/2-(175)-125/2,"Difficulty.png")
		//minigame.loadbutton(screenwidth()/2 - 300 + 400,screenheight()/2 - 300 +300,"Arcade.png")
		pen(False)
		If profile.hasbeaten[1,diff] Then
			
			color(Green)
			moveto(lvl1.buttonpic.X-5, lvl1.buttonpic.Y-5)
			pen(True)
			rectangle(lvl1.buttonpic.width+10, lvl1.buttonpic.height+10, True) 
		End If
		pen(False)
		If profile.hasbeaten[2,diff] Then
			
			color(Green)
			moveto(lvl2.buttonpic.X-5, lvl2.buttonpic.Y-5)
			pen(True)
			rectangle(lvl2.buttonpic.width+10, lvl2.buttonpic.height+10, True) 
		End If
		pen(False)
		If profile.hasbeaten[3,diff] Then
			
			color(Green)
			moveto(lvl3.buttonpic.X-5, lvl3.buttonpic.Y-5)
			pen(True)
			rectangle(lvl3.buttonpic.width+10, lvl3.buttonpic.height+10, True) 
		End If
		pen(False)
		If profile.hasbeaten[4,diff] Then
			
			color(Green)
			moveto(lvl4.buttonpic.X-5, lvl4.buttonpic.Y-5)
			pen(True)
			rectangle(lvl4.buttonpic.width+10, lvl4.buttonpic.height+10, True) 
		End If
		pen(False)
		If profile.hasbeaten[5,diff] Then
			color(Green)
			moveto(lvl5.buttonpic.X-5, lvl5.buttonpic.Y-5)
			pen(True)
			rectangle(lvl5.buttonpic.width+10, lvl5.buttonpic.height+10, True) 
		End If
		pen(False)
		refreshscreen()
	
		
		//DO NOT DELETE - means old clicks don't carry over
		While  Not mouse.Event = "ButtonDown"
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(music,file)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			delay(1)
		End While
		
		//while hasn't pushed a button
		While buttonclicked=False			
			If lvl1.isclicked()=True Then
				buttonclicked=True//biutton has been clicked
				screensprite = "Info Screen.png"//load as info screen
				currentmenu = "q"//move on out of menu loop
				setLevel(1)//set level according to button
				
				//applies to all buttons
			Else If lvl2.isclicked()=True Then
				buttonclicked=True
				screensprite = "Info Screen4.png"
				currentmenu = "q"
				setLevel(2)
			Else If lvl3.isclicked()=True Then
				buttonclicked=True
				screensprite = "Info Screen3.png"
				currentmenu = "q"
				setLevel(3)
			Else If lvl4.isclicked()=True Then
				buttonclicked=True
				screensprite = "Info Screen2.png"
				currentmenu = "q"
				setLevel(4)
			Else If lvl5.isclicked()=True Then
				If haveUnlocked(profile) Then
					buttonclicked=True
					screensprite = "Info Screen5.png"
					currentmenu = "q"
					setLevel(5)
				Else
					alert("You have not unlocked level 5 yet", "Locked Feature")
					clearmouseEvents()
				End If
			/*Else If mainmenu.isclicked()=True Then
				screensprite = ""
				buttonclicked = True
				currentmenu = "gametype"*/
			Else If difficulty.isclicked()=True Then
				screensprite = ""
				buttonclicked = True
				currentmenu = "difficulty"
				
			End If
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(currentlevel().music,currentlevel().mus)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			delay(1)
		End While
		//unloads and displays info screen
		lvl1.buttonpic.Unload()
		lvl2.buttonpic.Unload()
		lvl3.buttonpic.Unload()
		lvl4.buttonpic.Unload()
		lvl5.buttonpic.Unload()
		//mainmenu.buttonpic.Unload()
		difficulty.buttonpic.Unload()
		title.Unload()
		title2.Unload()
		//minigame.buttonpic.unload()
		buttonclicked=False
		clearMouseEvents()
		//displays info
		If Not screensprite = "" Then
			lvlinfo.load(screensprite)
		End If
		music.Stop()
		character.lives = 3
		clearbackground(white)
		delay(100)
	End Method
	
	//multiplayer levelselect menu
	Method levelselectMulti( music As Sound, file As String)
		Define tempScreenwidth As Integer = screenwidth()
		Define tempScreenheight As Integer = screenheight()
		//butons to select levels
		Define lvl1 As button
		Define lvl2 As button
		Define lvl3 As button
		Define lvl4 As button
		Define lvl5 As button
		//Define mainmenu As button
		Define difficulty As button
		Define buttonclicked As Boolean
		Define screensprite As String
		Define title As Sprite
		Define title2 As Sprite
		title.Load("Levela.png")
		title2.Load("Selecta.png")
		title.MoveTo(65 + screenwidth()/2-300,250 + screenheight()/2-300)
		title2.MoveTo(400+ screenwidth()/2-300,250+ screenheight()/2-300)
		title.Show()
		title2.Show()
		clearbackground(orange)
		//change music
		music.LoadFile(file)
		If Not muted Then
			music.playLoop()
		End If
		
		//clear inputs
		clearMouseEvents()
		
		
		beginframe()
		//load buttons
		lvl1.loadbutton(screenwidth()/2-175-125/2,screenheight()/2-(175)-125/2,"level.png")
		lvl2.loadbutton(screenwidth()/2+175 - 125/2,screenheight()/2-(175*2/2)-125/2,"level2.png")
		lvl3.loadbutton(screenwidth()/2-(175*2/2)-125/2,screenheight()/2+175 - 125/2,"level3.png")
		lvl4.loadbutton(screenwidth()/2+175-125/2,screenheight()/2+(175)-125/2,"level4.png")
		//If haveunlocked(profile) Then
			lvl5.loadbutton(screenwidth()/2-125/2,screenheight()/2-125/2,"level5.png")
		//Else 
		//	lvl5.loadbutton(screenwidth()/2-125/2,screenheight()/2-125/2,"level5locked.png")
		//End If
		//mainmenu.loadbutton(screenwidth()/2-125/2,screenheight()/2+175 -125/2,"Main Menu.png")
		difficulty.loadbutton(screenwidth()/2-125/2-8,screenheight()/2-(175)-125/2,"Difficulty.png")
		refreshscreen()
	
		
		//DO NOT DELETE - means old clicks don't carry over
		While  Not mouse.Event = "ButtonDown" And getkey() = ""
			delay(1)
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(music, file)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If Not (screenwidth() = tempscreenwidth And screenheight() = tempscreenheight) Then
				beginframe()
				clearbackground(orange)
				//load buttons
				lvl1.loadbutton(screenwidth()/2-175-125/2,screenheight()/2-(175)-125/2)
				lvl2.loadbutton(screenwidth()/2+175 - 125/2,screenheight()/2-(175*2/2)-125/2)
				lvl3.loadbutton(screenwidth()/2-(175*2/2)-125/2,screenheight()/2+175 - 125/2)
				lvl4.loadbutton(screenwidth()/2+175-125/2,screenheight()/2+(175)-125/2)
				lvl5.loadbutton(screenwidth()/2-125/2,screenheight()/2-125/2)
				//mainmenu.loadbutton(screenwidth()/2-125/2,screenheight()/2+175 -125/2)
				difficulty.loadbutton(screenwidth()/2-125/2-8,screenheight()/2-(175)-125/2)
				title.MoveTo(65 + screenwidth()/2-300,250 + screenheight()/2-300)
				title2.MoveTo(400+ screenwidth()/2-300,250+ screenheight()/2-300)
				refreshscreen()
			End If
		End While
		//while hasn't pushed a button
		While buttonclicked=False			
			If lvl1.isclicked()=True Then
				buttonclicked=True//biutton has been clicked
				screensprite = "Info Screen.png"//load as info screen
				currentmenu = "characterSelect"//move on out of menu loop
				setLevel(6)//set level according to button
				
				//applies to all buttons
			Else If lvl2.isclicked()=True Then
				buttonclicked=True
				screensprite = "Info Screen4.png"
				currentmenu = "characterSelect"
				setLevel(7)
			Else If lvl3.isclicked()=True Then
				buttonclicked=True
				screensprite = "Info Screen3.png"
				currentmenu = "characterSelect"
				setLevel(8)
			Else If lvl4.isclicked()=True Then
				buttonclicked=True
				screensprite = "Info Screen2.png"
				currentmenu = "characterSelect"
				setLevel(9)
			Else If lvl5.isclicked()=True Then
				//If haveUnlocked(profile) Then
					buttonclicked=True
					screensprite = "Info Screen5.png"
					currentmenu = "characterSelect"
					setLevel(10)
				//Else
				//	alert("You have not unlocked level 5 yet", "Locked Feature")
				//	clearmouseEvents()
				//End If
			/*Else If mainmenu.isclicked()=True Then
				screensprite = ""
				buttonclicked = True
				currentmenu = "gametype"*/
			Else If difficulty.isclicked()=True Then
				screensprite = ""
				buttonclicked = True
				currentmenu = "difficultyMulti"
				
			End If
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(currentlevel().music,currentlevel().mus)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If Not (screenwidth() = tempscreenwidth And screenheight() = tempscreenheight) Then
				beginframe()
				clearbackground(orange)
				//load buttons
				lvl1.loadbutton(screenwidth()/2-175-125/2,screenheight()/2-(175)-125/2)
				lvl2.loadbutton(screenwidth()/2+175 - 125/2,screenheight()/2-(175*2/2)-125/2)
				lvl3.loadbutton(screenwidth()/2-(175*2/2)-125/2,screenheight()/2+175 - 125/2)
				lvl4.loadbutton(screenwidth()/2+175-125/2,screenheight()/2+(175)-125/2)
				lvl5.loadbutton(screenwidth()/2-125/2,screenheight()/2-125/2)
				//mainmenu.loadbutton(screenwidth()/2-125/2,screenheight()/2+175 -125/2)
				difficulty.loadbutton(screenwidth()/2-125/2-8,screenheight()/2-(175)-125/2)
				title.MoveTo(65 + screenwidth()/2-300,250 + screenheight()/2-300)
				title2.MoveTo(400+ screenwidth()/2-300,250+ screenheight()/2-300)
				refreshscreen()
			End If
		End While
		//unloads and displays info screen
		lvl1.buttonpic.Unload()
		lvl2.buttonpic.Unload()
		lvl3.buttonpic.Unload()
		lvl4.buttonpic.Unload()
		lvl5.buttonpic.Unload()
		//mainmenu.buttonpic.Unload()
		difficulty.buttonpic.Unload()
		title.Unload()
		title2.Unload()
		buttonclicked=False
		clearMouseEvents()
		//displays info
		If Not screensprite = "" Then
			lvlinfo.load(screensprite)
		End If
		music.Stop()
		character.lives = 3
		clearbackground(white)
		delay(100)
	End Method
	
	
	//checks to see if level5 is playable
	Function haveunlocked(p As profile) As Boolean
		If unlocked[diff] Then
			Return True
		End If
		Define i As Integer
		For i = 1 To arraylength(p.hasbeaten, 1)-1
			If Not p.hasBeaten[i,diff] Then
				Return False
			End If
		Next
		Return True
	End Function
	
	//currently useless scroll credits methods - please do NOT quiz on this
	//It does nothing
	//will eventually scroll credits
	Method scrollCredits(pic As String, musicstring As String)
		clearbackground(black)
		Define image As Sprite
		image.Load(pic)
		Image.Scale(100*(min(600, screenwidth())/convertToDecimal(Image.width)), 100*(min(600, screenwidth())/convertToDecimal(Image.width)))
		image.MoveTo(screenwidth()/2 - Image.Width/2,screenheight())
		image.Show()
		Define music As Sound
		music.LoadFile(musicstring)
		If Not muted Then
			music.PlayLoop()
		End If
		clearKeyboardEvents()
		clearMouseEvents()
		Define i As Integer 
			
		For i = 0 To image.Height + 100 + screenheight()
			Image.moveTo(screenwidth()/2 - Image.Width/2, image.Y-1 )
			If mouse.Event = "ButtonDown" Or Not getKey() = "" Then
				i = Image.height+ 100 + screenheight()
			End If
			delay(1)
			
		Next
		clearkeyboardevents()
		clearmouseEvents()
		music.Stop()
		Image.Unload()
		delay(100)
	End Method
	
	//main menu
	//will get input and either stop or shift to main menu
	//go to difficulty select or quit
	Define mini As level
	
	Method mainmenu(music As Sound, file As String)
		Define tempscreenwidth As Integer = screenwidth()
		Define tempscreenheight As Integer = screenheight()
		SetFont ( "Arial", 10, False, False, False )
		Define buttonclicked As Boolean
		Define play As button
		Define quit As button
		//Define multi As button
		Define tutorial As button
		Define highscore As button
		Define logo As button
		Define title As Sprite
		title.Load("Title.png")
		title.MoveTo(max(screenwidth()/2 - 300,0),0)
		title.Show()
		clearbackground(chartreuse)
		clearMouseEvents()
		//beginframe()
		//load buttons
		highscore.loadbutton((screenwidth()-125)/2, screenheight()/2, "highscores.png")
		play.loadButton((screenwidth()-125)/2,screenheight()/2 - 150,"play.png")
		quit.loadButton((screenwidth()-125)/2,screenheight()/2 + 150,"Quit.png")
		//multi.loadbutton(screenwidth()/2 - 300 + 400,screenheight()/2 - 150,"Multiplayer.png")
		tutorial.loadbutton(screenwidth()/2 - 300 + 65, screenheight()/2 - 150, "tutorial.png")
		logo.loadbutton(screenwidth()/2 - 300 + 475,screenheight()/2 - 300 +475,"logo.png")
		
		//refreshscreen()
		//background.LoadFile("level2.wav")
		//begin new music
		music.LoadFile(file)
		If Not music.IsPlaying  And Not muted Then
			music.playLoop()
		End If
		//DO NOT DELETE - means old clicks don't carry over
		While  Not mouse.Event = "ButtonDown"
			delay(1)
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(music, file)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If Not (tempscreenwidth = screenwidth() And tempscreenheight = screenheight()) Then
				title.MoveTo(max(screenwidth()/2 - 300,0),0)
				title.Show()
				clearbackground(chartreuse)
				//beginframe()
				//load buttons
				highscore.loadbutton((screenwidth()-125)/2, screenheight()/2)
				play.loadButton((screenwidth()-125)/2,screenheight()/2 - 150)
				quit.loadButton((screenwidth()-125)/2,screenheight()/2 + 150)
				//multi.loadbutton(screenwidth()/2 - 300 + 400,screenheight()/2 - 150)
				tutorial.loadbutton(screenwidth()/2 - 300 + 65, screenheight()/2 - 150)
				logo.loadbutton(screenwidth()/2 - 300 + 475,screenheight()/2 - 300 +475)
				tempscreenwidth = screenwidth()
				tempscreenheight = screenheight()
				delay(1)
			End If
		End While
		//get button input
		While buttonclicked = False
			If play.isclicked()=True Then
				buttonclicked=True//button has been clicked
				currentmenu = "profileselect"//go to difficulty
			End If
			If quit.isclicked()=True Then//or exit
				stop()
			End If
			//If multi.isclicked() Then
			//	//stop()
			//	buttonclicked=True//button has been clicked
			//	currentmenu = "gamestart"//go to difficulty
			//	
			//End If
			If highscore.isclicked() Then
				buttonclicked=True//button has been clicked
				currentmenu = "highscore"
			End If
			If tutorial.isclicked() Then
				buttonclicked=True//button has been clicked
				currentmenu = "tutorial"
			End If
			If logo.isclicked() Then
				buttonclicked=True//button has been clicked
				currentmenu = "credits"
			End If
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(currentlevel().music,currentlevel().mus)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If Not (tempscreenwidth = screenwidth() And tempscreenheight = screenheight()) Then
				title.MoveTo(max(screenwidth()/2 - 300,0),0)
				title.Show()
				clearbackground(chartreuse)
				//beginframe()
				//load buttons
				highscore.loadbutton((screenwidth()-125)/2, screenheight()/2)
				play.loadButton((screenwidth()-125)/2,screenheight()/2 - 150)
				quit.loadButton((screenwidth()-125)/2,screenheight()/2 + 150)
				//multi.loadbutton(screenwidth()/2 - 300 + 400,screenheight()/2 - 150)
				tutorial.loadbutton(screenwidth()/2 - 300 + 65, screenheight()/2 - 150)
				logo.loadbutton(screenwidth()/2 - 300 + 475,screenheight()/2 - 300 +475)
				tempscreenwidth = screenwidth()
				tempscreenheight = screenheight()
				delay(1)
			End If
		End While
		//unload and clear input
		play.buttonpic.Unload()
		quit.buttonpic.Unload()
		//multi.buttonpic.Unload()
		highscore.buttonpic.unload()
		tutorial.buttonpic.Unload()
		logo.buttonpic.Unload()
		title.Unload()
		buttonclicked=False
		clearMouseEvents()
		music.Stop()
		delay(100)
	End Method
	
	//loads the tutorial
	Method Playtutorial()
		Define tempscreenwidth As Integer = screenwidth()
		Define tempscreenheight As Integer = screenheight()
		
		Define sprites As String[] = {"tut1.png", "tut2.png","tut3.png","tut3part2.png","tut4.png","tut5.png","tut6.png","tut7.png","tut8.png","tut9.png","tut10.png","tut11.png","tut12.png","tut13.png","tut14.png","tut15.png","tut16.png","tut17.png","tut18.png","tut19.png","tut20.png","tut21.png","tut22.png","tut23.png","tut24.png", "tut25.png"}
		
		Define i As Integer
		clearbackground(black)
		pen(False)
		moveto(0,0)
		i = 1
		Define display As sprite
		While Not i > arraylength(sprites)
			display.load(sprites[i])
			display.scale(100.0*(min(screenheight(),screenwidth())/convertToDecimal(display.Width)),100.0*(min(screenwidth(),screenheight())/convertToDecimal(display.Height)))
			If display.Width > screenwidth()  And screenwidth() < screenheight() Then
				display.scale(100.0 * screenwidth()/display.width,100.0 * screenwidth()/display.width)
			Else If display.Height > screenheight() Then
				display.scale(100.0 * screenheight()/display.height,100.0 * screenheight()/display.height)
			End If
			display.MoveTo((screenwidth() - display.width)/2,(screenheight() - display.height)/2)
			//PrintLine(i + " " + display.width + " " + display.height + " " + display.ScaleX + " " + display.scaley)
			display.Show()
			Define advance As Boolean = False
			While Not advance
				If iskeydown(Escape) Then 
					i = arraylength(sprites) +1
					advance = True
				Else If isKeyDown(Left) Then
					If i > 1 Then 
						i -=1
						advance = True
					End If
				Else If iskeydown(right) Then
					i += 1
					advance = True
				End If
				//only checks first changed direction -odd
				If Not (screenwidth() = tempscreenwidth And screenheight() = tempscreenheight) Then
					display.scale(100.0*(min(screenheight(),screenwidth())/convertToDecimal(display.Width)),100.0*(min(screenwidth(),screenheight())/convertToDecimal(display.Height)))
					If display.Width > screenwidth()  And screenwidth() < screenheight() Then
						display.scale(100.0 * screenwidth()/display.width,100.0 * screenwidth()/display.width)
					Else If display.Height > screenheight() Then
						display.scale(100.0 * screenheight()/display.height,100.0 * screenheight()/display.height)
					End If
					display.MoveTo(max((screenwidth() - display.width)/2,0),max((screenheight() - display.height)/2, 0))
					tempscreenwidth = screenwidth()
					tempscreenheight = screenheight()
				End If
				delay(1)//DO NOT DELETE EVER (EVER)
			End While
			
			clearkeyboardevents()
			display.Unload()
			
		End While
		delay(100)
	End Method
	
	//displays text
	
	
	
	//adds main menu button to show high scores
	Method DisplayHighScores()
		//at the moment, just displays total high scores
		Define levelnum As Integer
		Define diffnum As Integer
		Define rank As Integer
		Define mainmenu As button
		
		Define buttonclicked As Boolean = False
		Mainmenu.loadButton(screenwidth() - 150,screenheight() - 150, "Main Menu.png")
		//clear screen
		showHighScores(False)
		While buttonclicked = False
			If mainmenu.isclicked()=True Then
				buttonclicked=True
				currentmenu = "main"
			End If
			If isKeyDown("m")  And Not Mpressed Then
				
				mute()
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			Mainmenu.loadButton(screenwidth() - 150,screenheight() - 150)
			delay(1)
		End While
		mainmenu.buttonpic.Unload()
		delay(100)
	End Method
		
	
	//difficulty menu
	//called from main menu
	Method difficultymenu(music As sound, file As String)
		Define easy As button
		Define medium As button
		Define hard As button
		Define Chesney As button
		Define god As button
		Define mainMenu As button
		Define buttonclicked As Boolean
		Define title As Sprite
		title.Load("Difficultyselect.png")
		title.MoveTo(30 + max(screenwidth()/2 - 300,0),0)
		title.Show()
		clearbackground(lightskyblue)
		
		clearMouseEvents()
		beginframe()
		music.LoadFile(file)
		If Not muted Then
			music.PlayLoop()
		End If
		//load buttons
		easy.loadbutton(300 + screenwidth()/2 - 300,50+ screenheight()/2 - 300,"easy.png")
		medium.loadbutton(300+ screenwidth()/2 - 300,200+ screenheight()/2 - 300,"normal.png")
		hard.loadbutton(300+ screenwidth()/2 - 300,350+ screenheight()/2 - 300,"hard.png")
		Chesney.loadbutton(100+ screenwidth()/2 - 300,200+ screenheight()/2 - 300, "Chesney.png")
		Mainmenu.loadButton(100+ screenwidth()/2 - 300,350+ screenheight()/2 - 300, "back.png")
		If godEnabled Then
			god.loadbutton(450+ screenwidth()/2 - 300,200+ screenheight()/2 - 300, "Unfair.png")
		End If
		refreshscreen()
		//DO NOT DELETE - means old clicks don't carry over
		While  Not mouse.Event = "ButtonDown"
			delay(1)
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(music, file)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
		End While
		While buttonclicked = False
			If easy.isclicked()=True Then
				buttonclicked=True//button is clicked
				setdifficulty(2)//set difficulty
				currentmenu = "levelselect"//go to level select
				
				//repeat for all
			End If
			 If medium.isclicked()=True Then
				buttonclicked=True
				setdifficulty(3)
				currentmenu = "levelselect"
			End If
			If hard.isclicked()=True Then
				buttonclicked=True
				setdifficulty(4)
				currentmenu = "levelselect"
			End If 
			If Chesney.isclicked()=True Then
				buttonclicked=True
				setdifficulty(1)
				currentmenu = "levelselect"
			End If
			If godEnabled Then
				If god.isclicked() Then
					buttonclicked=True
					setdifficulty(5)
					currentmenu = "levelselect"
				End If
			End If
			If mainmenu.isclicked()=True Then
				buttonclicked=True
				currentmenu = "gametype"
			End If
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(currentlevel().music,currentlevel().mus)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
		End While
		//unload butons and destroy input
		easy.buttonpic.Unload()
		medium.buttonpic.Unload()
		hard.buttonpic.Unload()
		chesney.buttonpic.Unload()
		mainmenu.buttonpic.Unload()
		god.buttonpic.Unload()
		title.Unload()
		buttonclicked=False
		clearMouseEvents()
		music.Stop()
		delay(100)
	End Method
	
	Method difficultymenuMulti(music As sound, file As String)
		Define easy As button
		Define medium As button
		Define hard As button
		Define Chesney As button
		Define mainMenu As button
		Define buttonclicked As Boolean
		Define god As button
		Define title As Sprite
		title.Load("Difficultyselect.png")
		title.MoveTo(30 + max(screenwidth()/2 - 300,0),0)
		title.Show()
		clearbackground(lightskyblue)
		clearMouseEvents()
		beginframe()
		//load buttons
		easy.loadbutton(300+ screenwidth()/2 - 300,50+ screenheight()/2 - 300,"easy.png")
		medium.loadbutton(300+ screenwidth()/2 - 300,200+ screenheight()/2 - 300,"normal.png")
		hard.loadbutton(300+ screenwidth()/2 - 300,350+ screenheight()/2 - 300,"hard.png")
		Chesney.loadbutton(100+ screenwidth()/2 - 300,200+ screenheight()/2 - 300, "Chesney.png")
		Mainmenu.loadButton(100+ screenwidth()/2 - 300,350+ screenheight()/2 - 300, "back.png")
		If godEnabled Then
			god.loadbutton(450+ screenwidth()/2 - 300, 200+ screenheight()/2 - 300, "Unfair.png")
		End If
		refreshscreen()
		music.LoadFile(file)
		If Not muted Then
			music.PlayLoop()
		End If
		//DO NOT DELETE - means old clicks don't carry over
		While  Not mouse.Event = "ButtonDown"
			delay(1)
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(music, file)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
		End While
		While buttonclicked = False
			If easy.isclicked()=True Then
				buttonclicked=True//button is clicked
				setdifficulty(2)//set difficulty
				currentmenu = "levelselectMulti"//go to level select
				
				//repeat for all
			Else If medium.isclicked()=True Then
				buttonclicked=True
				setdifficulty(3)
				currentmenu = "levelselectMulti"
			Else If hard.isclicked()=True Then
				buttonclicked=True
				setdifficulty(4)
				currentmenu = "levelselectMulti"
			Else If Chesney.isclicked()=True Then
				buttonclicked=True
				setdifficulty(1)
				currentmenu = "levelselectMulti"
			Else If mainmenu.isclicked()=True Then
				buttonclicked=True
				currentmenu = "gametype"
			Else If godenabled Then
				If god.isclicked() Then
					buttonclicked=True
					setdifficulty(5)
					currentmenu = "levelselectMulti"
				End If
			End If
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(currentlevel().music,currentlevel().mus)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
		End While
		//unload butons and destroy input
		easy.buttonpic.Unload()
		medium.buttonpic.Unload()
		hard.buttonpic.Unload()
		chesney.buttonpic.Unload()
		mainmenu.buttonpic.Unload()
		god.buttonpic.Unload()
		title.Unload()
		buttonclicked=False
		clearMouseEvents()
		music.Stop()
		delay(100)
	End Method
	
	Method typemenu(music As sound, file As String)
		Define single As button
		Define mainmenu As button
		Define multi As button
		Define minigame As button
		Define buttonclicked As Boolean = False
		music.LoadFile(file)
		If Not muted Then
			music.PlayLoop()
		End If
		single.loadbutton(300+ screenwidth()/2 - 300,50+ screenheight()/2 - 300, "Singleplayer.png")
		multi.loadbutton(300+ screenwidth()/2 - 300,200+ screenheight()/2 - 300, "Multiplayer.png")
		minigame.loadbutton(300+ screenwidth()/2 - 300,350+ screenheight()/2 - 300, "Arcade.png")
		Mainmenu.loadButton(100+ screenwidth()/2 - 300,350+ screenheight()/2 - 300, "Main menu.png")
		clearmouseevents()
		clearkeyboardevents()
		clearbackground(green)
		While  Not mouse.Event = "ButtonDown"
			delay(1)
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(music, file)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
		End While
		While Not buttonclicked 
			If multi.isclicked() Then
				updateUnlockables(False, True)
				buttonclicked = True
				currentmenu = "difficultymulti"
				setlevel(6)
				
			Else If minigame.isclicked() Then 
				buttonclicked = True
				currentmenu = "q"
				setlevel(0)
				setdifficulty(0)
			Else If mainmenu.isclicked() Then 
				buttonclicked = True
				currentmenu = "main"
			Else If single.isclicked() Then 
				updateUnlockables(False, False)
				buttonclicked = True
				currentmenu = "difficulty"
				setlevel(1)
				
			End If
			delay(1)
			If isKeyDown("m")  And Not Mpressed Then
				
				mute(music, file)
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
		End While
		
		single.buttonpic.Unload()
		multi.buttonpic.Unload()
		minigame.buttonpic.Unload()
		Mainmenu.buttonpic.Unload()
		clearbackground(green)
		music.stop()
	End Method
			
		
	//End Method
	
	Method profileselect(music As sound, file As String)
		music.Stop()
		console.fontcolor=white
		savefile.currentmenu = "select"
		While equals(savefile.currentmenu,"done")= False And equals(savefile.currentmenu,"main") = False
			If savefile.currentmenu = "select" Then
				savefile.selectmenu(profile)
			Else If savefile.currentmenu = "create" Then
				savefile.displaysaves(False,False,False,True,profile, True)
				savefile.createprofile(profile)
			Else If savefile.currentmenu = "delete" Then
				savefile.deletemenu(profile)
			End If	
		End While	
		console.Clear()
		console.Hide()
		If savefile.currentmenu= "done" Then
			currentmenu = "gametype"
			savefile.save(profile)
			savefile.save()
			//updateUnlockables(False, False)
		Else
			currentmenu = "main"
		End If	
			
		
	End Method
	
	//Method difficultyMini()
		
	//End Method
	
	Method updateunlockables(alert As Boolean, mult As Boolean)
		Define i As Integer
		Define i2 As Integer
		Define levelsbeaten As Integer
		Define maxscore As Integer
		Define maxtotalscore As Integer
		If alert And haswon Then
			profile.hasbeaten[clevel,diff] = True
		End If
		savefile.save(profile)
		savefile.save()
			
		For i = 1 To arraylength(profile.hasbeaten,1)
			For i2 = 1 To arraylength(profile.hasbeaten,2)
				If profile.hasbeaten[i,i2] Then
					levelsbeaten +=1
					If maxscore < profile.scores[i,i2] Then
						maxscore = profile.scores[i,i2]
					End If
				End If
			Next
		Next
		For i = 1 To arraylength(profile.totalScores)
			If maxtotalscore< profile.totalScores[i] Then
				maxtotalscore= profile.totalScores[i]
			End If
		Next
		If levelsbeaten>=5 And donutlocked Then
			If alert Then
				Alert("New Multiplayer Character: Donut\nKeep playing for more unlockables", "New Character")
			End If
			donutlocked =False
		Else If levelsbeaten<5 Then
			donutlocked =True
		End If
	
		If profile.totalScores[3] >= 50000  And levelsbeaten >=10 And sodalocked And Not donutlocked Then
			If alert Then
				Alert("New Multiplayer Character: Soda", "New Character")
			End If
			sodalocked = False	
		Else If Not( profile.totalscores[3] >= 50000  And levelsbeaten >=10) Then
			sodalocked = True
		End If
	
	
		If levelsbeaten>=20 And Not godenabled Then
			If alert Then
				Alert("God Difficulty now enabled", "New Difficulty")
			End If
			godEnabled = True
		Else If levelsbeaten<20 Then
			godenabled = False
		
		End If
		
		
		
		
		If maxscore >= 10000  And frieslocked And levelsbeaten >5 Then
			If alert Then
				Alert("New Multiplayer Character: Fries", "New Character")
			End If
			friesLocked = False
		Else If Not(maxscore >= 10000 And levelsbeaten >5) Then
			friesLocked = True
		
		End If
		
		If levelsbeaten>=20 And burgerlocked  And Not(sodalocked Or donutlocked Or frieslocked)   Then
			If alert Then
			
				Alert("New Multiplayer Character: Burger\n", "New Character")
			End If
			burgerlocked  = False
		Else If Not ( levelsbeaten>=20 And Not(sodalocked Or donutlocked Or frieslocked))   Then
			burgerlocked = True
		
	
		End If
	


		If levelsbeaten >=25 And Not cheats And Not mult Then
			Alert("Cheats:\nDifficulty\nPress 1 through 5 in game to switch to applicable difficulty\n(1 = Training, 5 = God)\nPress and hold 't' and 'y' to add or subtract time\npress and hold '>' and '<' to add or subtract health\nPress 'g' to respawn good foods\nPress 'e' to respawn enemies\nPress 'i' to trigger immortality","Cheating enabled")
			cheats = True
		Else If cheats And ((levelsbeaten <25) Or mult) Then
			cheats = False
			Alert("Cheats disabled","Cheating disabled")
		End If



	
		
		
	End Method
	
	Method InitMinigame()
		clearbackground(white)
		mini.mus = "level8.wav"
		Define sidegap As Integer =20
		Define n As Integer
		Define timer As Timer
		Define enemyset As genericlist
		Define goodset As arcadeobj[5]
		healthbar.loadbar(425 *screenwidth()/600,0,150*screenwidth()/600,25)
		healthbar.label = "Health"
		lifeSprite.Load("Dr. Meatloaf Lives.png")
		lifesprite.Scale(100*30/lifesprite.Width, 100*30/lifesprite.height)
		character.lives=3
		character.type = 8
		
		
		//character.psprite.MoveTo(screenwidth()/2,(screenheight()-ygap)/2
		
		character.enemiesHit = 0
		character.goodFoodsHit = 0
		character.score = 0
		totalgametime = 0
		Define quit As Boolean
		While character.lives > 0 And Not quit
			clearbackground(white)
			beginframe()
			character.loadplayersimple(screenwidth()/2,(screenheight()+ygap)/2)
			character.moveplayersimple(0,0)
			character.health = 50
			displayplayer(character)
			character.displayplayersimple()
			For n = 1 To 3 
				Define e As arcadeobj
				enemyset.Add(e)
			Next
			For n = 1 To enemyset.Count
				Define e  As arcadeobj = enemyset.Item(n)
				e.load(2,sidegap)
				While abs(e.xpos - character.xpos)<100
					e.xpos = random(e.minxbound,e.maxxbound)
				End While
				While abs(e.ypos - character.ypos)<100
					e.ypos = random(e.minybound,e.maxybound)
				End While
				e.MoveobjectSimple(e.xpos,e.ypos,True)
				enemyset.Item(n) = e
			Next
			For n = 1 To arraylength(goodset)
				goodset[n].load(1,sidegap)
				Define e  As arcadeobj = goodset[n]
				e.load(2,sidegap)
				While abs(e.xpos - character.xpos)<100
					e.xpos = random(e.minxbound,e.maxxbound)
				End While
				While abs(e.ypos - character.ypos)<100
					e.ypos = random(e.minybound,e.maxybound)
				End While
				e.MoveobjectSimple(e.xpos,e.ypos,True)
				enemyset.Item(n) = e
			Next
			refreshscreen()
			scrollGamemini(sidegap,goodset,enemyset, True)
			quit = runminigame(sidegap,goodset,enemyset)
			delay(500)
		End While
		//If Not quit Then
		playagainMini(quit)
		//End Ifalse
		currentmenu = "gametype"
		leavecurrentlevel()
		For n = 1 To enemyset.count
			Define e  As arcadeobj = enemyset.Item(n)
			e.objsprite.Unload()
		Next
		For n = 1 To arraylength(goodset)
			goodset[n].objsprite.Unload()
		Next
	End Method
	
	
	Method scrollgameMini(sgap As Integer, gfoods As arcadeobj[], enemies As genericlist, paused As Boolean)
		Define n As Integer
		healthbar.loadbar(425 *screenwidth()/600,0,150*screenwidth()/600,25)
		BeginFrame()
		clearbackground(white)
		pen(False)
		moveto(screenwidth()-sgap,screenheight()-sgap)
		pen(True)
		color(black)
		moveto(screenwidth()-sgap,ygap)
		moveto(sgap,ygap)
		moveto(sgap,screenheight()-sgap)
		moveto(screenwidth()-sgap,screenheight()-sgap)
		For n = 1 To arraylength(gfoods)
			gfoods[n].minxbound = sgap
			gfoods[n].minybound = ygap
			gfoods[n].maxxbound = screenwidth()-sgap-gfoods[n].objsprite.Width
			gfoods[n].maxybound = screenheight()-sgap-gfoods[n].objsprite.height
		Next	
		For n = 1 To enemies.count
			Define e As arcadeobj = enemies.item(n)
			e.minxbound = sgap
			e.minybound = ygap
			e.maxxbound = screenwidth()-sgap-e.objsprite.Width
			e.maxybound = screenheight()-sgap-e.objsprite.height
		Next
		For n = 1 To character.lives
			lifeSprite.MoveTo(150 + (n-1)*1.5*lifesprite.Width, 40)
			lifeSprite.Stamp()
 		Next
		If character.health > 65 Then
			color(limegreen)
			character.playerSpeed = 9
		Else If character.health >=35 Then
			color(yellow)
			character.playerSpeed = 7
		Else If character.health >=0 Then
			healthbar.blink(red)
			character.playerSpeed = 5
		Else 
			color(red)
		End If
		//fill in health bar
		healthbar.draw(convertTodecimal(1)-healthbar.converttodec(character.health, 100))
		Pen(False)
		moveTO(0,40)
		print("Score: " + character.score)
		moveTo(100, 40)
		Print("Lives: ")
		If Not paused Then
			moveplayermini(character, sgap)
			moveobjectmini(sgap,gfoods,enemies)
			//doevents()
		End If
		displayplayer(character)
		character.displayplayersimple()
		character.SetScore(20*totalGameTime + character.enemiesHit*-50 + character.goodFoodsHit*100)
		refreshscreen()
	End Method
	
	//Define character1 As player
	
	Function RunMinigame(sgap As Integer, goodfoods As arcadeobj[], enemies As genericlist) As Boolean
		mini.music.LoadFile(mini.mus)
		If Not muted Then
			mini.music.Playloop()
		End If
		Define quit As Boolean = False
		Define paused As Boolean = False
		Define PauseSprite As Sprite
		Define n As Integer
		Define time As Decimal
		Define ppressed As Boolean
		pauseSprite.Load("Pause.png")
		Define GameTime As timer
		gametime.Start()
		clearkeyboardevents()
		clearmouseevents()
		While getKey() = "" And GameTime.Elapsed< 5 
			delay(1)
		End While		
		While character.health > 0 And Not iskeydown("q")
			If iskeydown("p") And Not paused Then
				paused = True
				clearkeyboardevents()
				clearmouseevents()
				pauseSprite.hide()
				pauseSprite.Scale(300,300)
				pauseSprite.moveTo((screenwidth()-pauseSprite.width)/2, (screenheight()+ygap-pauseSprite.height)/2)
				pauseSprite.Show()
				
			Else If iskeydown("p") Then
				paused = False
				clearkeyboardevents()
				clearmouseevents()
				pauseSprite.hide()
				While getKey() = "" And GameTime.Elapsed< 5 
					delay(1)
				End While	
			End If	
			If isKeyDown("m")  And Not Mpressed Then
				
				mute()
				Mpressed = True
			Else If Not isKeyDown("m") Then
				Mpressed = False
			End If
			If Not paused Then
				time = gametime.Elapsed
				delay(30-1000*time)
				If time < .5 Then
					totalgametime+=time
				End If
				gametime.Reset()
				//can we move all features into here??
				//move enemies and carrots
				scrollgamemini(sgap,goodfoods,enemies, paused)
				For n = 1 To arraylength(goodfoods)
					If goodfoods[n].checkstatus(character) Then
						Define e As arcadeobj
						e.load(2,sgap)
						e.alive = False
						enemies.Add(e)
					End If
				Next	
				For n = 1 To enemies.Count
					Define e As arcadeobj = enemies.Item(n)
					If e.checkstatus(character) Then
						enemies.remove(e)
					End If
				Next	
				
			Else
				scrollgamemini(sgap,goodfoods,enemies, paused)
				//delay(1)
			End If
		End While	
		If iskeydown("q") Then
			quit = True
		End If
		mini.music.Stop()
		Define i As Integer
		For i = enemies.Count To 1 Step -1
			Define e As arcadeobj = enemies.item(i)
			e.objsprite.Unload()
			enemies.RemoveAt(i)
		Next
		Return quit
		//delay 30 -timeelapsed - alot of things depend on CONSTANT frame length
	End Function
	
	Method MovePlayerMini(p As player, sgap As Integer)
		Define moving As Boolean = False
		If iskeydown(p.upKey) Then
			p.MovePlayerSimple(0,max(-character.psprite.Y+ygap,-p.playerspeed))
			p.Direction = 0	
			moving = True
		End If	
		If iskeydown(p.leftKey) Then
			p.MovePlayerSimple(max(-p.playerspeed,-character.psprite.X+sgap),0)
			p.Direction = 3
			moving = True
		End If	
		If iskeydown(p.downKey) Then
			p.MovePlayerSimple(0,min(-p.psprite.Y +screenheight()-sgap-p.psprite.Height,p.playerspeed))
			p.Direction = 2	
			moving = True
		End If	
		If iskeydown(p.rightKey) Then
			p.MovePlayerSimple(min(p.playerspeed,-p.psprite.X +screenwidth()-sgap-p.psprite.width),0)
			p.Direction = 1
			moving = True
		End If	
		If moving Or Not p.psprite.ActiveFrame = 1 Then
			p.psprite.AnimationTimeline.Paused = False
		Else
			p.psprite.AnimationTimeline.Paused = True
		End If
		//displayplayer(p)
	End Method
	
	Method moveobjectmini (sgap As Integer, gfoods As arcadeobj[], enemies As genericlist)
		Define n As Integer
		For n = 1  To arraylength(gfoods)
			gfoods[n].MoveobjectSimple(gfoods[n].calcmovex(),gfoods[n].calcmovey(),False)
		Next
		For n = 1  To enemies.count
			Define e As arcadeobj = enemies.Item(n)
			e.MoveobjectSimple(e.calcmovex(),e.calcmovey(),False)
		Next
	End Method
	
	Method PlayAgainMini(quit As Boolean)
		ShowConsole()
		If Not quit Then
			If character.score > profile.arcadescore Then
				profile.arcadescore = character.score
			End If
			If profile.arcadescore > savefile.highscores[7,1].score Then
				savefile.highscores[7,1].score = profile.arcadescore
				savefile.highscores[7,1].name = profile.name
			End If
		End If
		savefile.save(profile)
		savefile.save()
		savefile.savehighscores()
		ConsoleWrite("\n"+ "Total Time: " +convertToclock(totalGameTime)+"\nTotal Enemies Hit: " + character.enemiesHit + "\nTotal Good Foods Eaten: " + character.goodFoodsHit + "\nScore:"+ character.score + "\n")
		//wipe old input
		clearMouseEvents()
		clearKeyboardEvents()
		//wait for input to advance
		ConsoleWrite("\n\nHit any key to continue\n")
		While Not mouse.Event = "ButtonDown" And getKey() = ""
			delay(1)
		End While
		HideConsole()
		ClearConsole()
		
		//if quit is neccessary, then exit to levelselect
		
		//currentmenu = "main"
		
		
	End Method
	
End Program